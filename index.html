<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="chinese">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="loser的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="loser的博客">
<meta property="og:locale" content="chinese">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="loser的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>loser的博客</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="chinese">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">loser的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/17/高级反调试技术/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/17/高级反调试技术/" itemprop="url">高级反调试技术</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-17T19:53:49+08:00">
                2019-06-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h1 id="高级反调试技术"><a href="#高级反调试技术" class="headerlink" title="高级反调试技术"></a>高级反调试技术</h1><p>PE保护器中使用的高级反调试技术有一些共同特征，如技术难度较高等，令代码逆向分析人员身心俱疲。</p>
<p>应用了这些高级反调试技术的程序包含大量垃圾代码、条件分支语句、循环语句、加密/解密代码以及“深不见底”的调用树( Call-Tree),代码逆向分析人员一旦陷人其中便会迷失方向,根本无法访问到实际要分析的代码，只是在无关紧要的地方徘徊。这些混乱加上代码中动态反调试技术的干扰，使代码逆向分析人员处于束手无策的尴尬境地。</p>
<p>当然，这并不是说调试全无可能，只是说调试的难度大大增加了。对于一名经验丰富的代码逆向分析人员而言，分析PE保护器也是一个非常棘手的问题,需要花费大量的时间与精力。而且，“完美分析”本身就是极其艰巨的任务。</p>
<!--more-->
<h1 id="垃圾代码"><a href="#垃圾代码" class="headerlink" title="垃圾代码"></a>垃圾代码</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/12/动态反调试技术/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/12/动态反调试技术/" itemprop="url">动态反调试技术</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-12T15:33:18+08:00">
                2019-06-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>利用动态反调试技术可以不断阻止对程序代码的跟踪调试，目的就是隐藏和保护程序代码与数据，使之无法进行逆向分析。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/06/12/动态反调试技术/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/09/静态反调试技术/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/09/静态反调试技术/" itemprop="url">静态反调试技术</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-09T21:10:44+08:00">
                2019-06-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="PEB"><a href="#PEB" class="headerlink" title="PEB"></a>PEB</h1><p>PEB中与反调试技术密切相关的成员有如下几个</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/06/09/静态反调试技术/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/03/IA-32指令/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/03/IA-32指令/" itemprop="url">IA-32指令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-03T20:12:38+08:00">
                2019-06-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="IA-32指令"><a href="#IA-32指令" class="headerlink" title="IA-32指令"></a>IA-32指令</h1><p>简言之 指令是指CPU能够认读的机器语言 IA-32指令指IA-32系列CPU使用的指令<br><img src="1.png" alt=""><br>如图 粗线框中的每一行都是一条指令 编程人员使用程序语言（C/C++ java python等）编写程序 而CPU则使用机器语言 编程人员编写的程序源代码需要编译/链接后转换为CPU可以读懂的机器语言</p>
<h1 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h1><p>如图IA-32指令由三部分组成<br><img src="2.png" alt=""><br>下来对部分指令进行说明</p>
<h2 id="指令前缀"><a href="#指令前缀" class="headerlink" title="指令前缀"></a>指令前缀</h2><p>指令前缀（可选项）：指令前缀prefix大小为一个字节，用来辅助说明指令的具体功能，可选项</p>
<p>例如：<strong>66</strong>：81FE 4746 CMP SI,474加粗字体就是指令前缀，后面跟一个：。</p>
<h2 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h2><p>opand，这个没啥好说的，必选项,大小为1到3字节，通常为一个字节，多字节后面会有说明.例如：66：<strong>81</strong>FE 4746 CMP SI,474</p>
<h2 id="ModR-M"><a href="#ModR-M" class="headerlink" title="ModR/M"></a>ModR/M</h2><p>Mod R/M 大小为一个字节，由三部分组成，分别为 Mod（字节前两位），Reg（字节中间三位），R/M(字节后三位)。Mod R/M的主要功能就是说明操作数的寻址方式，包括寄存器选择，内存操作数的偏移等等。例如：66：81<strong>FE</strong> 4746 CMP SI,474</p>
<h2 id="SIB"><a href="#SIB" class="headerlink" title="SIB"></a>SIB</h2><p>SIB，大小为一个字节，也是用来辅助操作数寻址的，一般用于辅助Mod R/M,当出现基址加变址寻址或者基址寻址时要用到。8984<strong>24</strong>  50020000 Mov [ESP+250]，EAX.</p>
<h2 id="位移"><a href="#位移" class="headerlink" title="位移"></a>位移</h2><p>位移也是可选项 操作码的操作数为内存地址时 用来表示位移操作 C705 <strong>A8A04000</strong> 02000000   mov     dword ptr ds:[<strong>0x40A0A8</strong>], 0x2</p>
<h2 id="立即数"><a href="#立即数" class="headerlink" title="立即数"></a>立即数</h2><p>立即数也是一个可选项 操作码的操作数为常量时 该常量就被称为立即数 C705 A8A04000 <strong>02000000</strong>   mov     dword ptr ds:[0x40A0A8], <strong>0x2</strong></p>
<h1 id="指令解析手册"><a href="#指令解析手册" class="headerlink" title="指令解析手册"></a>指令解析手册</h1><h2 id="下载IA-32用户手册"><a href="#下载IA-32用户手册" class="headerlink" title="下载IA-32用户手册"></a>下载IA-32用户手册</h2><p>为了能够顺利解析IA-32的机器码，我们应该下载Intel的开发手册，然后打印出有关指令解析的图表。下载网址为：<a href="http://www.intel.com/products/processor/manuals" target="_blank" rel="noopener">http://www.intel.com/products/processor/manuals</a></p>
<h2 id="打印指令解析手册"><a href="#打印指令解析手册" class="headerlink" title="打印指令解析手册"></a>打印指令解析手册</h2><p>table 2-2 32-bit Addressing forms with the ModR/M Byte， page 510</p>
<p>table 2-3 32-bit Addressing forms with the SIB Bytes， page 511</p>
<p>APPENDIX A ，page 487</p>
<p>A.2.1 Codes for Addressing Method</p>
<p>A.2.2 Code for Operand Type</p>
<p>Table A-2 .one –byte Opcode Maps</p>
<p>Table A-3.two-bytes Opcode Maps</p>
<p>pages ：2519-2530</p>
<p>Table A-6 Opcode Extension for one-and Two Opcodes by Group Number</p>
<p>pages：2535-2537</p>
<h1 id="指令解析练习"><a href="#指令解析练习" class="headerlink" title="指令解析练习"></a>指令解析练习</h1><h2 id="操作码映射"><a href="#操作码映射" class="headerlink" title="操作码映射"></a>操作码映射</h2><p>首先我们解析一个长度为一的操作码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">41	INC ECx</span><br></pre></td></tr></table></figure></p>
<p>对应的表是Table A-2 .one –byte Opcode Maps<br>指令：41，将指令拆成4和1，4对应表的行向量，1对应表列向量，如下图:</p>
<p><img src="3.png" alt=""><br>由上图可知41对应的指令为INC ECX,我们可以使用od来印证正确性。如下图：</p>
<p><img src="4.png" alt=""><br>至于为什么用寄存器ECX,是因为IA-32默认使用32位寄存器。</p>
<h2 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">68 A0B44000</span><br></pre></td></tr></table></figure>
<p>我们先拆分68为6和8还是使用表Table A-2 .one –byte Opcode Maps</p>
<p>来查找操作指令。如下图：<br><img src="5.png" alt=""><br>上图可知是push指令，操作数的寻址方式有Iz规定，我们接下来来使用code for Addressing Method和表code for opcode type 来查看具体信息，第一个大写字符I规定了寻址方式，在code for Addressing Method查找对应含义，如下图:</p>
<p><img src="6.png" alt=""><br>表示这是一个立即数。第二个小写字符z在表code for opcode type 中查找，如下图：<br><img src="7.png" alt=""><br>z表示使用的字符大小为字或者双字，由于是在32位系统中默认使用双字（使用单字的情况是使用前缀来说明），故这里是个双字，Iz一起就是表明使用双字立即数，表明指令68 A0B44000中A0B44000就是使用的双字立即数。完整的指令翻译过来就是：</p>
<p>Push 0004B4A0（注意汇编中的数据存储），我们也来使用od验证一下。如下图：<br><img src="8.png" alt=""></p>
<h2 id="带有Mod-R-M的指令"><a href="#带有Mod-R-M的指令" class="headerlink" title="带有Mod R/M的指令"></a>带有Mod R/M的指令</h2><p>上面两个指令都很简单，除了操作码就是操作数本身，下面来解析带有Mod R/M的指令，现在来看指令89C1。先解析89如下图：</p>
<p><img src="9.png" alt=""><br>上图可知指令是OR指令，两个操作数的说明分别是Ev和Gv，这两个使用表A.2.1 Codes for Addressing Method和表A.2.2 Code for Operand Type来查看。Ev的查询结果如下图：</p>
<p><img src="10.png" alt=""><br>这里应该主义的是，E中已经说明了要使用通用寄存器或者内存操作数，并且要使用Mod R/M来进行辅助说明，所以在操作码89后的C1就是ModR/M,Ev统一起来就是可以使用双子寄存器操作数或者双子内存操作数，具体的要使用ModR/M字段来辅助说明。我们把ModR/M字段的内容c1（1100，0001）拆成三部分：Mod：11，Reg：000，R/M：001，下面根据这个信息来查询表table 2-2 32-bit Addressing forms with the ModR/M Byte，如下图：</p>
<p><img src="11.png" alt=""><br>使用三个字段分别找到Ev对应的寄存器是ECX，Gv使用的寄存器是EAX，因此完整指令应该为89C1 OR ECX,EAX,用od验证如下图:</p>
<p><img src="12.png" alt=""></p>
<h2 id="带有Group指令解析"><a href="#带有Group指令解析" class="headerlink" title="带有Group指令解析"></a>带有Group指令解析</h2><p>Group指令与ModR/M结合使用。Group给指令带来了更为丰富的变化，也是的指令解析更为复杂。例如：83C3 12,先解析83，如下图：</p>
<p><img src="13.png" alt=""><br>上图可以看出该指令带group指令。对于group指令我们还需查询表Table A-6 Opcode Extension for one-and Two Opcodes by Group Number。我们使用ModR/M（C3=1100,0011）的第二个字段Reg(000)来查询，如下图：</p>
<p><img src="14.png" alt=""><br>对应的指令为ADD，结合来看指令大致为ADD Ev，Ib，再根据ModR/M字段值C3得出指令为ADD EBX,12。</p>
<h2 id="指令前缀的使用"><a href="#指令前缀的使用" class="headerlink" title="指令前缀的使用"></a>指令前缀的使用</h2><p>指令前缀主要来辅助说明操作码的，比如前缀66就会规定指令为16位形式。前缀的形式一般都是：前缀：操作码（这里是显示形式，其实在od中编写不用写符号：但是显示会出现符号：）。</p>
<p>接下来来示范解析带有前缀的指令 66：81FE 3412。前缀66的信息查询也是在表</p>
<p>Table A-2 .one –byte Opcode Maps（单字节操作码查询表）中如下图：</p>
<p><img src="15.png" alt=""><br>上图表示操作码的size位16位，接下来继续解析81，如下图：<br><img src="16.png" alt=""><br>说明还要使用ModR/M（FE=1111，1110）的字段Reg（111）表Table A-6 Opcode Extension for one-and Two Opcodes by Group Number来查询Group信息。如下图：</p>
<p>因此指令的形式是CMP Ev,Ib，由于前缀规定使用16位操作数，所以指令解析为：</p>
<p>66：81FE 3412 CMP SI,1234(指令为16位的)。</p>
<h2 id="双字节操作码的解析"><a href="#双字节操作码的解析" class="headerlink" title="双字节操作码的解析"></a>双字节操作码的解析</h2><p>双字节操作码很好分辨，指令的第一个字节为0F，指令映射参考表Table A-3.two-bytes Opcode Maps。接下来我们来解析指令0F85 FA1F0000。先解析0F,查询表Table A-2 .one –byte Opcode Maps可得下图：</p>
<p><img src="17.png" alt=""><br>可知这是一个双字节操作数，其实双操作数的第一个字节都是0F，再来查询85，我们使用表Table A-3.two-bytes Opcode Maps。如下图：</p>
<p><img src="18.png" alt=""><br>由上图可知这是一个条件跳转指令，而且是长跳转，JCC +NE/NZ=JNE指令。Long型表明跳转地址为四个字节。这里还需特别注意的是：机器码0F85 FA1F0000的四个字节是相对地址，要正确解析出指令还需算出实际的跳转地址。公式为：实际地址=当前地址+指令大小+相对地址。我们用OD实际的运算一下：选定当前的地址是010073ee，则解析后的实际跳转地址=010073ee+6（指令大小为五个字节）+00001FFA= 01008EEE,所以完整的指令解析为：</p>
<p>JNZ 01008EEE。如下图：<br><img src="19.png" alt=""></p>
<h2 id="同时含有位移值和立即数的情况"><a href="#同时含有位移值和立即数的情况" class="headerlink" title="同时含有位移值和立即数的情况"></a>同时含有位移值和立即数的情况</h2><p>例如指令：C705 00CF4000 01000100</p>
<p>首先解析C7，如下图：<br><img src="20.png" alt=""><br>这是一个含有group的指令，ModR/M为05（0000，0101），其中Reg值为：000，根据Reg值查询group表，如下图：</p>
<p><img src="21.png" alt=""><br>由此可见指令的形式为MOV  Ev，Iz,Ev表示使用ModR/M规定的寄存器双字或者内存双字。Iz表示立即数双字。下面使用ModR/M来确定具体的寻址方式，查询ModR/M表，如下图：</p>
<p><img src="22.png" alt=""><br>因此第一个操作数使用的32位内存操作数，默认的段寄存器是DS，第二个操作数是立即数。完整解析指令为：Mov DWORD DS:[40CF00],10001.</p>
<h2 id="使用SIB的情况"><a href="#使用SIB的情况" class="headerlink" title="使用SIB的情况"></a>使用SIB的情况</h2><p>SIB也是用来辅助寻址的，主要针对基址寻址和基址加变址寻址。</p>
<p>那如何来判断指令是否使用了SIB呢？</p>
<p>且看指令8B0C01 ,先解析8B，如下图：<br><img src="23.png" alt=""><br>指令形式为MOV Gv,Ev。Gv表示ModR/M规定的双字寄存器数，Ev表示使用ModR/M规定的双子寄存器数或者双字内存数。接下俩解析ModR/M，字段值为0C（00001100），查询ModR/M表可得下图：</p>
<p><img src="24.png" alt=""><br>由上图可得指令的基本结构为MOV ECX,[Reg.A+Reg.B]。对于这种结构的寻址方式就要用到SIB辅助寻址，指令中的SIB=01，拆成三个字段scale=00，Index=000，base=001，查询表table 2-3 32-bit Addressing forms with the SIB Bytes如下图:</p>
<p><img src="25.png" alt=""><br>因此完整的解析指令为：8B0C01 MOV ECX,DWORD PTR DS:[ECX,EAX],使用OD验证一下，如下图：</p>
<p><img src="26.png" alt=""><br>以上就是解析IA-32机器码时会遇到的所有情况，掌握了这些解析机器码不成问题。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/29/从TEB到PEB再到SEH/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/29/从TEB到PEB再到SEH/" itemprop="url">从TEB到PEB再到SEH</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-29T22:35:19+08:00">
                2019-05-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h1 id="TEB"><a href="#TEB" class="headerlink" title="TEB"></a>TEB</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>TEB指线程环境块 该结构体包含进程中运行线程的各种信息 进程中每个线程都对应一个TEB结构体 不同OS中TEB结构体形态略微不同</p>
<!--more-->
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>结构体中有非常多的成员，其中用户模式调试中起着重要作用的成员有两个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+0 NtTib : _NT_TIB</span><br><span class="line">...</span><br><span class="line">+0X30 ProcessEnvironmentBlock : Ptr32_PEB</span><br></pre></td></tr></table></figure></p>
<p>偏移0x30处的ProcessEnvironmentBlock是指向PEB（进程环境块）结构体的指针<br>偏移0处的_NT_TIB结构体内容如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _NT_TIB &#123;</span><br><span class="line">　struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList;</span><br><span class="line">　PVOID StackBase;</span><br><span class="line">　PVOID StackLimit;</span><br><span class="line">　PVOID SubSystemTib;</span><br><span class="line">　union &#123;</span><br><span class="line">　　PVOID FiberData;</span><br><span class="line">　　DWORD Version;</span><br><span class="line">　&#125;;</span><br><span class="line">　PVOID ArbitraryUserPointer;</span><br><span class="line">　struct _NT_TIB *Self;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>ExceptionList成员指向_EXCEPTION_REGISTRATION_RECORD结构体组成的链表，用于Windows OS的SEH（异常处理机制） </p>
<p>Self成员是结构体的自引用指针</p>
<h2 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h2><p>内核模式下可以直接查看内核的内存，但是用户模式下由于没有相关权限，所以只能通过OS提供的API来访问</p>
<h2 id="Ntdll-NtCurrentTeb"><a href="#Ntdll-NtCurrentTeb" class="headerlink" title="Ntdll.NtCurrentTeb()"></a>Ntdll.NtCurrentTeb()</h2><p>Ntdll.NtCurrentTeb()用来返回当前线程的TEB结构体的地址 我们接下来用OD看看函数内部如何实现的 我们打开notepad.exe<br><img src="1.png" alt=""><br>我们跳转到该API代码处<br><img src="2.png" alt=""><br>我们可以看到该API函数代码很简单 只返回FS:[18]的值 FS:[18]的实际地址为003D0018 内存中进入该地址 发现值为003D0000 我们仔细看发现TEB结构体的内存（003D0000）与FS段寄存器所指的段内存的基址是一样的 也就是说 TEB与FS段寄存器有着某种关联</p>
<h2 id="FS段寄存器"><a href="#FS段寄存器" class="headerlink" title="FS段寄存器"></a>FS段寄存器</h2><p>FS段寄存器就是专门用来指示当前线程的TEB结构体的<br>具体方法为<br>FS寄存器指示SDT的索引，其中存放着TEB结构体的地址</p>
<p>SDT位于内核内存区域，地址存放在GDTR（全局描述符表寄存器）中<br>因此GDTR+FS就可以得到TEB结构体的指针了</p>
<p>从而有<br>FS:[0x18] = FS:0<br>（+0x18处就是self指针）<br>FS:[0x30] = &amp;PEB<br>PEB结构体常用于反调试 接下来将讲解<br>FS:[0] = &amp;SEH<br>SEH是windows的结构化异常处理机制 常用于反调试技术</p>
<h1 id="PEB"><a href="#PEB" class="headerlink" title="PEB"></a>PEB</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>PEB（Process Environment Block，进程环境块）存放进程信息，每个进程都有自己的PEB信息。位于用户地址空间。</p>
<p>PEB地址可以通过函数PsGetProcessPeb(EPROCESS)来获得，也可以通过EPROCESS基地址加偏移0x1b0(x86)来获得。</p>
<h3 id="访问方法-1"><a href="#访问方法-1" class="headerlink" title="访问方法"></a>访问方法</h3><p>在前面我们已经知道 TEB.ProcessEnvironmentBlock成员位于距离TEB结构体Offset 30的位置处 我们有以下方法获取地址</p>
<p>#1：直接获取PEB地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV EAX,DWORD PTR FS:[30]  ; FS[30]=address of PEB</span><br></pre></td></tr></table></figure></p>
<p>#2：先获取TEB 再通过TEB.ProcessEnvironmentBlock成员（+30偏移）获取PEB地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV EAX,DWORD PTR FS:[18]  ; FS[18]=address of TEB</span><br><span class="line">MOV EAX,DWORD PTR DS:[EAX+30]  ; DS[EAX+30]=address of PEB</span><br></pre></td></tr></table></figure></p>
<p>接下来用OD打开一个exe文件 在EP代码处输入如图指令<br><img src="3.png" alt=""><br>然后单步执行 EAX寄存器存入FS:[30]的值 即PEB结构体的地址<br><img src="4.png" alt=""><br>我们在数据窗口看看PEB的地址<br><img src="5.png" alt=""></p>
<h3 id="PEB结构体定义"><a href="#PEB结构体定义" class="headerlink" title="PEB结构体定义"></a>PEB结构体定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _UNICODE_STR</span><br><span class="line">&#123;</span><br><span class="line">    USHORT Length;</span><br><span class="line">    USHORT MaximumLength;</span><br><span class="line">    PWSTR pBuffer;</span><br><span class="line">&#125; UNICODE_STR, *PUNICODE_STR;</span><br><span class="line"></span><br><span class="line">typedef struct _LDR_DATA_TABLE_ENTRY</span><br><span class="line">&#123;</span><br><span class="line">    //LIST_ENTRY InLoadOrderLinks; </span><br><span class="line">    LIST_ENTRY InMemoryOrderModuleList;</span><br><span class="line">    LIST_ENTRY InInitializationOrderModuleList;</span><br><span class="line">    PVOID DllBase;</span><br><span class="line">    PVOID EntryPoint;</span><br><span class="line">    ULONG SizeOfImage;</span><br><span class="line">    UNICODE_STR FullDllName;</span><br><span class="line">    UNICODE_STR BaseDllName;</span><br><span class="line">    ULONG Flags;</span><br><span class="line">    SHORT LoadCount;</span><br><span class="line">    SHORT TlsIndex;</span><br><span class="line">    LIST_ENTRY HashTableEntry;</span><br><span class="line">    ULONG TimeDateStamp;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br><span class="line"></span><br><span class="line">typedef struct _PEB_LDR_DATA //, 7 elements, 0x28 bytes</span><br><span class="line">&#123;</span><br><span class="line">    DWORD dwLength;</span><br><span class="line">    DWORD dwInitialized;</span><br><span class="line">    LPVOID lpSsHandle;</span><br><span class="line">    LIST_ENTRY InLoadOrderModuleList;</span><br><span class="line">    LIST_ENTRY InMemoryOrderModuleList;</span><br><span class="line">    LIST_ENTRY InInitializationOrderModuleList;</span><br><span class="line">    LPVOID lpEntryInProgress;</span><br><span class="line">&#125; PEB_LDR_DATA, *PPEB_LDR_DATA;</span><br><span class="line"></span><br><span class="line">typedef struct _PEB_FREE_BLOCK // 2 elements, 0x8 bytes</span><br><span class="line">&#123;</span><br><span class="line">    struct _PEB_FREE_BLOCK * pNext;</span><br><span class="line">    DWORD dwSize;</span><br><span class="line">&#125; PEB_FREE_BLOCK, *PPEB_FREE_BLOCK;</span><br><span class="line"></span><br><span class="line">typedef struct __PEB // 65 elements, 0x210 bytes</span><br><span class="line">&#123;</span><br><span class="line">    BYTE bInheritedAddressSpace;</span><br><span class="line">    BYTE bReadImageFileExecOptions;</span><br><span class="line">    BYTE bBeingDebugged;</span><br><span class="line">    BYTE bSpareBool;</span><br><span class="line">    LPVOID lpMutant;</span><br><span class="line">    LPVOID lpImageBaseAddress;</span><br><span class="line">    PPEB_LDR_DATA pLdr;</span><br><span class="line">    LPVOID lpProcessParameters;</span><br><span class="line">    LPVOID lpSubSystemData;</span><br><span class="line">    LPVOID lpProcessHeap;</span><br><span class="line">    PRTL_CRITICAL_SECTION pFastPebLock;</span><br><span class="line">    LPVOID lpFastPebLockRoutine;</span><br><span class="line">    LPVOID lpFastPebUnlockRoutine;</span><br><span class="line">    DWORD dwEnvironmentUpdateCount;</span><br><span class="line">    LPVOID lpKernelCallbackTable;</span><br><span class="line">    DWORD dwSystemReserved;</span><br><span class="line">    DWORD dwAtlThunkSListPtr32;</span><br><span class="line">    PPEB_FREE_BLOCK pFreeList;</span><br><span class="line">    DWORD dwTlsExpansionCounter;</span><br><span class="line">    LPVOID lpTlsBitmap;</span><br><span class="line">    DWORD dwTlsBitmapBits[2];</span><br><span class="line">    LPVOID lpReadOnlySharedMemoryBase;</span><br><span class="line">    LPVOID lpReadOnlySharedMemoryHeap;</span><br><span class="line">    LPVOID lpReadOnlyStaticServerData;</span><br><span class="line">    LPVOID lpAnsiCodePageData;</span><br><span class="line">    LPVOID lpOemCodePageData;</span><br><span class="line">    LPVOID lpUnicodeCaseTableData;</span><br><span class="line">    DWORD dwNumberOfProcessors;</span><br><span class="line">    DWORD dwNtGlobalFlag;</span><br><span class="line">    LARGE_INTEGER liCriticalSectionTimeout;</span><br><span class="line">    DWORD dwHeapSegmentReserve;</span><br><span class="line">    DWORD dwHeapSegmentCommit;</span><br><span class="line">    DWORD dwHeapDeCommitTotalFreeThreshold;</span><br><span class="line">    DWORD dwHeapDeCommitFreeBlockThreshold;</span><br><span class="line">    DWORD dwNumberOfHeaps;</span><br><span class="line">    DWORD dwMaximumNumberOfHeaps;</span><br><span class="line">    LPVOID lpProcessHeaps;</span><br><span class="line">    LPVOID lpGdiSharedHandleTable;</span><br><span class="line">    LPVOID lpProcessStarterHelper;</span><br><span class="line">    DWORD dwGdiDCAttributeList;</span><br><span class="line">    LPVOID lpLoaderLock;</span><br><span class="line">    DWORD dwOSMajorVersion;</span><br><span class="line">    DWORD dwOSMinorVersion;</span><br><span class="line">    WORD wOSBuildNumber;</span><br><span class="line">    WORD wOSCSDVersion;</span><br><span class="line">    DWORD dwOSPlatformId;</span><br><span class="line">    DWORD dwImageSubsystem;</span><br><span class="line">    DWORD dwImageSubsystemMajorVersion;</span><br><span class="line">    DWORD dwImageSubsystemMinorVersion;</span><br><span class="line">    DWORD dwImageProcessAffinityMask;</span><br><span class="line">    DWORD dwGdiHandleBuffer[34];</span><br><span class="line">    LPVOID lpPostProcessInitRoutine;</span><br><span class="line">    LPVOID lpTlsExpansionBitmap;</span><br><span class="line">    DWORD dwTlsExpansionBitmapBits[32];</span><br><span class="line">    DWORD dwSessionId;</span><br><span class="line">    ULARGE_INTEGER liAppCompatFlags;</span><br><span class="line">    ULARGE_INTEGER liAppCompatFlagsUser;</span><br><span class="line">    LPVOID lppShimData;</span><br><span class="line">    LPVOID lpAppCompatInfo;</span><br><span class="line">    UNICODE_STR usCSDVersion;</span><br><span class="line">    LPVOID lpActivationContextData;</span><br><span class="line">    LPVOID lpProcessAssemblyStorageMap;</span><br><span class="line">    LPVOID lpSystemDefaultActivationContextData;</span><br><span class="line">    LPVOID lpSystemAssemblyStorageMap;</span><br><span class="line">    DWORD dwMinimumStackCommit;</span><br><span class="line">&#125; _PEB, *_PPEB;</span><br></pre></td></tr></table></figure>
<h2 id="PEB的重要成员"><a href="#PEB的重要成员" class="headerlink" title="PEB的重要成员"></a>PEB的重要成员</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+002 BeingDebugged</span><br><span class="line">+008 ImageBaseAddress</span><br><span class="line">+00c Ldr</span><br><span class="line">+018 ProcessHeap</span><br><span class="line">+068 NtGlobaFlag</span><br></pre></td></tr></table></figure>
<h3 id="PEB-BeingDebugged"><a href="#PEB-BeingDebugged" class="headerlink" title="PEB.BeingDebugged"></a>PEB.BeingDebugged</h3><p>Kernel32.dll中有个名为Kernel32！IsDebuggerPresent（）的API 但普通的应用程序开发在并不常用</p>
<p>该API函数用来判断当前进程是否处于调试状态 并判断结果 该API通过检测PEB.BeingDebugged成员来确定是否处于调试状态（是为1 否为0）该API代码：</p>
<p><img src="6.png" alt=""><br>该值通常用于反调试技术 检测该值 若进程处于调试中 就终止调试</p>
<h3 id="PEB-ImageBaseAddress"><a href="#PEB-ImageBaseAddress" class="headerlink" title="PEB.ImageBaseAddress"></a>PEB.ImageBaseAddress</h3><p>PEB.ImageBaseAddress成员用来表示进程的ImageBase<br>GetModuleHandle（）API用来获取ImageBase<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HMODULE WINAPI GetModuleHandle(</span><br><span class="line">_In_opt_LPCTSTR lpModuleName</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>向lpModuleName参数赋值为NULL 调用GetModuleHandle()函数将返回进程被加载的ImageBase GetModuleHandle()的部分API代码：</p>
<p><img src="7.png" alt=""><br>向lpModuleName参数赋值为NULL值后 调用GetModuleHandle（）函数时执行如图代码 我们可以看到 PEB.ImageBaseAddress成员的值被设置到EAX寄存器</p>
<h3 id="PEB-Ldr"><a href="#PEB-Ldr" class="headerlink" title="PEB.Ldr"></a>PEB.Ldr</h3><p>PEB.Ldr成员是指向_PEB_LDR_DATA结构体的指针 代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _PEB_LDR_DATA //, 7 elements, 0x28 bytes</span><br><span class="line">&#123;</span><br><span class="line">    DWORD dwLength;</span><br><span class="line">    DWORD dwInitialized;</span><br><span class="line">    LPVOID lpSsHandle;</span><br><span class="line">    LIST_ENTRY InLoadOrderModuleList;</span><br><span class="line">    LIST_ENTRY InMemoryOrderModuleList;</span><br><span class="line">    LIST_ENTRY InInitializationOrderModuleList;</span><br><span class="line">    LPVOID lpEntryInProgress;</span><br><span class="line">&#125; PEB_LDR_DATA, *PPEB_LDR_DATA;</span><br></pre></td></tr></table></figure></p>
<p>当模块（DLL）加载到进程后 通过PEB.Ldr成员可以直接获取该模块的加载基地址 所以PEB.Ldr是非常重要的成员 _PEB_LDR_DATA 结构体成员有3个_LIST_ENTRY类型的成员（LIST_ENTRY InLoadOrderModuleList;LIST_ENTRY InMemoryOrderModuleList;LIST_ENTRY InInitializationOrderModuleList;）_LIST_ENTRY结构体的定义如代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedefstruct _LIST_ENTRY&#123;</span><br><span class="line">	struct _LIST_ENTRY*Flink</span><br><span class="line">	struct _LIST_ENTRY*Blink</span><br><span class="line">&#125; LIST_ENTRY,*PLIST_ENTRY</span><br></pre></td></tr></table></figure>
<p>我们可以看到_LIST_ENTRY结构体提供了双向链表机制 链表中保存的是_LDR_DATA_TABLE_ENTRY结构体的信息 代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _LDR_DATA_TABLE_ENTRY</span><br><span class="line">&#123;</span><br><span class="line">    //LIST_ENTRY InLoadOrderLinks; </span><br><span class="line">    LIST_ENTRY InMemoryOrderModuleList;</span><br><span class="line">    LIST_ENTRY InInitializationOrderModuleList;</span><br><span class="line">    PVOID DllBase;</span><br><span class="line">    PVOID EntryPoint;</span><br><span class="line">    ULONG SizeOfImage;</span><br><span class="line">    UNICODE_STR FullDllName;</span><br><span class="line">    UNICODE_STR BaseDllName;</span><br><span class="line">    ULONG Flags;</span><br><span class="line">    SHORT LoadCount;</span><br><span class="line">    SHORT TlsIndex;</span><br><span class="line">    LIST_ENTRY HashTableEntry;</span><br><span class="line">    ULONG TimeDateStamp;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br></pre></td></tr></table></figure></p>
<p>每个加载到进程中的DLL模块都有与之对应的_LDR_DATA_TABLE_ENTRY结构体 这些结构体互相链接 最终形成_LIST_ENTRY双向链表 需要注意的是：_PEB_LDR_DATA结构体中存在的3种链表 也就是说 存在多个_LDR_DATA_TABLE_ENTRY结构体 并且有三种链接方法可以将它们链接起来</p>
<h3 id="PEB-ProcessHeap-amp-PEB-NtGlobaFlag"><a href="#PEB-ProcessHeap-amp-PEB-NtGlobaFlag" class="headerlink" title="PEB.ProcessHeap&amp;PEB.NtGlobaFlag"></a>PEB.ProcessHeap&amp;PEB.NtGlobaFlag</h3><p>PEB.ProcessHeap&amp;PEB.NtGlobaFla常用于反调试技术 若处于调试状态 成员就持有特定值</p>
<h1 id="SEH"><a href="#SEH" class="headerlink" title="SEH"></a>SEH</h1><p>windows 提供的异常处理机制实际上只是一个简单的框架。我们通常所用的异常处理（比如 C++ 的 throw、try、catch）都是编译器在系统提供的异常处理机制上进行加工了的增强版本。这里先抛开增强版的不提，先说原始版本。</p>
<p>原始版本的机制很简单：谁都可以触发异常，谁都可以处理异常（只要它能看得见）。但是不管是触发还是处理都得先注册。系统把这些注册信息保存在一个链表里，并且这个链表保存在线程的数据结构里。也就是说，异常所涉及的一些行为都是线程相关的。比如，线程 T1 触发的异常就只能由线程 T1 来处理，其他线程根本就不知道 T1 发生了什么事，更不会处理。等注册完毕后，线程就可以抛出或处理异常了，系统也可以做相应的管理工作了。</p>
<p>系统提供的管理工作简单来说包括（但不限于）：找到触发异常的线程的异常处理链表（前面注册的那个），然后按照规则对该异常进行分发，根据分发后的处理结果再进行下一步的分发或者结束处理。</p>
<h2 id="SEH练习-1"><a href="#SEH练习-1" class="headerlink" title="SEH练习#1"></a>SEH练习#1</h2><p>先简单介绍练习示例seh.exe 该程序故意触发了内存非法访问异常 然后通过SEH机制来处理 并且使用PEB信息向程序添加简单的反调试代码  使程序在正常运行与调试运行时表现出不同的行为动作</p>
<h3 id="正常运行"><a href="#正常运行" class="headerlink" title="正常运行"></a>正常运行</h3><p>该程序非常简单 运行后弹出“Hello:)”字符串<br><img src="8.png" alt=""></p>
<h3 id="调试运行"><a href="#调试运行" class="headerlink" title="调试运行"></a>调试运行</h3><p>用OD打开<br><img src="9.png" alt=""><br>按下F9运行 发生非法访问异常后暂停调试<br><img src="10.png" alt=""><br>401019地址处的MOV指令用来触发异常 当前EAX寄存器的值为0 所以该指令的实际含义是向地址为0处写入1 但试图向未分配的内存地址0处写入某个值时 就会触发内存非法访问异常</p>
<p>在OD中查看状态窗口 如下<br><img src="11.png" alt=""><br><strong>在内存0处发生写入异常 若想将异常抛给程序 请使用Shift+Run/Step</strong></p>
<p>我们根据调试器的提示使用Shift+F9继续运行程序 调试开始运行弹出对话框：</p>
<p><img src="12.png" alt=""><br>可以看到它与正常运行时弹出的对话框是不一样的 以上就是“利用SEH机制的反调试技术”</p>
<h2 id="OS的异常处理方法"><a href="#OS的异常处理方法" class="headerlink" title="OS的异常处理方法"></a>OS的异常处理方法</h2><p>同一程序在正常运行和调试运行时的表现行为是不同的 这是由Winsows OS异常处理方法不同引起的</p>
<h3 id="正常运行时的异常处理方法"><a href="#正常运行时的异常处理方法" class="headerlink" title="正常运行时的异常处理方法"></a>正常运行时的异常处理方法</h3><p>进程运行时发生异常 OS会委托进程处理 若进程代码中存在具体的异常处理（SEH异常处理器）代码 则能顺利处理相关异常 程序继续运行 但如果进程内部没有具体实现SEH 那么相关异常就无法处理 OS就会启动默认的异常处理机制 终止进程运行</p>
<p><img src="13.png" alt=""></p>
<h3 id="调试运行时的异常处理方法"><a href="#调试运行时的异常处理方法" class="headerlink" title="调试运行时的异常处理方法"></a>调试运行时的异常处理方法</h3><p>调试运行中发生异常时，处理方法与上面有些不同。若被调试进程内部发生异常，OS会首先把异常抛给调试进程处理。调试器几乎拥有被调试者的所有权限，它不仅可以运行、终止被调试者，还拥有被调试进程的虚拟内存、寄存器的读写权限。需要特别指出的是，被调试者内部发生的所有异常(错误)都由调试器处理。所以调试过程中发生的所有异常(错误)都要先交由调试器管理(被调试者的SEH依据优先顺序推给调试器)。像这样，被调试者发生异常时，调试器就会暂停运行，必须采取某种措施来处理异常，完成后继续调试。遇到异常时经常采用的几种处理方法如下所示。</p>
<p>(1)直接修改异常:代码、寄存器、内存<br>被调试者发生异常时,调试器会在发生异常的代码处暂停,此时可以通过调试器直接修改有问题的代码 内存 寄存器等 排除异常后 调试器继续运行程序</p>
<p><strong>遇到图10中的异常时，采用直接修改异常的方法进行如下处理.</strong></p>
<p><strong>●由于EAX寄存器所指的地址值错误，所以只要把EAX寄存器的值修改为有效的内存地址即可。</strong></p>
<p><strong>●由于401019地址处的代码触发了异常，使用OllyDbg的汇编( Space)或编辑( Ctrl+E) 功能将相关代码修改为NOP指令，运行后也可排除异常。</strong></p>
<p><strong>●也可以使用OllyDbg的New Origin here(Ctrl+Gray *)功能改变程序的运行路径(因为无法直接修改EIP寄存器，所以需要借助该功能修改)。</strong></p>
<p><strong>请不要随意使用这些修改方法，必须在明确知道程序错误的情形下才能使用。</strong></p>
<p>(2)将异常抛给被调试者处理</p>
<p>如果被调试者内部存在SEH(异常处理函数)能够处理异常，那么异常通知会发送给被调试者，由被调试者自行处理。这与程序正常运行时的异常处理方式是一样的。 前面的seh.exe练习示例中，使用OllyDbg中的Shift+F7/F8/F9命令( StepInto/StepOver/Run )可以直接将当前异常抛还给被调试者。</p>
<p>(3) OS默认的异常处理机制</p>
<p>若调试器与被调试者都无法处理(或故意不处理)当前发生的异常，则OS的默认异常处理机制会处理它，终止被调试进程，同时结束调试。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>学习异常处理前 先了解操作系统中定义的异常<br><img src="14.png" alt=""><br>以上的调试列表 我们调试时会经常遇到5种具有代表性的异常</p>
<h3 id="EXCEPTION-ACCESS-VIOLATION-0xC0000005"><a href="#EXCEPTION-ACCESS-VIOLATION-0xC0000005" class="headerlink" title="EXCEPTION_ ACCESS VIOLATION(0xC0000005)"></a>EXCEPTION_ ACCESS VIOLATION(0xC0000005)</h3><p>试图访问不存在或者不具体访问权限的内存区域时 就会发生EXCEPTION_ ACCESS VIOLATION（非法访问异常 该异常最常见）</p>
<p><strong>MOV DWORD PTR DS:[0], 1<br>-&gt;内存地址0处是尚未分配的区域。<br>ADD DWoRD PTR DS: [401000]，1<br>-&gt;. text 节区的起始地址401000仅具有 “读”权限(无“写” 权限)。<br>XOR DWORD PTR DS: [80000000]，1234<br>-&gt;内存地址80000000属于内核区域，用户模式下无法访问。</strong></p>
<h3 id="EXCEPTION-BREAKPOINT-0x80000003"><a href="#EXCEPTION-BREAKPOINT-0x80000003" class="headerlink" title="EXCEPTION BREAKPOINT(0x80000003)"></a>EXCEPTION BREAKPOINT(0x80000003)</h3><p>在运行代码中设置断点后 CPU尝试执行该地址处的指令时 将发生EXCEPTION BREAKPOINT异常  调试器利用该异常实现断点功能</p>
<p><strong>INT3</strong><br>设置断点对应的汇编指令时INT3 对应的及其指令（IA-32）为0xcc CPU运行代码过程中若遇到汇编指令INT3 则会触发EXCEPTION BREAKPOINT异常 在OD中设置好断点后 确认该地址处是否真的会变成INT3 在OD中打开seh.exe文件 跳转到0040100处 设置好断点：</p>
<p><img src="14.png" alt=""><br>从图中可以看到，虽然401000地址处设置了断点，但是该地址处的指令并未变为INT3(汇编指令),也未由“68”变为“CC”(机器指令)。为什么跟前面讲的不一样呢?其实，这是OllyDbg耍的一个小花招。由于在O1lyDbg中按F2键设置的断点是用户用来调试的临时断点( UserTemporary Break Point ),所以不需要在调试画面中显示。在代码与内存中将用户设置的临时断点全部显示出来，反而会大大降低代码的可读性，给代码调试带来不便。换言之，实际进程内存中401000地址处的指令“68” 已经被更改为“CC”，但是为了调试方便，OllyDbg并 未将其显示出来。将进程内存转储之后可以看到更改后的CC指令,先使用PE Tools工具转储进程内存,如图下图</p>
<p>以seh_dump.exe文件名保存转储文件</p>
<p><img src="15.png" alt=""><br>使用PEView查看00401000地址处的指令<br><img src="16.png" alt=""><br>查看00401000地址处处可以看到cc指令 也就是说进程内存中的实际值为0xcc 但是OD调试器在显示时先将其更改为原来的操作码“68” 然后显示出来</p>
<p>以上就是断点内部工作原理，灵活运用这一原理能为程序调试带来很大便利。比如，使用Hex Editor工具打开PE文件，修改EP地址对应的文件偏移处的第一个字节为CC,然后运行该PE文件就会发生EXCEPTION BREAKPOINT异常，经过OS的默认异常处理后终止运行。若在系统注册表中将默认调试器设置为OllyDbg,那么发生以上异常时OS会自动运行01lyDbg调试器,附加发生异常的进程(第八部分中将详细讲解利用这一原理调试的方法)</p>
<h3 id="EXCEPTION-ILL-EGAL-INSTRUCTION-0xC000001D"><a href="#EXCEPTION-ILL-EGAL-INSTRUCTION-0xC000001D" class="headerlink" title="EXCEPTION ILL EGAL INSTRUCTION(0xC000001D)"></a>EXCEPTION ILL EGAL INSTRUCTION(0xC000001D)</h3><p>CPU在遇到无法解析的指令时引发该异常 比如“0FFF”指令在X86CPU中未定义 CPU遇到该指令将引发EXCEPTION ILL EGAL INSTRUCTION异常</p>
<p>下面用OD打开seh.exe 在EP代码处直接修改指令为0FFF 然后程序引发EXCEPTION ILL EGAL INSTRUCTION异常 暂停调试</p>
<p><img src="17.png" alt=""></p>
<h3 id="EXCEPTION-INT-DIVIDE-BY-ZERO-0xC0000094"><a href="#EXCEPTION-INT-DIVIDE-BY-ZERO-0xC0000094" class="headerlink" title="EXCEPTION INT DIVIDE BY ZERO(0xC0000094 )"></a>EXCEPTION INT DIVIDE BY ZERO(0xC0000094 )</h3><p>INTEGER（整数）除法运算中 若分母为0 则引发EXCEPTION INT DIVIDE BY ZERO异常 编写应用程序时偶尔会引发该异常 分母为变量时 该变量在某个瞬间变为0 执行除法运算就会引发EXCEPTION INT DIVIDE BY ZERO异常 打开seh.exe 使用汇编指令在EP代码处修改代码 如图：</p>
<p><img src="18.png" alt=""><br>401220地址处的DIV ECX指令执行除法运算 然后将结果保存到EAX寄存器 但此时ECX寄存器的值为0 所以引发EXCEPTION INT DIVIDE BY ZERO异常 暂停运行</p>
<h3 id="EXC-EPTION-SINGLE-STEP-0x80000004"><a href="#EXC-EPTION-SINGLE-STEP-0x80000004" class="headerlink" title="EXC EPTION SINGLE STEP(0x80000004 )"></a>EXC EPTION SINGLE STEP(0x80000004 )</h3><p>Single Step(单步)的含义是执行1条指令，然后暂停。CPU进入单步模式后，每执行一条指令就会引发EXCEPTION_ SINGLE STEP异常，暂停运行。将EFLAGS寄存器的TF ( Trap Flag,陷阱标志)位设置为1后，CPU就会进入单步工作模式。</p>
<h2 id="SEH详细说明"><a href="#SEH详细说明" class="headerlink" title="SEH详细说明"></a>SEH详细说明</h2><h3 id="SEH链"><a href="#SEH链" class="headerlink" title="SEH链"></a>SEH链</h3><p>SEH是以链的形式存在 第一个异常处理器若未处理相关异常 它就会被传递到下一个异常处理器 直到被处理 从技术层面来看 SEH是由_EXCEPTION_REGISTRATION_RECORD结构体组成的链表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _EXCEPTION_REGISTRATION_RECORD &#123;</span><br><span class="line">        //指向下一个 EXCEPTION_REGISTRATION_RECORD，由此构成一个异常注册信息链表。</span><br><span class="line">        //链表中的最后一个结点会将 Next 置为 EXCEPTION_CHAIN_END，表示链表到此结束。</span><br><span class="line">        struct _EXCEPTION_REGISTRATION_RECORD *Next;</span><br><span class="line">        PEXCEPTION_ROUTINE Handler;  //指向异常处理函数</span><br><span class="line">&#125; EXCEPTION_REGISTRATION_RECORD;</span><br></pre></td></tr></table></figure>
<h3 id="异常处理函数的定义"><a href="#异常处理函数的定义" class="headerlink" title="异常处理函数的定义"></a>异常处理函数的定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXCEPTION_DISPOSIYION_except_handler (</span><br><span class="line">       EXCEPTION_RECORD	*pRecord,</span><br><span class="line">       EXCEPYION_REGISTRATION_RECORD  *pFrame,</span><br><span class="line">       CONREXT				*pContext,</span><br><span class="line">       PVOID 				pValue,</span><br><span class="line">       );</span><br></pre></td></tr></table></figure>
<p>当接收到异常后，系统找到当前线程的异常链表，从链表中的第一个结点开始遍历，找到一个 EXCEPTION_REGISTRATION_RECORD 就调用它的 Handler，并把该异常(类型为 EXCEPTION_RECORD 的参数)表示传递给该 Handler，Handler 处理并返回一个类型为 EXCEPTION_DISPOSITION 的枚举值。该返回值指示系统下一步该做什么</p>
<p>_EXCEPTION_RECORD结构体的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _EXCEPTION_RECORD &#123;</span><br><span class="line">  DWORD                    ExceptionCode;	//异常代码</span><br><span class="line">  DWORD                    ExceptionFlags;</span><br><span class="line">  struct _EXCEPTION_RECORD *ExceptionRecord;</span><br><span class="line">  PVOID                    ExceptionAddress;	//异常发生地址</span><br><span class="line">  DWORD                    NumberParameters;</span><br><span class="line">  ULONG_PTR                ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];</span><br><span class="line">												//15</span><br><span class="line">  &#125; EXCEPTION_RECORD;</span><br></pre></td></tr></table></figure></p>
<p>异常处理的第三个指针指向CONTEXT结构体的指针 定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _CONTEXT</span><br><span class="line">&#123;</span><br><span class="line">    DWORD           ContextFlags    // -|               +00h</span><br><span class="line">    DWORD           Dr0             //  |               +04h</span><br><span class="line">    DWORD           Dr1             //  |               +08h</span><br><span class="line">    DWORD           Dr2             //  &gt;调试寄存器     +0Ch</span><br><span class="line">    DWORD           Dr3             //  |               +10h</span><br><span class="line">    DWORD           Dr6             //  |               +14h</span><br><span class="line">    DWORD           Dr7             // -|               +18h</span><br><span class="line"></span><br><span class="line">    FLOATING_SAVE_AREA FloatSave;   //浮点寄存器区      +1Ch~~~88h</span><br><span class="line"></span><br><span class="line">    DWORD           SegGs           //-|                +8Ch</span><br><span class="line">    DWORD           SegFs           // |\段寄存器       +90h</span><br><span class="line">    DWORD           SegEs           // |/               +94h</span><br><span class="line">    DWORD           SegDs           //-|                +98h</span><br><span class="line"></span><br><span class="line">    DWORD           Edi             //________          +9Ch</span><br><span class="line">    DWORD           Esi             // |  通用          +A0h</span><br><span class="line">    DWORD           Ebx             // |   寄           +A4h</span><br><span class="line">    DWORD           Edx             // |   存           +A8h</span><br><span class="line">    DWORD           Ecx             // |   器           +ACh</span><br><span class="line">    DWORD           Eax             //_|___组_          +B0h</span><br><span class="line"></span><br><span class="line">    DWORD           Ebp             //++++++            +B4h</span><br><span class="line">    DWORD           Eip             // |控制            +B8h</span><br><span class="line">    DWORD           SegCs           // |寄存            +BCh</span><br><span class="line">    DWORD           EFlag           // |器组            +C0h</span><br><span class="line">    DWORD           Esp             // |                +C4h</span><br><span class="line">    DWORD           SegSs           //++++++            +C8h</span><br><span class="line"></span><br><span class="line">    BYTE    ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];</span><br><span class="line">&#125; CONTEXT;</span><br><span class="line">    typedef     CONTEXT     *PCONTEXT;</span><br><span class="line">    #define     MAXIMUM_SUPPORTED_EXTENSION     512</span><br></pre></td></tr></table></figure></p>
<p> CONTEXT结构体用来备份CPU寄存器的值，因为多线程环境下需要这样做。每个线程内部都拥有1个CONTEXT结构体。CPU暂时离开当前线程去运行其他线程时，CPU寄存器的值就会保存到当前线程的CONTEXT结构体; CPU再次运行该线程时，会使用保存在CONTEXT结构体的值来覆盖CPU寄存器的值，然后从之前暂停的代码处继续执行。通过这种方式，OS可以在多线程环境下安全运行各线程</p>
<p> 异常发生时，执行异常代码的线程就会中断运行，转而运行SEH(异常处理器/异常处理函数),此时OS会把线程的CONTEXT结构体的指针传递给异常处理函数(异常处理器)的相应参数。CONTEXT的结构体成员中有1个Eip成员(偏移量:B8)。在异常处理函数中将参数传递过来的CONTEXT.Eip设置为其他地址，然后返回异常处理函数。这样，之前暂停的线程会执行新设置的EIP地址处的代码( 反调试中经常采用这一技术，练习示例seh.exe中也采用了该技术，后面会详细分析)。在代码异常处理函数代码中 可以看到异常处理函数的返回值为EXCEPTION DISPOSITION枚举类型，下面了解一下该类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> typedef enum _EXCEPTION_DISPOSITION</span><br><span class="line">&#123;</span><br><span class="line">　　ExceptionContinueExecution = 0</span><br><span class="line">   ExceptionContinueSearch = 1</span><br><span class="line">   ExceptionNestedException = 2</span><br><span class="line">   ExceptionCollidedUnwind = 3</span><br><span class="line">&#125;EXCEPTION_DISPOSITION</span><br></pre></td></tr></table></figure>
<p>异常处理后会返回ExceptionContinueExecution（0）从发生异常的代码处继续运行 若当前异常处理器无法处理 则返回ExceptionContinueSearch（1） 将异常传递给下一个异常处理器</p>
<h3 id="TEB-NtTib-ExceptionList"><a href="#TEB-NtTib-ExceptionList" class="headerlink" title="TEB.NtTib.ExceptionList"></a>TEB.NtTib.ExceptionList</h3><p>通过TEB结构体成员很容易的访问进程SEH链<br>TEB.NtTib.ExceptionList成员是PEB结构体的第一个成员 FS段寄存器指向段内存的起始地址 TEB结构体即位于此 我们可以通过以下公式获取</p>
<p>TEB.NtTib.ExceptionList=FS:[0]</p>
<h3 id="SEH安装方法"><a href="#SEH安装方法" class="headerlink" title="SEH安装方法"></a>SEH安装方法</h3><p>在c语言中用<strong>try、</strong>finally和__except等术语可以容易的添加SEH 在汇编中也是一样的简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PUSH @MyHandler				;异常处理器</span><br><span class="line">PUSH DWORD PTR FS:[0]		;Head of SEH Linked List</span><br><span class="line">MOV DWORD PTR FS:[0],ESP	;添加链表</span><br></pre></td></tr></table></figure></p>
<p>看代码就容易理解了。“在程序代码中安装SEH”就是指，将自身的异常处理器添加到已有的SEH链。从技术层面讲，就是将自身的EXCEPTION REGISTRATION RECORD结构体链接到EXCEPTION_ REGISTRATION_ RECORD结构体链表。前面出现的seh.exe程序就是采用上述汇编代码添加的SEH，下面再次调试seh.exe程序以进一步了解添加SEH的方法及其工作原理。</p>
<h2 id="SEH练习-2（seh-exe）"><a href="#SEH练习-2（seh-exe）" class="headerlink" title="SEH练习#2（seh.exe）"></a>SEH练习#2（seh.exe）</h2><p>打开OD使代码运行到00401000处（main函数）<br><img src="20.png" alt=""><br>位于401000 401005 40100c处的三条指令与“SEH安装”的代码是相同的 新添加的异常处理器就是位于40105a处的异常处理函数</p>
<h3 id="查看SEH链"><a href="#查看SEH链" class="headerlink" title="查看SEH链"></a>查看SEH链</h3><p>继续运行代码到401005处 查看FS:[0]的值 其值就是SEH链的起始地址<br><img src="21.png" alt=""><br>从代码信息窗口中可以看到，FS:[0]=[7FFDE000]=12FF78,其中12FF78就是SEH链的起始地址(即EXCEPTION REGISTRATION RECORD结构体链表的起始地址)。在上图的栈窗口中查看地址12FF78,可以发现第一个EXCEPTION REGISTRATION RECORD结构体( Next=12FFC4,Handler-402730 )。异常处理器地址402730存在于seh.exe进程的代码节区(该异常处理器是VC++生成PE文件时默认添加到其启动函数的,请各位自行查看位于402730地址处的异常处理器代码)。然后转到12FFC4地址处，查看链表中的第二个EXCEPTION _REGISTRATION RECORD结构体</p>
<p><img src="22.png" alt=""><br>从图中可以看到，第二个结构体的Next成员值为FFFFFFF,所以第二个EXCEPTION_REGISTRATION RECORD结构体也是SEH链表的最后- - 个结构体。异常处理器地址为7717D74D,它位于ntdll.dll模块的代码区域,是OS的默认异常处理器(创建进程时, OS会自动产生默认的SEH )。</p>
<h3 id="添加SEH"><a href="#添加SEH" class="headerlink" title="添加SEH"></a>添加SEH</h3><p>运行401005处的指令 查看栈窗口<br><img src="23.png" alt=""><br>栈中新创建了EXCEPTION_REGISTRATION RECORD结构体 继续运行40100c处的代码 查看栈窗口</p>
<p><img src="24.png" alt=""><br>栈窗口出现了新生成的SEH的注释 新的异常处理器就是这样添加SEH链</p>
<p>OD中有查看SEH链的功能（Alt+s）<br><img src="25.png" alt=""></p>
<h3 id="发生异常"><a href="#发生异常" class="headerlink" title="发生异常"></a>发生异常</h3><p>如果执行401019地址处的MOV DWORD PTR DS:[EAX],1指令,就会引发EXCEPTION_ ACCESS_ VIOLATION异常(该异常已做说明，此处不再赘述)。此时程序处在调试之中，根据异常处理的顺序，OS会把控制权交给调试器(异常处理器( 40105A)未运行)。在40105A地址处设置断点，然后按Shift+F9组合键，再将异常派送给被调试进程( seh.exe),调试器暂停在设置的断点处( 40105A )。</p>
<p>如图所示，被调试者会调用注册在自身SEH链中的异常处理器来处理异常。设置好断点后，接下来即可调试异常处理器<br><img src="26.png" alt=""></p>
<h3 id="查看异常处理器参数"><a href="#查看异常处理器参数" class="headerlink" title="查看异常处理器参数"></a>查看异常处理器参数</h3><p>调用SEH时 栈中的参数如图<br><img src="27.png" alt=""><br>第一个参数（ESP+4）指向EXCEPTION_RECORD结构体的指针pRecord（12fac0） 数据窗口查看：</p>
<p><img src="28.png" alt=""><br>参考图中以及EXCEPTION_RECORD结构体的定义可知 ExceptionCode（pRecord+0）为C0000005 发生异常的代码地址为401019</p>
<p>第二个参数（ESP+8）是指向EXCEPTION_REGISTRATION RECORD结构体的指针（pFrame） 其值为0012ff3c 是SEH链的起始地址</p>
<p>第三个参数（ESP+c）是指向CONTEXT结构体的指针pContext（0012fadc）查看指针pContext所指的地址空间 如图 COntext是一个非常大的结构体（大部分为NULL）其中特别需要注意的是Eip成员它位于结构体偏移B8的位置 存储着发生异常的代码地址</p>
<p><img src="29.png" alt=""><br>最后一个参数（pValue）（ESP+10）供系统使用 可以忽略</p>
<h3 id="调试异常处理器"><a href="#调试异常处理器" class="headerlink" title="调试异常处理器"></a>调试异常处理器</h3><p>40105a地址处的异常处理器中存在着调试器的检测代码 虽然简单 但非常有代表性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV ESI,DWORD PTR SS:[ESP+0C]	;ESI=pContext</span><br></pre></td></tr></table></figure></p>
<p>[ESP+c]是异常处理器的第三个参数pContext的值 以上命令用来将pContext地址（12fadc）传送入ESI寄存器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV EAX,DWORD PTR FS:[30]</span><br></pre></td></tr></table></figure></p>
<p>上述指令用来将FS：[30]的值传送给EAX FS:[30]就是PEB结构体的起始地址<br><img src="30.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CMP BYTE PTR DS:[EAX+2],1</span><br><span class="line">``` </span><br><span class="line">上述指令用来读取[EAX+2]zi&apos;jie&apos;zhi地址中的1个字节值 然后和1比较 由于EAX当前保存着PEB的起始地址 所以[EAX+2]指的是PEB.BeingDebugged成员 从图中可以看出[EAX+2]=[7ffdf002]=PEB.BeingDebugged的值为1 表示进程处于调试状态</span><br><span class="line"></span><br><span class="line">![](31.png)</span><br></pre></td></tr></table></figure></p>
<p>JNE SHORT 00401076<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">若CMP指令的两个对象不同 则JNE就进行跳转 由于PEB.BeingDebugged的值为1 则不进行跳转</span><br><span class="line">![](32.png)</span><br></pre></td></tr></table></figure></p>
<p>MOV DWORD PTR DS:[ESI+0B8],00401023<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">上述指令用来将pContext-&gt;Eip值改为401023 异常处理器终止时 发生异常的线程会运行401023地址处的代码 弹出“Debugger detected:(”消息框</span><br><span class="line"></span><br><span class="line">![](33.png)</span><br><span class="line">在401023处设置一个断点</span><br></pre></td></tr></table></figure></p>
<p>JMP SHORT 00401080<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于pContext-&gt;Eip值改变 所以执行跳转到异常处理器的终止代码处（401080）</span><br></pre></td></tr></table></figure></p>
<p>MOV DWORD PTR DS:[ESI+0B8],00401039<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">若程序运行在非调试状态下，则执行401068地址处的JNZ指令,跳转到401076地址处。如上所示，401076地址处的指令用来将pContext→Eip值更改为401039， 401039地址处的代码用来弹出消息对话框，显示“Hello:)”消息文本</span><br><span class="line"></span><br><span class="line">![](34.png)</span><br></pre></td></tr></table></figure></p>
<p>XOR EAX,EAX<br>RETN<br><code>`</code><br>最后两条指令中先将返回值( EAX )设置为0,然后异常处理器返回。返回值0代表EXCEPTION_CONTINUE_ EXECUTION,表示异常得到处理，相关线程可以继续运行</p>
<p><strong>本练习示例( seh.exe)的目的在于向各位展示使用SEH进行反调试的技术。所以在代码中故意引发了异常，然后在SEH中根据调试与否修改了运行分支。若熟悉了该技术，调试压缩器/保护器类的文件时会非常有帮助。</strong></p>
<p>运行到401082地址处的RETN指令时，控制权被返回至ntdlI1模块中的代码区域，它属于系统区域，所以在OllyDbg中按F9运行键后，调试会在401023地址处(设置有断点)暂停。</p>
<p>使用StepOver(F8)指令使调试运行到401031地址处的CALL指令,弹出一个消息框。按“确定”按钮关闭消息框后，执行401037地址处的JMP SHORT 40104D指令，跳转到删除SEH的代码处( 40104D )。</p>
<h3 id="删除SEH"><a href="#删除SEH" class="headerlink" title="删除SEH"></a>删除SEH</h3><p>在程序终止前删除已注册的SHE,如图所示。</p>
<p>调试运行到40104D地址处查看栈, EXCEPTION REGISTRATION RECORD结构体存储在其中( 12FF3C ),该结构体是SEH链中最初运行的异常处理器。40104D处的POP DWORD PTR FS:[0]指令用来读取栈值( 12FF78),并将其放人FS:[0]。FS:[0]是TEB.NtTib. ExceptionList, 12FF78就是下一个SEH的起始地址。执行该命令后，前面注册的SEH ( 12FF3C )被从SEH链中删除。然后执行401054地址处的ADD ESP,4指令,将栈中的异常处理器地址( 40105A)也删除。请各位反复调试，查清栈中数据变化的情况。</p>
<p><img src="35.png" alt=""></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>SEH大量应用于压缩器、保护器、恶意程序( Malware ),用来反调试。大家研究与调试SEH的过程中，会进一步加深对Wiondows OS内部结构的认识,提高自身逆向分析技术水平。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/26/TLS回调函数/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/26/TLS回调函数/" itemprop="url">TLS回调函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-26T17:11:45+08:00">
                2019-05-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="练习-1"><a href="#练习-1" class="headerlink" title="练习#1"></a>练习#1</h1><p>运行练习文件（HelloTls.exe）弹出消息框 单击 确定 结束程序</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/05/26/TLS回调函数/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/26/内核6中的DLL注入/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/26/内核6中的DLL注入/" itemprop="url">内核6中的DLL注入</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-26T13:31:36+08:00">
                2019-05-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="再现DLL注入失败"><a href="#再现DLL注入失败" class="headerlink" title="再现DLL注入失败"></a>再现DLL注入失败</h1><p>尝试将Dummy.dll文件注入Windows7的系统时 会出现失败 接下来将再现</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/05/26/内核6中的DLL注入/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/23/ASLR/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/23/ASLR/" itemprop="url">ASLR</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-23T20:08:14+08:00">
                2019-05-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>ASLR是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的的一种技术。</p>
<p>ASLR（Address space layout randomization）是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的。据研究表明ASLR可以有效的降低缓冲区溢出攻击的成功率，如今Linux、FreeBSD、Windows等主流操作系统都已采用了该技术。</p>
<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>用OD载入ASLR和ASLR_no两个程序<br><img src="1.png" alt=""><br><img src="8.png" alt=""><br>看起来基址不一样的 这就是ALSR文件的区别 每次载入都会改变基址 我们用PEView载入程序看看<br><img src="2.png" alt=""><br>节区信息<br>对于普通的EXE文件不存在.reloc文件 只有用了ASLR技术的应用才会有 被加载在内存时 被用作重定位的参考 它不是必须部分 可以删除 </p>
<p>再来看看这两部分 ASLR的characteristics属性字段并不存在这一段 因为ASLR.exe文件中多出来1个.reloc节区 所以Number of Sections值增1</p>
<p><img src="3.png" alt=""><br>ASLR文件的DLL Characteristics中设有这一段 这也就是ASLR文件的标志了<br><img src="4.png" alt=""></p>
<h1 id="删除ALSR功能"><a href="#删除ALSR功能" class="headerlink" title="删除ALSR功能"></a>删除ALSR功能</h1><p>我们使用Stud_PE工具修改ASLR.exe文件 载入可以看到应用的相关信息 并点击这里可以看到<br><img src="5.png" alt=""><br>我们找到DLL Characteristics的地方 并看到他在内存中的值 我们将属性值由8140改成8100 然后保存文件<br><img src="6.png" alt=""><br><img src="7.png" alt=""><br>再次载入ASLR文件 可以看到基址和ASLR_no文件一样了 这样就将文件删除ALSR功能了<br><img src="9.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/20/OD学习5-25/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/20/OD学习5-25/" itemprop="url">OD学习5-25</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-20T19:12:10+08:00">
                2019-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="高级全局API钩取：IE连接控制"><a href="#高级全局API钩取：IE连接控制" class="headerlink" title="高级全局API钩取：IE连接控制"></a>高级全局API钩取：IE连接控制</h1><h2 id="调试IE进程"><a href="#调试IE进程" class="headerlink" title="调试IE进程"></a>调试IE进程</h2><p>常见网络连接库：ws2_32.dll（套接字），wininet.dll，winhttp.dll</p>
<p>使用Process Explorer查看IE加载的DLL</p>
<p>IE不仅加载了ws2_32.dll还加载了wininet.dll，wininet.dll中提供的API中有个名为InternetConnect()的API，这个API用来连接网站</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HINTERNET InternetConnect(</span><br><span class="line">  _In_ HINTERNET     hInternet,</span><br><span class="line">  _In_ LPCTSTR       lpszServerName,</span><br><span class="line">  _In_ INTERNET_PORT nServerPort,</span><br><span class="line">  _In_ LPCTSTR       lpszUsername,</span><br><span class="line">  _In_ LPCTSTR       lpszPassword,</span><br><span class="line">  _In_ DWORD         dwService,</span><br><span class="line">  _In_ DWORD         dwFlags,</span><br><span class="line">  _In_ DWORD_PTR     dwContext</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>首先先打开IE浏览器 等待浏览器加载完：</p>
<p><img src="7.png" alt=""><br>然后打开OD附加进程 这里发现有两个IE的进程 随便加载一个都行</p>
<p><img src="8.png" alt=""><br>加载之后在反汇编窗口右击选择</p>
<p><img src="9.png" alt=""><br>接下来找到InternetConnectW()API函数</p>
<p><img src="10.png" alt=""><br>双击来到这里 设置断点</p>
<p><img src="11.png" alt=""><br>点击F9运行一次 然后在浏览器中输入网址</p>
<p><img src="12.png" alt=""><br>回车发现浏览器并没有跳转 OD处于暂停状态 右下角数据窗口是刚才输入的网址</p>
<p><img src="13.png" alt=""><br>下来在数据窗口跟随 发现网址后更改为另外一个网址</p>
<p><img src="14.png" alt=""><br>取消断点后F9运行程序<br><img src="15.png" alt=""><br>发现已经跳转到更改后的网址了 </p>
<h2 id="IE的进程结构"><a href="#IE的进程结构" class="headerlink" title="IE的进程结构"></a>IE的进程结构</h2><p>IE的每个选项卡对应一个进程，统一由一个父进程管理。所以钩取API时需要使用全局钩取。</p>
<p>这里通过钩取ntdll!ZwResumeThread钩取子进程</p>
<h2 id="全局钩取ntdll-ResumeThread-API"><a href="#全局钩取ntdll-ResumeThread-API" class="headerlink" title="全局钩取ntdll!ResumeThread API"></a>全局钩取ntdll!ResumeThread API</h2><p>因为最终目的是控制IE的网络连接，所以dll注入时仅需向所有的iexplore.exe进程中注入即可，无需对其他无关进程注入dll</p>
<p>我们首先想想创建子进程的API有哪些 创建进程API中最具代表性的绝对是kernel32！CreateProcess{}API 下面调试一个简单的程序来测试CreateProcess（）API ：</p>
<h3 id="cptest-exe"><a href="#cptest-exe" class="headerlink" title="cptest.exe"></a>cptest.exe</h3><p>用OD载入cptest程序 发现这个程序和载入ie程序的一样 反汇编窗口右击查找所有模块名称 然后进入kernel32！CreateProcessW() 发现在内部又调用了kernel32！CreateProcessInternelW()：</p>
<p><img src="16.png" alt=""><br>给kernel32！CreateProcessW()设置断点F9运行 接下来单步跟踪进入kernel32！CreateProcessInternelW()：</p>
<p><img src="17.png" alt=""><br>kernel32！CreateProcessInternelW()是一个相当大的函数 滚动条往下翻就会找到ntdll!ZwCreateUserProcess（） API：</p>
<p><img src="18.png" alt=""><br>查看图中栈中出现了字符串notepad.exe同时在数据窗口也可以看到</p>
<p><img src="19.png" alt=""><br>在process Explorer中可以看到notepad被暂时挂起 分配了PID却没有运行程序<br><img src="20.png" alt=""><br>在OD中继续单步运行程序 可以看到调用ntdll.ZwResumeThread（）API的代码<br><img src="21.png" alt=""><br>而ntdll.ZwResumeThread（）API函数就是用来恢复运行线程的 该线程是子进程（notepad.exe）的主进程 所以运行此代码时 子进程的EP代码才会执行 我们可以看见进程中的Suspended（挂起）已经不见了</p>
<p><img src="51.png" alt=""><br>综上所述 CreateProcessW（）API的调用流程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kernel32！CreateProcessW()</span><br><span class="line">	kernel32！CreateProcessInternelW()</span><br><span class="line">		ntdll!ZwCreateUserProcess（） //创建进程（主线程处于挂起状态）</span><br><span class="line">		ntdll.ZwResumeThread（）	//主线程被恢复运行（运行进程）</span><br></pre></td></tr></table></figure></p>
<p>创建子进程最后调用的是ntdll.ZwResumeThread（）API 所以钩取该API 在子进程的EP代码运行之前 拦截获取控制权 然后钩取指定API </p>
<p>前面的4个API都能实现实现我们的目标—全局API钩取</p>
<h2 id="控制IE浏览器"><a href="#控制IE浏览器" class="headerlink" title="控制IE浏览器"></a>控制IE浏览器</h2><h3 id="运行IE"><a href="#运行IE" class="headerlink" title="运行IE"></a>运行IE</h3><p>首先运行IE浏览器 然后使用process Explorer查看运行中的IE进程的结构</p>
<p>我们可以看到 IE进程以父子进程的形式进行 只要钩取夫进程的ntdll.ZwResumeThread（）API 那么后面的所有子进程都会被钩取</p>
<p><img src="52.png" alt=""></p>
<h3 id="注入DLL"><a href="#注入DLL" class="headerlink" title="注入DLL"></a>注入DLL</h3><p>使用如图InjDll.exe命令 将redirect.dll文件注入IE进程<br><img src="53.png" alt=""><br>查看DLL注入成功<br><img src="54.png" alt=""></p>
<h3 id="卸载DLL"><a href="#卸载DLL" class="headerlink" title="卸载DLL"></a>卸载DLL</h3><p>我们可以看到DLL已经卸载成功<br><img src="55.png" alt=""></p>
<h2 id="源代码分析"><a href="#源代码分析" class="headerlink" title="源代码分析"></a>源代码分析</h2><h3 id="DllMain"><a href="#DllMain" class="headerlink" title="DllMain"></a>DllMain</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span><br><span class="line">&#123;</span><br><span class="line">    char            szCurProc[MAX_PATH] = &#123;0,&#125;;</span><br><span class="line">    char            *p = NULL;</span><br><span class="line"></span><br><span class="line">    switch( fdwReason )</span><br><span class="line">    &#123;</span><br><span class="line">        case DLL_PROCESS_ATTACH : </span><br><span class="line">            DebugLog(&quot;DllMain() : DLL_PROCESS_ATTACH\n&quot;);</span><br><span class="line"></span><br><span class="line">            GetModuleFileNameA(NULL, szCurProc, MAX_PATH);</span><br><span class="line">            p = strrchr(szCurProc, &apos;\\&apos;);</span><br><span class="line">            if( (p != NULL) &amp;&amp; !_stricmp(p+1, &quot;iexplore.exe&quot;) )</span><br><span class="line">            &#123;</span><br><span class="line">                DebugLog(&quot;DllMain() : current process is [iexplore.exe]\n&quot;);</span><br><span class="line"></span><br><span class="line">                //为了防止在Dll注入时wininet.dll还未被加载，所以手动加载一下wininet.dll</span><br><span class="line">                if( NULL == LoadLibrary(L&quot;wininet.dll&quot;) )</span><br><span class="line">                &#123;</span><br><span class="line">                    DebugLog(&quot;DllMain() : LoadLibrary() failed!!! [%d]\n&quot;,</span><br><span class="line">                             GetLastError());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // hook</span><br><span class="line">            hook_by_code(&quot;ntdll.dll&quot;, &quot;ZwResumeThread&quot;, </span><br><span class="line">                         (PROC)NewZwResumeThread, g_pZWRT);</span><br><span class="line">            hook_by_code(&quot;wininet.dll&quot;, &quot;InternetConnectW&quot;, </span><br><span class="line">                         (PROC)NewInternetConnectW, g_pICW);</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case DLL_PROCESS_DETACH :</span><br><span class="line">            DebugLog(&quot;DllMain() : DLL_PROCESS_DETACH\n&quot;);</span><br><span class="line"></span><br><span class="line">            // unhook</span><br><span class="line">            unhook_by_code(&quot;ntdll.dll&quot;, &quot;ZwResumeThread&quot;, </span><br><span class="line">                           g_pZWRT);</span><br><span class="line">            unhook_by_code(&quot;wininet.dll&quot;, &quot;InternetConnectW&quot;, </span><br><span class="line">                           g_pICW);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数的核心功能是ZwResumeThread()和InternetConnectW()API的“挂钩/脱钩”功能 其中有条语句特别明显 若加载进程名为IE.exe时 则加载wininet.dll文件 这和全局API钩取的特性有关 钩取ZwResumeThread（）API时 需要在相关进程开始之前就获得拦截权 此时我们钩取的wininet.dll可能还未加载</p>
<h3 id="NewInternetConnectW"><a href="#NewInternetConnectW" class="headerlink" title="NewInternetConnectW"></a>NewInternetConnectW</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">HINTERNET WINAPI NewInternetConnectW</span><br><span class="line">(</span><br><span class="line">    HINTERNET hInternet,</span><br><span class="line">    LPCWSTR lpszServerName,</span><br><span class="line">    INTERNET_PORT nServerPort,</span><br><span class="line">    LPCTSTR lpszUsername,</span><br><span class="line">    LPCTSTR lpszPassword,</span><br><span class="line">    DWORD dwService,</span><br><span class="line">    DWORD dwFlags,</span><br><span class="line">    DWORD_PTR dwContext</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    HINTERNET hInt = NULL;</span><br><span class="line">    FARPROC pFunc = NULL;</span><br><span class="line">    HMODULE hMod = NULL;</span><br><span class="line"></span><br><span class="line">    // unhook</span><br><span class="line">    if( !unhook_by_code(&quot;wininet.dll&quot;, &quot;InternetConnectW&quot;, g_pICW) )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewInternetConnectW() : unhook_by_code() failed!!!\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // call original API</span><br><span class="line">    hMod = GetModuleHandle(L&quot;wininet.dll&quot;);</span><br><span class="line">    if( hMod == NULL )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewInternetConnectW() : GetModuleHandle() failed!!! [%d]\n&quot;,</span><br><span class="line">                  GetLastError());</span><br><span class="line">        goto __INTERNETCONNECT_EXIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pFunc = GetProcAddress(hMod, &quot;InternetConnectW&quot;);</span><br><span class="line">    if( pFunc == NULL )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewInternetConnectW() : GetProcAddress() failed!!! [%d]\n&quot;,</span><br><span class="line">                  GetLastError());</span><br><span class="line">        goto __INTERNETCONNECT_EXIT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //修改原API调用时的第二个参数</span><br><span class="line">    if( !_tcsicmp(lpszServerName, L&quot;www.naver.com&quot;) ||</span><br><span class="line">        !_tcsicmp(lpszServerName, L&quot;www.daum.net&quot;) ||</span><br><span class="line">        !_tcsicmp(lpszServerName, L&quot;www.nate.com&quot;) || </span><br><span class="line">        !_tcsicmp(lpszServerName, L&quot;www.yahoo.com&quot;) )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;[redirect] naver, daum, nate, yahoo =&gt; reversecore\n&quot;);</span><br><span class="line">        hInt = ((PFINTERNETCONNECTW)pFunc)(hInternet,</span><br><span class="line">                                           L&quot;www.reversecore.com&quot;,</span><br><span class="line">                                           nServerPort,</span><br><span class="line">                                           lpszUsername,</span><br><span class="line">                                           lpszPassword,</span><br><span class="line">                                           dwService,</span><br><span class="line">                                           dwFlags,</span><br><span class="line">                                           dwContext);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;[no redirect]\n&quot;);</span><br><span class="line">        hInt = ((PFINTERNETCONNECTW)pFunc)(hInternet,</span><br><span class="line">                                           lpszServerName,</span><br><span class="line">                                           nServerPort,</span><br><span class="line">                                           lpszUsername,</span><br><span class="line">                                           lpszPassword,</span><br><span class="line">                                           dwService,</span><br><span class="line">                                           dwFlags,</span><br><span class="line">                                           dwContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">__INTERNETCONNECT_EXIT:</span><br><span class="line"></span><br><span class="line">    // hook</span><br><span class="line">    if( !hook_by_code(&quot;wininet.dll&quot;, &quot;InternetConnectW&quot;, </span><br><span class="line">                      (PROC)NewInternetConnectW, g_pICW) )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewInternetConnectW() : hook_by_code() failed!!!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return hInt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InternetConnectW()的钩取函数为NewInternetConnectW()函数 他负责监视IE的连接地址 IE连接到特定网站时 将其转到我们的指定网站</p>
<h3 id="NewZwResumeThread"><a href="#NewZwResumeThread" class="headerlink" title="NewZwResumeThread"></a>NewZwResumeThread</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">//ThreadHandle是要恢复运行的线程的句柄(即子进程的主线程)</span><br><span class="line">NTSTATUS WINAPI NewZwResumeThread(HANDLE ThreadHandle, PULONG SuspendCount)</span><br><span class="line">&#123;</span><br><span class="line">    NTSTATUS status, statusThread;</span><br><span class="line">    FARPROC pFunc = NULL, pFuncThread = NULL;</span><br><span class="line">    DWORD dwPID = 0;</span><br><span class="line">    static DWORD dwPrevPID = 0;</span><br><span class="line">    THREAD_BASIC_INFORMATION tbi;</span><br><span class="line">    HMODULE hMod = NULL;</span><br><span class="line">    TCHAR szModPath[MAX_PATH] = &#123;0,&#125;;</span><br><span class="line"></span><br><span class="line">    DebugLog(&quot;NewZwResumeThread() : start!!!\n&quot;);</span><br><span class="line"></span><br><span class="line">    hMod = GetModuleHandle(L&quot;ntdll.dll&quot;);</span><br><span class="line">    if( hMod == NULL )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewZwResumeThread() : GetModuleHandle() failed!!! [%d]\n&quot;,</span><br><span class="line">                  GetLastError());</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 调用ntdll!ZwQueryInformationThread()，通过线程句柄获取其对应进程PID</span><br><span class="line">    pFuncThread = GetProcAddress(hMod, &quot;ZwQueryInformationThread&quot;);</span><br><span class="line">    if( pFuncThread == NULL )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewZwResumeThread() : GetProcAddress() failed!!! [%d]\n&quot;,</span><br><span class="line">                  GetLastError());</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    statusThread = ((PFZWQUERYINFORMATIONTHREAD)pFuncThread)</span><br><span class="line">                   (ThreadHandle, 0, &amp;tbi, sizeof(tbi), NULL);</span><br><span class="line">    if( statusThread != STATUS_SUCCESS )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewZwResumeThread() : pFuncThread() failed!!! [%d]\n&quot;, </span><br><span class="line">                 GetLastError());</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //子进程PID</span><br><span class="line">    dwPID = (DWORD)tbi.ClientId.UniqueProcess;</span><br><span class="line">    if ( (dwPID != GetCurrentProcessId()) &amp;&amp; (dwPID != dwPrevPID) )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewZwResumeThread() =&gt; call InjectDll()\n&quot;);</span><br><span class="line"></span><br><span class="line">        dwPrevPID = dwPID;</span><br><span class="line"></span><br><span class="line">        // change privilege</span><br><span class="line">        // 打开SeDebugPrivilege特权</span><br><span class="line">        if( !SetPrivilege(SE_DEBUG_NAME, TRUE) )</span><br><span class="line">            DebugLog(&quot;NewZwResumeThread() : SetPrivilege() failed!!!\n&quot;);</span><br><span class="line"></span><br><span class="line">        // 获取要注入的dll的路径</span><br><span class="line">        GetModuleFileName(GetModuleHandle(STR_MODULE_NAME), </span><br><span class="line">                          szModPath, </span><br><span class="line">                          MAX_PATH);</span><br><span class="line">        // 注入dll</span><br><span class="line">        if( !InjectDll(dwPID, szModPath) )</span><br><span class="line">            DebugLog(&quot;NewZwResumeThread() : InjectDll(%d) failed!!!\n&quot;, dwPID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // call ntdll!ZwResumeThread()</span><br><span class="line">    if( !unhook_by_code(&quot;ntdll.dll&quot;, &quot;ZwResumeThread&quot;, g_pZWRT) )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewZwResumeThread() : unhook_by_code() failed!!!\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pFunc = GetProcAddress(hMod, &quot;ZwResumeThread&quot;);</span><br><span class="line">    if( pFunc == NULL )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewZwResumeThread() : GetProcAddress() failed!!! [%d]\n&quot;,</span><br><span class="line">                  GetLastError());</span><br><span class="line">        goto __NTRESUMETHREAD_END;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = ((PFZWRESUMETHREAD)pFunc)(ThreadHandle, SuspendCount);</span><br><span class="line">    if( status != STATUS_SUCCESS )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewZwResumeThread() : pFunc() failed!!! [%d]\n&quot;, GetLastError());</span><br><span class="line">        goto __NTRESUMETHREAD_END;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">__NTRESUMETHREAD_END:</span><br><span class="line"></span><br><span class="line">    if( !hook_by_code(&quot;ntdll.dll&quot;, &quot;ZwResumeThread&quot;, </span><br><span class="line">                      (PROC)NewZwResumeThread, g_pZWRT) )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewZwResumeThread() : hook_by_code() failed!!!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DebugLog(&quot;NewZwResumeThread() : end!!!\n&quot;);</span><br><span class="line"></span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数负责对ntdll.ZwResumeThread（）API进行全局钩取</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/15/OD学习5-18/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/15/OD学习5-18/" itemprop="url">OD学习5-18</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-15T17:16:31+08:00">
                2019-05-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="计算器显示成文字"><a href="#计算器显示成文字" class="headerlink" title="计算器显示成文字"></a>计算器显示成文字</h1><h2 id="OD法更改"><a href="#OD法更改" class="headerlink" title="OD法更改"></a>OD法更改</h2><p>首先利用OD修改内存中的值来实现计算器显示中文数字（这次还是在XP虚拟机里运行的）</p>
<p>用OD打开calc.exe 快捷键ctrl+N查看目标文件的API函数 </p>
<p><img src="22.png" alt=""><br>这里我们发现的两个值得关注的API函数 SetWinsowTextW（）和SetDlgItemTextW（） 他们负责向计算器的文本显示框中显示文本 来看看SetWinsowTextW（）API定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOLSetWindowText(</span><br><span class="line">HWNDhwnd,</span><br><span class="line">LPCTSTRlpString</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>hWnd</strong><br>要改变文本内容的窗口或控件的句柄。不能改变在其他应用程序中的控件的文本内容，如果需要可以用另外一个SendMessage函数发送一条WM_SETTEXT消息。</p>
<p><strong>lpString</strong><br>指向一个空结束的字符串的指针，该字符串将作为窗口或控件的新文本。</p>
<p>这里我们关注第二个参考——字符串指针（lpString）钩取时查看字符串（lpString）中的内容 将其中的阿拉伯数字改成中文就行</p>
<p>然后在刚才关注的那两个API函数上设置断点<br><img src="23.png" alt=""><br>运行<br><img src="24.png" alt=""><br>第一次运行断在了SetwindowTextW这里 右下角堆栈窗口发现字符0就是计算器开始的在字符0<br><img src="25.png" alt=""><br>在运行断在了SetDlgItemTextW（）处 再次运行一下 计算器的页面出现了 为了继续调试 我们望计算器中输入7 发现OD自动在SetwindowTextW这里停了</p>
<p><img src="26.png" alt=""><br>看到了刚才说的那两个参数 在数据窗口跟随TEXT那一项发现了储存的数字7<br><img src="27.png" alt=""><br>将中文数字 七 的Unicode码（4e03）覆写到地址处 这里记得要逆序（034e）写入<br><img src="28.png" alt=""><br>发现数字7已经变成汉字七了！<br><img src="29.png" alt=""><br>运行程序在计算器中看到已经变了：<br><img src="30.png" alt=""><br>这里就算完成了OD的过程 对SetWinsowTextW（）API验证结束 接下来看看IAT钩取操作及其实现原理 </p>
<h2 id="IAT钩取工作原理"><a href="#IAT钩取工作原理" class="headerlink" title="IAT钩取工作原理"></a>IAT钩取工作原理</h2><p>IAT钩取通过修改IAT中保存的API地址来钩取某个API 如图：<br><img src="5.png" alt=""><br><img src="6.png" alt=""><br>钩取IAT前 首先向计算器进程注入hookiat.dll文件<br>原理：在保持运行代码不变的情况下 讲IAT中保存的API起始地址变为用户函数的起始地址</p>
<h2 id="练习示例"><a href="#练习示例" class="headerlink" title="练习示例"></a>练习示例</h2><p>先复制文件到工作目录（c:work）然后运行calc.exe程序 再打开任务管理器查看其PID 如图：<br><img src="31.png" alt=""><br>然后在命令窗口执行如图命令：<br><img src="32.png" alt=""><br>接下来在计算器随便输入一些数值 如图：<br><img src="33.png" alt=""><br>我们可以看到 输入的数值已经变成了中文 计算器也在正常运行（其实我自己调试的这个InjectDLL.exe注入的hookiat.dll注入之后计算器显示的是韩文 可能是韩国人整的DLL文件吧 但确实是钩取成功了！！）</p>
<h2 id="源代码分析（hookiat-dll）"><a href="#源代码分析（hookiat-dll）" class="headerlink" title="源代码分析（hookiat.dll）"></a>源代码分析（hookiat.dll）</h2><h3 id="Dllmain（）"><a href="#Dllmain（）" class="headerlink" title="Dllmain（）"></a>Dllmain（）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span><br><span class="line">&#123;</span><br><span class="line">	switch( fdwReason )</span><br><span class="line">	&#123;</span><br><span class="line">		case DLL_PROCESS_ATTACH : </span><br><span class="line">            // 保存原始API的地址</span><br><span class="line">           	g_pOrgFunc = GetProcAddress(GetModuleHandle(L&quot;user32.dll&quot;), </span><br><span class="line">                                        &quot;SetWindowTextW&quot;);</span><br><span class="line"> </span><br><span class="line">            // # hook</span><br><span class="line">            //   用hookiat.MySetWindowText钩取user32.SetWindowTextW</span><br><span class="line">			hook_iat(&quot;user32.dll&quot;, g_pOrgFunc, (PROC)MySetWindowTextW);</span><br><span class="line">			break;</span><br><span class="line"> </span><br><span class="line">		case DLL_PROCESS_DETACH :</span><br><span class="line">            // # unhook</span><br><span class="line">            //   将calc.exe的IAT恢复原值</span><br><span class="line">            hook_iat(&quot;user32.dll&quot;, (PROC)MySetWindowTextW, g_pOrgFunc);</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在DLL_PROCESS_ATTACH事件中先获取user32.SetWindowTextW的地址，然后保存到全局变量g_pOrgFunc中，后面脱钩会用到这个地址。</p>
<h3 id="MySetWindowTextW"><a href="#MySetWindowTextW" class="headerlink" title="MySetWindowTextW()"></a>MySetWindowTextW()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI MySetWindowTextW(HWND hWnd, LPWSTR lpString)</span><br><span class="line">&#123;</span><br><span class="line">    wchar_t* pNum = L&quot;零一二三四五六七八九&quot;;</span><br><span class="line">    wchar_t temp[2] = &#123;0,&#125;;</span><br><span class="line">    int i = 0, nLen = 0, nIndex = 0;</span><br><span class="line"> </span><br><span class="line">    nLen = wcslen(lpString);</span><br><span class="line">    for(i = 0; i &lt; nLen; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //   将阿拉伯数字转换为中文数字</span><br><span class="line">        //   lpString是宽字符版本(2个字节)字符串</span><br><span class="line">        if( L&apos;0&apos; &lt;= lpString[i] &amp;&amp; lpString[i] &lt;= L&apos;9&apos; )</span><br><span class="line">        &#123;</span><br><span class="line">            temp[0] = lpString[i];</span><br><span class="line">            nIndex = _wtoi(temp);</span><br><span class="line">            lpString[i] = pNum[nIndex];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //   调用user32.SetWindowTextW</span><br><span class="line">    //   (修改lpString缓冲区中的内容)</span><br><span class="line">    return ((PFSETWINDOWTEXTW)g_pOrgFunc)(hWnd, lpString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lpString参数是一块缓冲区，该缓冲区用来存放要输出显示的字符串。for循环将存放在lpString的阿拉伯数字字符串转换为中文数字字符串。for循环结束后，最后再调用函数指针g_pOrgFunc。</p>
<p>hook_iat()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">BOOL hook_iat(LPCSTR szDllName, PROC pfnOrg, PROC pfnNew)</span><br><span class="line">&#123;</span><br><span class="line">	HMODULE hMod;</span><br><span class="line">	LPCSTR szLibName;</span><br><span class="line">	PIMAGE_IMPORT_DESCRIPTOR pImportDesc; </span><br><span class="line">	PIMAGE_THUNK_DATA pThunk;</span><br><span class="line">	DWORD dwOldProtect, dwRVA;</span><br><span class="line">	PBYTE pAddr;</span><br><span class="line"> </span><br><span class="line">    // hMod, pAddr = ImageBase of calc.exe</span><br><span class="line">    //             = VA to MZ signature (IMAGE_DOS_HEADER)</span><br><span class="line">	hMod = GetModuleHandle(NULL);</span><br><span class="line">	pAddr = (PBYTE)hMod;</span><br><span class="line"> </span><br><span class="line">    // pAddr = VA to PE signature (IMAGE_NT_HEADERS)</span><br><span class="line">	pAddr += *((DWORD*)&amp;pAddr[0x3C]);</span><br><span class="line"> </span><br><span class="line">    // dwRVA = RVA to IMAGE_IMPORT_DESCRIPTOR Table</span><br><span class="line">	dwRVA = *((DWORD*)&amp;pAddr[0x80]);</span><br><span class="line"> </span><br><span class="line">    // pImportDesc = VA to IMAGE_IMPORT_DESCRIPTOR Table</span><br><span class="line">	pImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)hMod+dwRVA);</span><br><span class="line"> </span><br><span class="line">	for( ; pImportDesc-&gt;Name; pImportDesc++ )</span><br><span class="line">	&#123;</span><br><span class="line">        // szLibName = VA to IMAGE_IMPORT_DESCRIPTOR.Name</span><br><span class="line">		szLibName = (LPCSTR)((DWORD)hMod + pImportDesc-&gt;Name);</span><br><span class="line">		if( !_stricmp(szLibName, szDllName) )</span><br><span class="line">		&#123;</span><br><span class="line">            // pThunk = IMAGE_IMPORT_DESCRIPTOR.FirstThunk</span><br><span class="line">            //        = VA to IAT(Import Address Table)</span><br><span class="line">			pThunk = (PIMAGE_THUNK_DATA)((DWORD)hMod + </span><br><span class="line">                                         pImportDesc-&gt;FirstThunk);</span><br><span class="line"> </span><br><span class="line">            // pThunk-&gt;u1.Function = VA to API</span><br><span class="line">			for( ; pThunk-&gt;u1.Function; pThunk++ )</span><br><span class="line">			&#123;</span><br><span class="line">				if( pThunk-&gt;u1.Function == (DWORD)pfnOrg )</span><br><span class="line">				&#123;</span><br><span class="line">                </span><br><span class="line">					VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, </span><br><span class="line">                                   4, </span><br><span class="line">                                   PAGE_EXECUTE_READWRITE, </span><br><span class="line">                                   &amp;dwOldProtect);</span><br><span class="line"> </span><br><span class="line">                    pThunk-&gt;u1.Function = (DWORD)pfnNew;</span><br><span class="line">				</span><br><span class="line">                    VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, </span><br><span class="line">                                   4, </span><br><span class="line">                                   dwOldProtect, </span><br><span class="line">                                   &amp;dwOldProtect);						</span><br><span class="line"> </span><br><span class="line">					return TRUE;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	return FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数主要负责钩取API</p>
<p>首先从ImageBase开始经由PE签名找到IDT<br><img src="34.png" alt=""><br><img src="35.png" alt=""><br><img src="36.png" alt=""><br>pImportDesc变量中存储着IMAGE_IMPORT_DESCRIPTOR结构体的起始地址，后者是calc.exe进程IDT的第一个结构体。IDT是由IMAGE_IMPORT_DESCRIPTOR结构体组成的数组。若想查找到IAT，先要查找到这个位置。使用PEView查看该地址(00012B80+01000000=01012B80)，如图所示。</p>
<p><img src="37.png" alt=""><br>在for循环中通过比较查找到user32.dll的IMAGE_IMPORT_DESCRIPTOR结构体地址，从上图可以看出最终pImportDesc的值为01012BF4。接下来进入user32的IAT，pImportDesc-&gt;FirstThunk成员所指的就是IAT。使用PEView查看该地址(000010A4+01000000=010010A4)，如图所示</p>
<p><img src="38.png" alt=""><br>接下来又在for循环中查找SetWindowTextW的IAT地址(01001110)，然后修改它的值。因为计算器进程的IAT内存区域是只读的，所以需要使用VirtualProtect在钩取之前将相应的区域改为可读写的，钩取之后再改回来。</p>
<h1 id="调试被注入的DLL文件"><a href="#调试被注入的DLL文件" class="headerlink" title="调试被注入的DLL文件"></a>调试被注入的DLL文件</h1><p>首先运行calc程序 查看其PID的值<br><img src="39.png" alt=""><br>将程序进程附加到OD中 然后在事件中选定中断于新DLL进程 然后将hookiat.dll注入计算器进程<br><img src="41.png" alt=""><br>运行程序发现：<br><img src="40.png" alt=""><br>双击进入hookiat.dll中 接下来取消刚才事件中的中断于新DLL的选项 然后在hookiat模块查找参考字符串寻找DllMain（）代码 当然也可以F7单步跟踪查找 DllMain()函数中使用的字符串有“user32.dll”和“SetWindowTextW”</p>
<p><img src="42.png" alt=""><br>我们发现“user32.dll”有两处“SetWindowTextW”有一处 转到“SetWindowTextW”处：</p>
<p><img src="43.png" alt=""><br>框出来的内容就是DllMain（）函数了</p>
<p>这就是调试注入进程Dll的方法了</p>
<h2 id="Dllmain（）-1"><a href="#Dllmain（）-1" class="headerlink" title="Dllmain（）"></a>Dllmain（）</h2><p><img src="44.png" alt=""><br>这个call语句就是调用hook_iat()<br>步入刚才那个call语句进入hook_iat()</p>
<h2 id="hook-iat"><a href="#hook-iat" class="headerlink" title="hook_iat()"></a>hook_iat()</h2><h3 id="查找IMAGE-IMPORT-DESCRIPTION-Table"><a href="#查找IMAGE-IMPORT-DESCRIPTION-Table" class="headerlink" title="查找IMAGE_IMPORT_DESCRIPTION Table"></a>查找IMAGE_IMPORT_DESCRIPTION Table</h3><p>hook_iat()是负责具体实施IAT钩取的核心函数 下面是调试一下：<br><img src="45.png" alt=""><br>框起来的部分就是IMAGE_IMPORT_DESCRIPTION Table（下面简称“IID Table”）的过程 一时难分代码仅仅用了4行代码就找到了ID Table</p>
<p><img src="46.png" alt=""><br>这个call指令用于调用stricmp（）函数。</p>
<h3 id="在IAT中查找SetWindowTextW-API位置"><a href="#在IAT中查找SetWindowTextW-API位置" class="headerlink" title="在IAT中查找SetWindowTextW API位置"></a>在IAT中查找SetWindowTextW API位置</h3><p>通过便利IID Table比较IID.Name于“user32.dll”字符串 查找到user32.dll的IID  找到之后 下面代码用来查找SetWindowTextW API位置 然后修改其中内容 从而实现对API的钩取</p>
<p><img src="47.png" alt=""><br>cmp语句中ESI的值为user32.dll的IAT起始地址 EBP的值为SetWindowTextW的地址 代码循环进入IAT SetWindowTextW的地址值（ebp的值）</p>
<h3 id="IAT钩取"><a href="#IAT钩取" class="headerlink" title="IAT钩取"></a>IAT钩取</h3><p>IAT钩取代码<br><img src="48.png" alt=""><br>MOV指令用来将MySetWindowTextW的地址覆写到前面从IAT中获取的SetWindowTextW的地址 执行后就变成了执行MySetWindowTextW地址的代码 也就是将数字变成汉字的代码段</p>
<h1 id="隐藏进程"><a href="#隐藏进程" class="headerlink" title="隐藏进程"></a>隐藏进程</h1><h2 id="API代码修改技术的原理"><a href="#API代码修改技术的原理" class="headerlink" title="API代码修改技术的原理"></a>API代码修改技术的原理</h2><p>IAT钩取通过操作进程的特定IAT值来实现API钩取 而API代码修改技术则将API代码的前5个字节修改为JMP XXXXXXXXXX指令来钩取API 调用执行被钩取的API时 JMP XXXXXXXXX就会被执行 转而控制hooking函数 后面描述的是 向process explorer进程（procexp.exe）注入stealth.dll文件后钩取ntdll.ZwQuery-SystemInformation（）API的整个过程（ntdll.ZwQuery-SystemInformation（）API是为了隐藏进程而需要钩取的API）</p>
<h3 id="注入之前"><a href="#注入之前" class="headerlink" title="注入之前"></a>注入之前</h3><p>首先看一下钩取之前正常调用API的进程内存。下图描述的是( 钩取之前)正常调用API的情形<br><img src="49.png" alt=""><br>procexp.exe代码调用ntdll.ZwQuerySystemInformation) API时，程序执行流顺序如下。</p>
<p>①procexp.exe的00422CF7地址处的CALL DWORD PTR DS:[48C69C]指令调 用ntdll.ZwQuerySystemInformation( API ( 48C69C地址在进程的IAT区域中，其值为7C93D92E，它是ntdll.ZwQuerySystemInformation() API的起始地址)。</p>
<p>②相应API执行完毕后，返回到调用代码的下一条指令的地址处。</p>
<h3 id="注入之后"><a href="#注入之后" class="headerlink" title="注入之后"></a>注入之后</h3><p>下面看看钩取指定API后程序执行的过程。先把stealth.dll注人目标进程( procexp.exe),直接修改ntdll.ZwQuerySystemInformation( API的代码( Code Patch ),如图所示。<br><img src="50.png" alt=""><br> 首先把stealth.dll注人目标进程，钩取ntll.ZwQuerySystemInformation( API。ntdll.ZwQuery-SystemInformation(O) API起始地址( 7C93D92E)的5个字节代码被修改为JMP 10001120 (仅修改5个字节代码)。10001 120是stealth.MyZwQuerySystemInformation(函数的地址。此时,在procexp.exe代码中调用ntdll.ZwQuerySystemInformation( API,程序将按如下顺序执行</p>
<p>①在422CF7地址处调用ntdll.ZwQuerySystemInformation() API ( 7C93D92E )。</p>
<p>②位于7C93D92E地址处的( 修改后的) JMP 10001 120指令将执行流转到10001120地址处( hooking函数)。10001 16A地址处的CALL unhook()指令用来将ntdll.ZwQuerySystemInformation(API的起始5个字节恢复原值。</p>
<p>③位于1000119B地址处的CALL EAX(7C93D92E)指令将调用原来的函数（ntdll.ZwQuery-SystemlnformationOAPI)(由于前面已经“脱钩”，所以可以正常调用执行）。</p>
<p>④ntdll.ZwQuerySystemlnformation（）执行完毕后，由7C93D93A地址处的RETN 10指令返回到 stealth.dll代码区域（调用自身的位置）。然后10001212地址处的CALL hook()指令再次钩取 ntdll.ZwQuerySystemlnformation（）API(即将开始的5字节修改为JMP10001120指令）</p>
<p>⑤stealth.MyZwQuerySystemInformation(函数执行完毕后，由10001233地址处的RETN 10命令返回到procexp.exe进程的代码区域，继续执行。</p>
<p>上述过程刚开始看似很难，多看几遍，慢慢就会明白的。<br>使用API代码修改技术的好处是可以钩取进程中使用的任意API。前面讲过的IAT钩取技术仅适用于可钩取的API,而API代码修改技术无此限制，(虽然代码会更复杂一些)使用起来要自由得多。使用API代码修改技术的唯- -限制是， 要钩取的API代码长度要大于5个字节，但是由于所有API代码长度都大于5个字节 所以事实上这个限制是不存在的</p>
<h2 id="练习（HideProc-exe，stealth-dll）"><a href="#练习（HideProc-exe，stealth-dll）" class="headerlink" title="练习（HideProc.exe，stealth.dll）"></a>练习（HideProc.exe，stealth.dll）</h2><p>HideProc exe负责将stealth.dll文件注人所有运行中的进程。Stealth.dll负责钩取(注人stealth.dll文件的)进程的ntdll.ZwQuerySystemInformation() API。接下来我们使用上面2个文件隐藏notepad.exe进程。<br><img src="2.png" alt=""></p>
<h3 id="运行notepad-exe-procexp-exe-taskmgr-exe"><a href="#运行notepad-exe-procexp-exe-taskmgr-exe" class="headerlink" title="运行notepad.exe procexp.exe taskmgr.exe"></a>运行notepad.exe procexp.exe taskmgr.exe</h3><p>首先运行要隐藏的进程notepad.exe(要隐藏的进程) procexp.exe（钩取对象1） taskmgr.exe（钩取对象2）</p>
<h3 id="运行HideProc-exe"><a href="#运行HideProc-exe" class="headerlink" title="运行HideProc.exe"></a>运行HideProc.exe</h3><p>运行HideProc.exe 将stealth.dll文件注入当前运行的所有程序：<br><img src="1.png" alt=""><br>简要介绍一下HideProc.exe命令的几个参数:<br>-hide/-show: -hide 用于隐藏，-show 用于取消隐藏。<br>process name:要隐藏的进程名称。<br>dllpath:要注入的DLL文件路径。</p>
<h3 id="查看进程是否隐藏成功"><a href="#查看进程是否隐藏成功" class="headerlink" title="查看进程是否隐藏成功"></a>查看进程是否隐藏成功</h3><p><img src="3.png" alt=""><br>我们发现任务管理器中的进程已经消失了 可是程序依然在运行 这就证明注入成功了</p>
<h3 id="取消进程隐藏"><a href="#取消进程隐藏" class="headerlink" title="取消进程隐藏"></a>取消进程隐藏</h3><p><img src="4.png" alt=""><br>我们可以发现在procexp.exe taskmgr.exe又能看到进程了</p>
<h2 id="源代码分析"><a href="#源代码分析" class="headerlink" title="源代码分析"></a>源代码分析</h2><h3 id="HideProc-cpp"><a href="#HideProc-cpp" class="headerlink" title="HideProc.cpp"></a>HideProc.cpp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">BOOL InjectAllProcess(int nMode, LPCTSTR szDllPath)</span><br><span class="line">&#123;</span><br><span class="line">	DWORD                   dwPID = 0;</span><br><span class="line">	HANDLE                  hSnapShot = INVALID_HANDLE_VALUE;</span><br><span class="line">	PROCESSENTRY32          pe;</span><br><span class="line"> </span><br><span class="line">	// Get the snapshot of the system</span><br><span class="line">	pe.dwSize = sizeof( PROCESSENTRY32 );</span><br><span class="line">	hSnapShot = CreateToolhelp32Snapshot( TH32CS_SNAPALL, NULL );</span><br><span class="line"> </span><br><span class="line">	// find process</span><br><span class="line">	Process32First(hSnapShot, &amp;pe);</span><br><span class="line">	do</span><br><span class="line">	&#123;</span><br><span class="line">		dwPID = pe.th32ProcessID;</span><br><span class="line"> </span><br><span class="line">        // 鉴于系统安全性的考虑</span><br><span class="line">        // 对于PID小于100的系统进程</span><br><span class="line">        // 不执行DLL注入操作</span><br><span class="line">		if( dwPID &lt; 100 )</span><br><span class="line">			continue;</span><br><span class="line"> </span><br><span class="line">        if( nMode == INJECTION_MODE )</span><br><span class="line">		    InjectDll(dwPID, szDllPath);</span><br><span class="line">        else</span><br><span class="line">            EjectDll(dwPID, szDllPath);</span><br><span class="line">	&#125;</span><br><span class="line">	while( Process32Next(hSnapShot, &amp;pe) );</span><br><span class="line"> </span><br><span class="line">	CloseHandle(hSnapShot);</span><br><span class="line"> </span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先通过SetPrivilege函数调用AdjustTokenPrivileges提升权限，然后在InjectAllProcess中使用CreateToolhelp32Snapshot获取系统中运行的所有进程的列表，使用Process32First与Process32Next将获得的进程信息存放到PROCESSENTRY32结构体变量pe中，进而获取进程的PID。获取了进程的PID后，要根据所用的命令选项来选择调用InjectDll函数还是EjectDll函数。当某进程的PID小于100时，鉴于系统安全性的考虑，忽略对它的操作。</p>
<h3 id="Stealth-dll"><a href="#Stealth-dll" class="headerlink" title="Stealth.dll"></a>Stealth.dll</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// global variable (in sharing memory)</span><br><span class="line">#pragma comment(linker, &quot;/SECTION:.SHARE,RWS&quot;)</span><br><span class="line">#pragma data_seg(&quot;.SHARE&quot;)</span><br><span class="line">    TCHAR g_szProcName[MAX_PATH] = &#123;0,&#125;;</span><br><span class="line">#pragma data_seg()</span><br><span class="line"> </span><br><span class="line">// export function</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line">__declspec(dllexport) void SetProcName(LPCTSTR szProcName)</span><br><span class="line">&#123;</span><br><span class="line">    _tcscpy_s(g_szProcName, szProcName);</span><br><span class="line">&#125;</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>首先看导出函数SetProcName。先创建名为.SHARE的共享内存节区，然后创建g_szProcName缓冲区，最后再由导出函数SetProcName将要隐藏的进程名称保存到g_szProcName中。</p>
<h3 id="DllMain"><a href="#DllMain" class="headerlink" title="DllMain()"></a>DllMain()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span><br><span class="line">&#123;</span><br><span class="line">    char            szCurProc[MAX_PATH] = &#123;0,&#125;;</span><br><span class="line">    char            *p = NULL;</span><br><span class="line"> </span><br><span class="line">    // #1. 异常处理</span><br><span class="line">    // 若当前进程为HookProc.exe则终止，不进行钩取操作</span><br><span class="line">    GetModuleFileNameA(NULL, szCurProc, MAX_PATH);</span><br><span class="line">    p = strrchr(szCurProc, &apos;\\&apos;);</span><br><span class="line">    if( (p != NULL) &amp;&amp; !_stricmp(p+1, &quot;HideProc.exe&quot;) )</span><br><span class="line">        return TRUE;</span><br><span class="line"> </span><br><span class="line">    switch( fdwReason )</span><br><span class="line">    &#123;</span><br><span class="line">        // #2. API Hooking</span><br><span class="line">        case DLL_PROCESS_ATTACH : </span><br><span class="line">        hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, </span><br><span class="line">                     (PROC)NewZwQuerySystemInformation, g_pOrgBytes);</span><br><span class="line">        break;</span><br><span class="line"> </span><br><span class="line">        // #3. API Unhooking </span><br><span class="line">        case DLL_PROCESS_DETACH :</span><br><span class="line">        unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, </span><br><span class="line">                       g_pOrgBytes);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先比较字符串，若进程名为HideProc.exe则不钩取API。发生DLL_PROCESS_ATTACH事件时，调用hook_by_code函数钩取API；发生DLL_PROCESS_DETACH事件时，调用unhook_by_code函数取消API钩取。</p>
<h3 id="hook-by-code"><a href="#hook-by-code" class="headerlink" title="hook_by_code()"></a>hook_by_code()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">BOOL hook_by_code(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew, PBYTE pOrgBytes)</span><br><span class="line">&#123;</span><br><span class="line">    FARPROC pfnOrg;</span><br><span class="line">    DWORD dwOldProtect, dwAddress;</span><br><span class="line">    BYTE pBuf[5] = &#123;0xE9, 0, &#125;;</span><br><span class="line">    PBYTE pByte;</span><br><span class="line"> </span><br><span class="line">    // 获取要钩取的API地址</span><br><span class="line">    pfnOrg = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">    pByte = (PBYTE)pfnOrg;</span><br><span class="line"> </span><br><span class="line">    // 若已经被钩取则返回FALSE</span><br><span class="line">    if( pByte[0] == 0xE9 )</span><br><span class="line">        return FALSE;</span><br><span class="line"> </span><br><span class="line">    // 向内存添加写属性</span><br><span class="line">    VirtualProtect((LPVOID)pfnOrg, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"> </span><br><span class="line">    // 备份原有代码(5字节)</span><br><span class="line">    memcpy(pOrgBytes, pfnOrg, 5);</span><br><span class="line"> </span><br><span class="line">    // 计算JMP地址 (E9 XXXX)</span><br><span class="line">    // =&gt; XXXX = pfnNew - pfnOrg - 5</span><br><span class="line">    dwAddress = (DWORD)pfnNew - (DWORD)pfnOrg - 5;</span><br><span class="line">    memcpy(&amp;pBuf[1], &amp;dwAddress, 4);</span><br><span class="line"> </span><br><span class="line">    // Hook:修改5 byte(JMP XXXX)</span><br><span class="line">    memcpy(pfnOrg, pBuf, 5);</span><br><span class="line"> </span><br><span class="line">    // 恢复内存属性</span><br><span class="line">    VirtualProtect((LPVOID)pfnOrg, 5, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">    </span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它通过修改代码实现API钩取操作。JMP指令的实际形式为E9 XXXXXXXX，XXXXXXXX=要跳转的地址-当前指令地址-当前指令长度(5)。</p>
<h3 id="unhook-by-code"><a href="#unhook-by-code" class="headerlink" title="unhook_by_code()"></a>unhook_by_code()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">BOOL unhook_by_code(LPCSTR szDllName, LPCSTR szFuncName, PBYTE pOrgBytes)</span><br><span class="line">&#123;</span><br><span class="line">    FARPROC pFunc;</span><br><span class="line">    DWORD dwOldProtect;</span><br><span class="line">    PBYTE pByte;</span><br><span class="line"> </span><br><span class="line">    // 获取API地址</span><br><span class="line">    pFunc = GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">    pByte = (PBYTE)pFunc;</span><br><span class="line"> </span><br><span class="line">    // 若已经脱钩则返回FALSE</span><br><span class="line">    if( pByte[0] != 0xE9 )</span><br><span class="line">        return FALSE;</span><br><span class="line"> </span><br><span class="line">    // 向内存添加写属性</span><br><span class="line">    VirtualProtect((LPVOID)pFunc, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"> </span><br><span class="line">    // Unhook</span><br><span class="line">    memcpy(pFunc, pOrgBytes, 5);</span><br><span class="line"> </span><br><span class="line">    // 恢复内存属性</span><br><span class="line">    VirtualProtect((LPVOID)pFunc, 5, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"> </span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>unhook_by_code函数是用来取消钩取的函数，原理就是将函数代码开始的前5个字节恢复原值</p>
<h3 id="NewZwQuerySystemInformation（）"><a href="#NewZwQuerySystemInformation（）" class="headerlink" title="NewZwQuerySystemInformation（）"></a>NewZwQuerySystemInformation（）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS WINAPI NewZwQuerySystemInformation(</span><br><span class="line">                SYSTEM_INFORMATION_CLASS SystemInformationClass, </span><br><span class="line">                PVOID SystemInformation, </span><br><span class="line">                ULONG SystemInformationLength, </span><br><span class="line">                PULONG ReturnLength)</span><br><span class="line">&#123;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    FARPROC pFunc;</span><br><span class="line">    PSYSTEM_PROCESS_INFORMATION pCur, pPrev;</span><br><span class="line">    char szProcName[MAX_PATH] = &#123;0,&#125;;</span><br><span class="line">    </span><br><span class="line">    // 开始前先脱钩</span><br><span class="line">    unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, g_pOrgBytes);</span><br><span class="line"> </span><br><span class="line">    // 调用原始API</span><br><span class="line">    pFunc = GetProcAddress(GetModuleHandleA(DEF_NTDLL), </span><br><span class="line">                           DEF_ZWQUERYSYSTEMINFORMATION);</span><br><span class="line">    status = ((PFZWQUERYSYSTEMINFORMATION)pFunc)</span><br><span class="line">              (SystemInformationClass, SystemInformation, </span><br><span class="line">              SystemInformationLength, ReturnLength);</span><br><span class="line"> </span><br><span class="line">    if( status != STATUS_SUCCESS )</span><br><span class="line">        goto __NTQUERYSYSTEMINFORMATION_END;</span><br><span class="line"> </span><br><span class="line">    // 针对SystemProcessInformation类型操作</span><br><span class="line">    if( SystemInformationClass == SystemProcessInformation )</span><br><span class="line">    &#123;</span><br><span class="line">        // SYSTEM_PROCESS_INFORMATION类型转换</span><br><span class="line">        // pCur是单向链表的头</span><br><span class="line">        pCur = (PSYSTEM_PROCESS_INFORMATION)SystemInformation;</span><br><span class="line"> </span><br><span class="line">        while(TRUE)</span><br><span class="line">        &#123;</span><br><span class="line">            // 比较进程名称</span><br><span class="line">            // g_szProcName为要隐藏的进程名称</span><br><span class="line">            // (=&gt; SetProcName()设置)</span><br><span class="line">            if(pCur-&gt;Reserved2[1] != NULL)</span><br><span class="line">            &#123;</span><br><span class="line">                if(!_tcsicmp((PWSTR)pCur-&gt;Reserved2[1], g_szProcName))</span><br><span class="line">                &#123;</span><br><span class="line">                    // 从链表中删除隐藏进程的节点</span><br><span class="line">                    if(pCur-&gt;NextEntryOffset == 0)</span><br><span class="line">                        pPrev-&gt;NextEntryOffset = 0;</span><br><span class="line">                    else</span><br><span class="line">                        pPrev-&gt;NextEntryOffset += pCur-&gt;NextEntryOffset;</span><br><span class="line">                &#125;</span><br><span class="line">                else		</span><br><span class="line">                    pPrev = pCur;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            if(pCur-&gt;NextEntryOffset == 0)</span><br><span class="line">                break;</span><br><span class="line"> </span><br><span class="line">            // 链表的下一项</span><br><span class="line">            pCur = (PSYSTEM_PROCESS_INFORMATION)</span><br><span class="line">                    ((ULONG)pCur + pCur-&gt;NextEntryOffset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">__NTQUERYSYSTEMINFORMATION_END:</span><br><span class="line"> </span><br><span class="line">    // 函数终止前再次执行API钩取操作，为下次调用准备</span><br><span class="line">    hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, </span><br><span class="line">                 (PROC)NewZwQuerySystemInformation, g_pOrgBytes);</span><br><span class="line"> </span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单分析一下 将SystemInformationClass参数设置为SystemProcessInformation（5）后调用ZwQuerySystemInformation（）API，SystemInformation[in/out]参数中储存的是SYSTEM_PROCESS_INFORMATIN结构体单向链表的起始地址 隐藏某进程之前，先要查找与之对应的链表成员，然后断开其与链表的链接。</p>
<h2 id="利用热补丁技术钩取API"><a href="#利用热补丁技术钩取API" class="headerlink" title="利用热补丁技术钩取API"></a>利用热补丁技术钩取API</h2><p>前面demo程序中通过代码修改技术进行API Hook存在的缺点</p>
<p>1.频繁脱钩，挂钩会造成整体性能下降</p>
<p>2.多线程环境，当一个线程尝试运行某段代码，而另一进程刚好在对该代码进行写操作，这时就会发生冲突，会引起非法访问异常（Access Violation）。《windows核心编程》指出，利用代码修改技术钩取API会对系统安全造成威胁</p>
<h3 id="热补丁（修改7Byte代码）"><a href="#热补丁（修改7Byte代码）" class="headerlink" title="热补丁（修改7Byte代码）"></a>热补丁（修改7Byte代码）</h3><p>Windows系统库中的函数，如kernel32.CreateProcessA/W, user32.MessageBoxA，gdi32.TextOutW有一个相似点</p>
<p>1.API以MOV EDI, EDI指令开始(IA-32 0X8bff)<br>2.API上方有5个NOP指令(IA-32 0X90)<br>微软做此设计的目的就是方便打热补丁。</p>
<p>使用热补丁Hook API的过程如下</p>
<p>1.修改API开始的两个字节MOV EDI,EDI为SHORT JMP指令EB F9, 跳转的目标地址是address_of_api - 5，即5个NOP指令的第一条<br>2.修改5个NOP指令为长跳转E9 XXXXXXXX，跳转到用户自定义API<br>3.用户自定义代码调用原始API时，直接以API+2的地址为API地址调用原API，这样就不会引起内存非法访问</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="DllMain（）"><a href="#DllMain（）" class="headerlink" title="DllMain（）"></a>DllMain（）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span><br><span class="line">&#123;</span><br><span class="line">    char            szCurProc[MAX_PATH] = &#123;0,&#125;;</span><br><span class="line">    char            *p = NULL;</span><br><span class="line"></span><br><span class="line">    // 判断进程名称，不向HideProc2.exe注入dll</span><br><span class="line">    GetModuleFileNameA(NULL, szCurProc, MAX_PATH);</span><br><span class="line">    p = strrchr(szCurProc, &apos;\\&apos;);</span><br><span class="line">    if( (p != NULL) &amp;&amp; !_stricmp(p+1, &quot;HideProc2.exe&quot;) )</span><br><span class="line">        return TRUE;</span><br><span class="line"></span><br><span class="line">    // change privilege</span><br><span class="line">    SetPrivilege(SE_DEBUG_NAME, TRUE);</span><br><span class="line"></span><br><span class="line">    switch( fdwReason )</span><br><span class="line">    &#123;</span><br><span class="line">        case DLL_PROCESS_ATTACH : </span><br><span class="line">            // hook</span><br><span class="line">            hook_by_hotpatch(&quot;kernel32.dll&quot;, &quot;CreateProcessA&quot;, </span><br><span class="line">                             (PROC)NewCreateProcessA);</span><br><span class="line">            hook_by_hotpatch(&quot;kernel32.dll&quot;, &quot;CreateProcessW&quot;, </span><br><span class="line">                             (PROC)NewCreateProcessW);</span><br><span class="line">            //可以看到这里没有对ZwQuerySystemInformation使用热补丁Hook，具体原因见&quot;3.热补丁Hook的缺点&quot;</span><br><span class="line">            hook_by_code(&quot;ntdll.dll&quot;, &quot;ZwQuerySystemInformation&quot;, </span><br><span class="line">                         (PROC)NewZwQuerySystemInformation, g_pOrgZwQSI);</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case DLL_PROCESS_DETACH :</span><br><span class="line">            // unhook</span><br><span class="line">            unhook_by_hotpatch(&quot;kernel32.dll&quot;, &quot;CreateProcessA&quot;);</span><br><span class="line">            unhook_by_hotpatch(&quot;kernel32.dll&quot;, &quot;CreateProcessW&quot;);</span><br><span class="line">            unhook_by_code(&quot;ntdll.dll&quot;, &quot;ZwQuerySystemInformation&quot;, </span><br><span class="line">                           g_pOrgZwQSI);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和之前代码一样，在Dll附加进程的时候调用hook方法，在dll卸载时调用unhook方法</p>
<h4 id="hook-by-hotpatch"><a href="#hook-by-hotpatch" class="headerlink" title="hook_by_hotpatch()"></a>hook_by_hotpatch()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">BOOL hook_by_hotpatch(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew)</span><br><span class="line">&#123;</span><br><span class="line">    FARPROC pFunc;</span><br><span class="line">    DWORD dwOldProtect, dwAddress;</span><br><span class="line">    BYTE pBuf[5] = &#123; 0xE9, 0, &#125;;</span><br><span class="line">    BYTE pBuf2[2] = &#123; 0xEB, 0xF9 &#125;;</span><br><span class="line">    PBYTE pByte;</span><br><span class="line"></span><br><span class="line">    pFunc = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">    pByte = (PBYTE)pFunc;</span><br><span class="line">    if( pByte[0] == 0xEB )</span><br><span class="line">        return FALSE;</span><br><span class="line"></span><br><span class="line">    VirtualProtect((LPVOID)((DWORD)pFunc - 5), 7, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    // 1. NOP (0x90)</span><br><span class="line">    dwAddress = (DWORD)pfnNew - (DWORD)pFunc;</span><br><span class="line">    memcpy(&amp;pBuf[1], &amp;dwAddress, 4);</span><br><span class="line">    memcpy((LPVOID)((DWORD)pFunc - 5), pBuf, 5);</span><br><span class="line">    </span><br><span class="line">    // 2. MOV EDI, EDI (0x8BFF)</span><br><span class="line">    memcpy(pFunc, pBuf2, 2);</span><br><span class="line"></span><br><span class="line">    VirtualProtect((LPVOID)((DWORD)pFunc - 5), 7, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改API中无用的7字节数据，跳转到用户自定义Hook函数</p>
<h4 id="unhook-by-hotpatch"><a href="#unhook-by-hotpatch" class="headerlink" title="unhook_by_hotpatch"></a>unhook_by_hotpatch</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">BOOL unhook_by_hotpatch(LPCSTR szDllName, LPCSTR szFuncName)</span><br><span class="line">&#123;</span><br><span class="line">    FARPROC pFunc;</span><br><span class="line">    DWORD dwOldProtect;</span><br><span class="line">    PBYTE pByte;</span><br><span class="line">    BYTE pBuf[5] = &#123; 0x90, 0x90, 0x90, 0x90, 0x90 &#125;;</span><br><span class="line">    BYTE pBuf2[2] = &#123; 0x8B, 0xFF &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pFunc = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">    pByte = (PBYTE)pFunc;</span><br><span class="line">    if( pByte[0] != 0xEB )</span><br><span class="line">        return FALSE;</span><br><span class="line"></span><br><span class="line">    VirtualProtect((LPVOID)pFunc, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    // 1. NOP (0x90)</span><br><span class="line">    memcpy((LPVOID)((DWORD)pFunc - 5), pBuf, 5);</span><br><span class="line">    </span><br><span class="line">    // 2. MOV EDI, EDI (0x8BFF)</span><br><span class="line">    memcpy(pFunc, pBuf2, 2);</span><br><span class="line"></span><br><span class="line">    VirtualProtect((LPVOID)pFunc, 5, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将7字节数据修改为原数据</p>
<h4 id="NewCreateProcess"><a href="#NewCreateProcess" class="headerlink" title="NewCreateProcess"></a>NewCreateProcess</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI NewCreateProcessA(</span><br><span class="line">    LPCTSTR lpApplicationName,</span><br><span class="line">    LPTSTR lpCommandLine,</span><br><span class="line">    LPSECURITY_ATTRIBUTES lpProcessAttributes,</span><br><span class="line">    LPSECURITY_ATTRIBUTES lpThreadAttributes,</span><br><span class="line">    BOOL bInheritHandles,</span><br><span class="line">    DWORD dwCreationFlags,</span><br><span class="line">    LPVOID lpEnvironment,</span><br><span class="line">    LPCTSTR lpCurrentDirectory,</span><br><span class="line">    LPSTARTUPINFO lpStartupInfo,</span><br><span class="line">    LPPROCESS_INFORMATION lpProcessInformation</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    BOOL bRet;</span><br><span class="line">    FARPROC pFunc;</span><br><span class="line"></span><br><span class="line">    pFunc = GetProcAddress(GetModuleHandleA(&quot;kernel32.dll&quot;), &quot;CreateProcessA&quot;);</span><br><span class="line">    //以API地址+2为函数地址调用CreateProcessA函数</span><br><span class="line">    pFunc = (FARPROC)((DWORD)pFunc + 2);</span><br><span class="line">    bRet = ((PFCREATEPROCESSA)pFunc)(lpApplicationName,</span><br><span class="line">                                     lpCommandLine,</span><br><span class="line">                                     lpProcessAttributes,</span><br><span class="line">                                     lpThreadAttributes,</span><br><span class="line">                                     bInheritHandles,</span><br><span class="line">                                     dwCreationFlags,</span><br><span class="line">                                     lpEnvironment,</span><br><span class="line">                                     lpCurrentDirectory,</span><br><span class="line">                                     lpStartupInfo,</span><br><span class="line">                                     lpProcessInformation);</span><br><span class="line"></span><br><span class="line">    // 注入steach3.dll</span><br><span class="line">    if( bRet )</span><br><span class="line">        InjectDll2(lpProcessInformation-&gt;hProcess, STR_MODULE_NAME);</span><br><span class="line"></span><br><span class="line">    return bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意一点，在使用之前的hook方法进行API钩取时，在用户自定义NewCreateProcess函数开头需要调用unhook方法(防止进入钩取的死循环)，函数结尾需要调用hook方法进行重新钩取。</p>
<p>但是使用热补丁Hook时不需要这样反复脱钩，挂钩，只需在调用原始API时，使用address of API + 2的地址调用API即可</p>
<h3 id="使用热补丁进行Hook的缺点"><a href="#使用热补丁进行Hook的缺点" class="headerlink" title="使用热补丁进行Hook的缺点"></a>使用热补丁进行Hook的缺点</h3><p>热补丁钩取技术有个明显的缺点，即不符合钩取条件（7字节无用代码）的API无法使用热补丁钩取</p>
<p>这样的API有，ntdll.dll提供的API 和kernel32.GetStartInfoA() 等</p>
<p>并非所有API都能使用热补丁钩取，所以使用前需要先确认要钩取的API是否支持，若不支持则需使用前面的5字节代码修改技术</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">loser</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">loser</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
