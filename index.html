<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="chinese">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="loser的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="loser的博客">
<meta property="og:locale" content="chinese">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="loser的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>loser的博客</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="chinese">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">loser的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/15/OD学习5-18/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/15/OD学习5-18/" itemprop="url">OD学习5-18</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-15T17:16:31+08:00">
                2019-05-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="计算器显示成文字"><a href="#计算器显示成文字" class="headerlink" title="计算器显示成文字"></a>计算器显示成文字</h1><h2 id="OD法更改"><a href="#OD法更改" class="headerlink" title="OD法更改"></a>OD法更改</h2><p>首先利用OD修改内存中的值来实现计算器显示中文数字（这次还是在XP虚拟机里运行的）</p>
<p>用OD打开calc.exe 快捷键ctrl+N查看目标文件的API函数 </p>
<p><img src="22.png" alt=""><br>这里我们发现的两个值得关注的API函数 SetWinsowTextW（）和SetDlgItemTextW（） 他们负责向计算器的文本显示框中显示文本 来看看SetWinsowTextW（）API定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOLSetWindowText(</span><br><span class="line">HWNDhwnd,</span><br><span class="line">LPCTSTRlpString</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>hWnd</strong><br>要改变文本内容的窗口或控件的句柄。不能改变在其他应用程序中的控件的文本内容，如果需要可以用另外一个SendMessage函数发送一条WM_SETTEXT消息。</p>
<p><strong>lpString</strong><br>指向一个空结束的字符串的指针，该字符串将作为窗口或控件的新文本。</p>
<p>这里我们关注第二个参考——字符串指针（lpString）钩取时查看字符串（lpString）中的内容 将其中的阿拉伯数字改成中文就行</p>
<p>然后在刚才关注的那两个API函数上设置断点<br><img src="23.png" alt=""><br>运行<br><img src="24.png" alt=""><br>第一次运行断在了SetwindowTextW这里 右下角堆栈窗口发现字符0就是计算器开始的在字符0<br><img src="25.png" alt=""><br>在运行断在了SetDlgItemTextW（）处 再次运行一下 计算器的页面出现了 为了继续调试 我们望计算器中输入7 发现OD自动在SetwindowTextW这里停了</p>
<p><img src="26.png" alt=""><br>看到了刚才说的那两个参数 在数据窗口跟随TEXT那一项发现了储存的数字7<br><img src="27.png" alt=""><br>将中文数字 七 的Unicode码（4e03）覆写到地址处 这里记得要逆序（034e）写入<br><img src="28.png" alt=""><br>发现数字7已经变成汉字七了！<br><img src="29.png" alt=""><br>运行程序在计算器中看到已经变了：<br><img src="30.png" alt=""><br>这里就算完成了OD的过程 对SetWinsowTextW（）API验证结束 接下来看看IAT钩取操作及其实现原理 </p>
<h2 id="IAT钩取工作原理"><a href="#IAT钩取工作原理" class="headerlink" title="IAT钩取工作原理"></a>IAT钩取工作原理</h2><p>IAT钩取通过修改IAT中保存的API地址来钩取某个API 如图：</p>
<h2 id="练习示例"><a href="#练习示例" class="headerlink" title="练习示例"></a>练习示例</h2><p>先复制文件到工作目录（c:work）然后运行calc.exe程序 再打开任务管理器查看其PID 如图：<br><img src="31.png" alt=""><br>然后在命令窗口执行如图命令：<br><img src="32.png" alt=""><br>接下来在计算器随便输入一些数值 如图：<br><img src="33.png" alt=""><br>我们可以看到 输入的数值已经变成了中文 计算器也在正常运行（其实我自己调试的这个InjectDLL.exe注入的hookiat.dll注入之后计算器显示的是韩文 可能是韩国人整的DLL文件吧 但确实是钩取成功了！！）</p>
<h2 id="源代码分析（hookiat-dll）"><a href="#源代码分析（hookiat-dll）" class="headerlink" title="源代码分析（hookiat.dll）"></a>源代码分析（hookiat.dll）</h2><h3 id="Dllmain（）"><a href="#Dllmain（）" class="headerlink" title="Dllmain（）"></a>Dllmain（）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span><br><span class="line">&#123;</span><br><span class="line">	switch( fdwReason )</span><br><span class="line">	&#123;</span><br><span class="line">		case DLL_PROCESS_ATTACH : </span><br><span class="line">            // 保存原始API的地址</span><br><span class="line">           	g_pOrgFunc = GetProcAddress(GetModuleHandle(L&quot;user32.dll&quot;), </span><br><span class="line">                                        &quot;SetWindowTextW&quot;);</span><br><span class="line"> </span><br><span class="line">            // # hook</span><br><span class="line">            //   用hookiat.MySetWindowText钩取user32.SetWindowTextW</span><br><span class="line">			hook_iat(&quot;user32.dll&quot;, g_pOrgFunc, (PROC)MySetWindowTextW);</span><br><span class="line">			break;</span><br><span class="line"> </span><br><span class="line">		case DLL_PROCESS_DETACH :</span><br><span class="line">            // # unhook</span><br><span class="line">            //   将calc.exe的IAT恢复原值</span><br><span class="line">            hook_iat(&quot;user32.dll&quot;, (PROC)MySetWindowTextW, g_pOrgFunc);</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在DLL_PROCESS_ATTACH事件中先获取user32.SetWindowTextW的地址，然后保存到全局变量g_pOrgFunc中，后面脱钩会用到这个地址。</p>
<h3 id="MySetWindowTextW"><a href="#MySetWindowTextW" class="headerlink" title="MySetWindowTextW()"></a>MySetWindowTextW()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI MySetWindowTextW(HWND hWnd, LPWSTR lpString)</span><br><span class="line">&#123;</span><br><span class="line">    wchar_t* pNum = L&quot;零一二三四五六七八九&quot;;</span><br><span class="line">    wchar_t temp[2] = &#123;0,&#125;;</span><br><span class="line">    int i = 0, nLen = 0, nIndex = 0;</span><br><span class="line"> </span><br><span class="line">    nLen = wcslen(lpString);</span><br><span class="line">    for(i = 0; i &lt; nLen; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //   将阿拉伯数字转换为中文数字</span><br><span class="line">        //   lpString是宽字符版本(2个字节)字符串</span><br><span class="line">        if( L&apos;0&apos; &lt;= lpString[i] &amp;&amp; lpString[i] &lt;= L&apos;9&apos; )</span><br><span class="line">        &#123;</span><br><span class="line">            temp[0] = lpString[i];</span><br><span class="line">            nIndex = _wtoi(temp);</span><br><span class="line">            lpString[i] = pNum[nIndex];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //   调用user32.SetWindowTextW</span><br><span class="line">    //   (修改lpString缓冲区中的内容)</span><br><span class="line">    return ((PFSETWINDOWTEXTW)g_pOrgFunc)(hWnd, lpString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lpString参数是一块缓冲区，该缓冲区用来存放要输出显示的字符串。for循环将存放在lpString的阿拉伯数字字符串转换为中文数字字符串。for循环结束后，最后再调用函数指针g_pOrgFunc。</p>
<p>hook_iat()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">BOOL hook_iat(LPCSTR szDllName, PROC pfnOrg, PROC pfnNew)</span><br><span class="line">&#123;</span><br><span class="line">	HMODULE hMod;</span><br><span class="line">	LPCSTR szLibName;</span><br><span class="line">	PIMAGE_IMPORT_DESCRIPTOR pImportDesc; </span><br><span class="line">	PIMAGE_THUNK_DATA pThunk;</span><br><span class="line">	DWORD dwOldProtect, dwRVA;</span><br><span class="line">	PBYTE pAddr;</span><br><span class="line"> </span><br><span class="line">    // hMod, pAddr = ImageBase of calc.exe</span><br><span class="line">    //             = VA to MZ signature (IMAGE_DOS_HEADER)</span><br><span class="line">	hMod = GetModuleHandle(NULL);</span><br><span class="line">	pAddr = (PBYTE)hMod;</span><br><span class="line"> </span><br><span class="line">    // pAddr = VA to PE signature (IMAGE_NT_HEADERS)</span><br><span class="line">	pAddr += *((DWORD*)&amp;pAddr[0x3C]);</span><br><span class="line"> </span><br><span class="line">    // dwRVA = RVA to IMAGE_IMPORT_DESCRIPTOR Table</span><br><span class="line">	dwRVA = *((DWORD*)&amp;pAddr[0x80]);</span><br><span class="line"> </span><br><span class="line">    // pImportDesc = VA to IMAGE_IMPORT_DESCRIPTOR Table</span><br><span class="line">	pImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)hMod+dwRVA);</span><br><span class="line"> </span><br><span class="line">	for( ; pImportDesc-&gt;Name; pImportDesc++ )</span><br><span class="line">	&#123;</span><br><span class="line">        // szLibName = VA to IMAGE_IMPORT_DESCRIPTOR.Name</span><br><span class="line">		szLibName = (LPCSTR)((DWORD)hMod + pImportDesc-&gt;Name);</span><br><span class="line">		if( !_stricmp(szLibName, szDllName) )</span><br><span class="line">		&#123;</span><br><span class="line">            // pThunk = IMAGE_IMPORT_DESCRIPTOR.FirstThunk</span><br><span class="line">            //        = VA to IAT(Import Address Table)</span><br><span class="line">			pThunk = (PIMAGE_THUNK_DATA)((DWORD)hMod + </span><br><span class="line">                                         pImportDesc-&gt;FirstThunk);</span><br><span class="line"> </span><br><span class="line">            // pThunk-&gt;u1.Function = VA to API</span><br><span class="line">			for( ; pThunk-&gt;u1.Function; pThunk++ )</span><br><span class="line">			&#123;</span><br><span class="line">				if( pThunk-&gt;u1.Function == (DWORD)pfnOrg )</span><br><span class="line">				&#123;</span><br><span class="line">                </span><br><span class="line">					VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, </span><br><span class="line">                                   4, </span><br><span class="line">                                   PAGE_EXECUTE_READWRITE, </span><br><span class="line">                                   &amp;dwOldProtect);</span><br><span class="line"> </span><br><span class="line">                    pThunk-&gt;u1.Function = (DWORD)pfnNew;</span><br><span class="line">				</span><br><span class="line">                    VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, </span><br><span class="line">                                   4, </span><br><span class="line">                                   dwOldProtect, </span><br><span class="line">                                   &amp;dwOldProtect);						</span><br><span class="line"> </span><br><span class="line">					return TRUE;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	return FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数主要负责钩取API</p>
<p>首先从ImageBase开始经由PE签名找到IDT<br><img src="34.png" alt=""><br><img src="35.png" alt=""><br><img src="36.png" alt=""><br>pImportDesc变量中存储着IMAGE_IMPORT_DESCRIPTOR结构体的起始地址，后者是calc.exe进程IDT的第一个结构体。IDT是由IMAGE_IMPORT_DESCRIPTOR结构体组成的数组。若想查找到IAT，先要查找到这个位置。使用PEView查看该地址(00012B80+01000000=01012B80)，如图所示。</p>
<p><img src="37.png" alt=""><br>在for循环中通过比较查找到user32.dll的IMAGE_IMPORT_DESCRIPTOR结构体地址，从上图可以看出最终pImportDesc的值为01012BF4。接下来进入user32的IAT，pImportDesc-&gt;FirstThunk成员所指的就是IAT。使用PEView查看该地址(000010A4+01000000=010010A4)，如图所示</p>
<p><img src="38.png" alt=""><br>接下来又在for循环中查找SetWindowTextW的IAT地址(01001110)，然后修改它的值。因为计算器进程的IAT内存区域是只读的，所以需要使用VirtualProtect在钩取之前将相应的区域改为可读写的，钩取之后再改回来。</p>
<h1 id="调试被注入的DLL文件"><a href="#调试被注入的DLL文件" class="headerlink" title="调试被注入的DLL文件"></a>调试被注入的DLL文件</h1><p>首先运行calc程序 查看其PID的值<br><img src="39.png" alt=""><br>将程序进程附加到OD中 然后在事件中选定中断于新DLL进程 然后将hookiat.dll注入计算器进程<br><img src="41.png" alt=""><br>运行程序发现：<br><img src="40.png" alt=""><br>双击进入hookiat.dll中 接下来取消刚才事件中的中断于新DLL的选项 然后在hookiat模块查找参考字符串寻找DllMain（）代码 当然也可以F7单步跟踪查找 DllMain()函数中使用的字符串有“user32.dll”和“SetWindowTextW”</p>
<p><img src="42.png" alt=""><br>我们发现“user32.dll”有两处“SetWindowTextW”有一处 转到“SetWindowTextW”处：</p>
<p><img src="43.png" alt=""><br>框出来的内容就是DllMain（）函数了</p>
<p>这就是调试注入进程Dll的方法了</p>
<h2 id="Dllmain（）-1"><a href="#Dllmain（）-1" class="headerlink" title="Dllmain（）"></a>Dllmain（）</h2><p><img src="44.png" alt=""><br>这个call语句就是调用hook_iat()<br>步入刚才那个call语句进入hook_iat()</p>
<h2 id="hook-iat"><a href="#hook-iat" class="headerlink" title="hook_iat()"></a>hook_iat()</h2><h3 id="查找IMAGE-IMPORT-DESCRIPTION-Table"><a href="#查找IMAGE-IMPORT-DESCRIPTION-Table" class="headerlink" title="查找IMAGE_IMPORT_DESCRIPTION Table"></a>查找IMAGE_IMPORT_DESCRIPTION Table</h3><p>hook_iat()是负责具体实施IAT钩取的核心函数 下面是调试一下：<br><img src="45.png" alt=""><br>框起来的部分就是IMAGE_IMPORT_DESCRIPTION Table（下面简称“IID Table”）的过程 一时难分代码仅仅用了4行代码就找到了ID Table</p>
<p><img src="46.png" alt=""><br>这个call指令用于调用stricmp（）函数。</p>
<h3 id="在IAT中查找SetWindowTextW-API位置"><a href="#在IAT中查找SetWindowTextW-API位置" class="headerlink" title="在IAT中查找SetWindowTextW API位置"></a>在IAT中查找SetWindowTextW API位置</h3><p>通过便利IID Table比较IID.Name于“user32.dll”字符串 查找到user32.dll的IID  找到之后 下面代码用来查找SetWindowTextW API位置 然后修改其中内容 从而实现对API的钩取</p>
<p><img src="47.png" alt=""><br>cmp语句中ESI的值为user32.dll的IAT起始地址 EBP的值为SetWindowTextW的地址 代码循环进入IAT SetWindowTextW的地址值（ebp的值）</p>
<h3 id="IAT钩取"><a href="#IAT钩取" class="headerlink" title="IAT钩取"></a>IAT钩取</h3><p>IAT钩取代码<br><img src="48.png" alt=""><br>MOV指令用来将MySetWindowTextW的地址覆写到前面从IAT中获取的SetWindowTextW的地址 执行后就变成了执行MySetWindowTextW地址的代码 也就是将数字变成汉字的代码段</p>
<h1 id="隐藏进程"><a href="#隐藏进程" class="headerlink" title="隐藏进程"></a>隐藏进程</h1><h2 id="API代码修改技术的原理"><a href="#API代码修改技术的原理" class="headerlink" title="API代码修改技术的原理"></a>API代码修改技术的原理</h2><p>IAT钩取通过操作进程的特定IAT值来实现API钩取 而API代码修改技术则将API代码的前5个字节修改为JMP XXXXXXXXXX指令来钩取API 调用执行被钩取的API时 JMP XXXXXXXXX就会被执行 转而控制hooking函数 后面描述的是 向process explorer进程（procexp.exe）注入stealth.dll文件后钩取ntdll.ZwQuery-SystemInformation（）API的整个过程（ntdll.ZwQuery-SystemInformation（）API是为了隐藏进程而需要钩取的API）</p>
<h3 id="注入之前"><a href="#注入之前" class="headerlink" title="注入之前"></a>注入之前</h3><p>首先看一下钩取之前正常调用API的进程内存。下图描述的是( 钩取之前)正常调用API的情形<br><img src="49.png" alt=""><br>procexp.exe代码调用ntdll.ZwQuerySystemInformation) API时，程序执行流顺序如下。</p>
<p>①procexp.exe的00422CF7地址处的CALL DWORD PTR DS:[48C69C]指令调 用ntdll.ZwQuerySystemInformation( API ( 48C69C地址在进程的IAT区域中，其值为7C93D92E，它是ntdll.ZwQuerySystemInformation() API的起始地址)。</p>
<p>②相应API执行完毕后，返回到调用代码的下一条指令的地址处。</p>
<h3 id="注入之后"><a href="#注入之后" class="headerlink" title="注入之后"></a>注入之后</h3><p>下面看看钩取指定API后程序执行的过程。先把stealth.dll注人目标进程( procexp.exe),直接修改ntdll.ZwQuerySystemInformation( API的代码( Code Patch ),如图所示。<br><img src="50.png" alt=""><br> 首先把stealth.dll注人目标进程，钩取ntll.ZwQuerySystemInformation( API。ntdll.ZwQuery-SystemInformation(O) API起始地址( 7C93D92E)的5个字节代码被修改为JMP 10001120 (仅修改5个字节代码)。10001 120是stealth.MyZwQuerySystemInformation(函数的地址。此时,在procexp.exe代码中调用ntdll.ZwQuerySystemInformation( API,程序将按如下顺序执行</p>
<p>①在422CF7地址处调用ntdll.ZwQuerySystemInformation() API ( 7C93D92E )。</p>
<p>②位于7C93D92E地址处的( 修改后的) JMP 10001 120指令将执行流转到10001120地址处( hooking函数)。10001 16A地址处的CALL unhook()指令用来将ntdll.ZwQuerySystemInformation(API的起始5个字节恢复原值。</p>
<p>③位于1000119B地址处的CALL EAX(7C93D92E)指令将调用原来的函数（ntdll.ZwQuery-SystemlnformationOAPI)(由于前面已经“脱钩”，所以可以正常调用执行）。</p>
<p>④ntdll.ZwQuerySystemlnformation（）执行完毕后，由7C93D93A地址处的RETN 10指令返回到 stealth.dll代码区域（调用自身的位置）。然后10001212地址处的CALL hook()指令再次钩取 ntdll.ZwQuerySystemlnformation（）API(即将开始的5字节修改为JMP10001120指令）</p>
<p>⑤stealth.MyZwQuerySystemInformation(函数执行完毕后，由10001233地址处的RETN 10命令返回到procexp.exe进程的代码区域，继续执行。</p>
<p>上述过程刚开始看似很难，多看几遍，慢慢就会明白的。<br>使用API代码修改技术的好处是可以钩取进程中使用的任意API。前面讲过的IAT钩取技术仅适用于可钩取的API,而API代码修改技术无此限制，(虽然代码会更复杂一些)使用起来要自由得多。使用API代码修改技术的唯- -限制是， 要钩取的API代码长度要大于5个字节，但是由于所有API代码长度都大于5个字节 所以事实上这个限制是不存在的</p>
<h2 id="练习（HideProc-exe，stealth-dll）"><a href="#练习（HideProc-exe，stealth-dll）" class="headerlink" title="练习（HideProc.exe，stealth.dll）"></a>练习（HideProc.exe，stealth.dll）</h2><p>HideProc exe负责将stealth.dll文件注人所有运行中的进程。Stealth.dll负责钩取(注人stealth.dll文件的)进程的ntdll.ZwQuerySystemInformation() API。接下来我们使用上面2个文件隐藏notepad.exe进程。<br><img src="2.png" alt=""></p>
<h3 id="运行notepad-exe-procexp-exe-taskmgr-exe"><a href="#运行notepad-exe-procexp-exe-taskmgr-exe" class="headerlink" title="运行notepad.exe procexp.exe taskmgr.exe"></a>运行notepad.exe procexp.exe taskmgr.exe</h3><p>首先运行要隐藏的进程notepad.exe(要隐藏的进程) procexp.exe（钩取对象1） taskmgr.exe（钩取对象2）</p>
<h3 id="运行HideProc-exe"><a href="#运行HideProc-exe" class="headerlink" title="运行HideProc.exe"></a>运行HideProc.exe</h3><p>运行HideProc.exe 将stealth.dll文件注入当前运行的所有程序：<br><img src="1.png" alt=""><br>简要介绍一下HideProc.exe命令的几个参数:<br>-hide/-show: -hide 用于隐藏，-show 用于取消隐藏。<br>process name:要隐藏的进程名称。<br>dllpath:要注入的DLL文件路径。</p>
<h3 id="查看进程是否隐藏成功"><a href="#查看进程是否隐藏成功" class="headerlink" title="查看进程是否隐藏成功"></a>查看进程是否隐藏成功</h3><p><img src="3.png" alt=""><br>我们发现任务管理器中的进程已经消失了 可是程序依然在运行 这就证明注入成功了</p>
<h3 id="取消进程隐藏"><a href="#取消进程隐藏" class="headerlink" title="取消进程隐藏"></a>取消进程隐藏</h3><p><img src="4.png" alt=""><br>我们可以发现在procexp.exe taskmgr.exe又能看到进程了</p>
<h2 id="源代码分析"><a href="#源代码分析" class="headerlink" title="源代码分析"></a>源代码分析</h2><h3 id="HideProc-cpp"><a href="#HideProc-cpp" class="headerlink" title="HideProc.cpp"></a>HideProc.cpp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">BOOL InjectAllProcess(int nMode, LPCTSTR szDllPath)</span><br><span class="line">&#123;</span><br><span class="line">	DWORD                   dwPID = 0;</span><br><span class="line">	HANDLE                  hSnapShot = INVALID_HANDLE_VALUE;</span><br><span class="line">	PROCESSENTRY32          pe;</span><br><span class="line"> </span><br><span class="line">	// Get the snapshot of the system</span><br><span class="line">	pe.dwSize = sizeof( PROCESSENTRY32 );</span><br><span class="line">	hSnapShot = CreateToolhelp32Snapshot( TH32CS_SNAPALL, NULL );</span><br><span class="line"> </span><br><span class="line">	// find process</span><br><span class="line">	Process32First(hSnapShot, &amp;pe);</span><br><span class="line">	do</span><br><span class="line">	&#123;</span><br><span class="line">		dwPID = pe.th32ProcessID;</span><br><span class="line"> </span><br><span class="line">        // 鉴于系统安全性的考虑</span><br><span class="line">        // 对于PID小于100的系统进程</span><br><span class="line">        // 不执行DLL注入操作</span><br><span class="line">		if( dwPID &lt; 100 )</span><br><span class="line">			continue;</span><br><span class="line"> </span><br><span class="line">        if( nMode == INJECTION_MODE )</span><br><span class="line">		    InjectDll(dwPID, szDllPath);</span><br><span class="line">        else</span><br><span class="line">            EjectDll(dwPID, szDllPath);</span><br><span class="line">	&#125;</span><br><span class="line">	while( Process32Next(hSnapShot, &amp;pe) );</span><br><span class="line"> </span><br><span class="line">	CloseHandle(hSnapShot);</span><br><span class="line"> </span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先通过SetPrivilege函数调用AdjustTokenPrivileges提升权限，然后在InjectAllProcess中使用CreateToolhelp32Snapshot获取系统中运行的所有进程的列表，使用Process32First与Process32Next将获得的进程信息存放到PROCESSENTRY32结构体变量pe中，进而获取进程的PID。获取了进程的PID后，要根据所用的命令选项来选择调用InjectDll函数还是EjectDll函数。当某进程的PID小于100时，鉴于系统安全性的考虑，忽略对它的操作。</p>
<h3 id="Stealth-dll"><a href="#Stealth-dll" class="headerlink" title="Stealth.dll"></a>Stealth.dll</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// global variable (in sharing memory)</span><br><span class="line">#pragma comment(linker, &quot;/SECTION:.SHARE,RWS&quot;)</span><br><span class="line">#pragma data_seg(&quot;.SHARE&quot;)</span><br><span class="line">    TCHAR g_szProcName[MAX_PATH] = &#123;0,&#125;;</span><br><span class="line">#pragma data_seg()</span><br><span class="line"> </span><br><span class="line">// export function</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line">__declspec(dllexport) void SetProcName(LPCTSTR szProcName)</span><br><span class="line">&#123;</span><br><span class="line">    _tcscpy_s(g_szProcName, szProcName);</span><br><span class="line">&#125;</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>首先看导出函数SetProcName。先创建名为.SHARE的共享内存节区，然后创建g_szProcName缓冲区，最后再由导出函数SetProcName将要隐藏的进程名称保存到g_szProcName中。</p>
<h3 id="DllMain"><a href="#DllMain" class="headerlink" title="DllMain()"></a>DllMain()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span><br><span class="line">&#123;</span><br><span class="line">    char            szCurProc[MAX_PATH] = &#123;0,&#125;;</span><br><span class="line">    char            *p = NULL;</span><br><span class="line"> </span><br><span class="line">    // #1. 异常处理</span><br><span class="line">    // 若当前进程为HookProc.exe则终止，不进行钩取操作</span><br><span class="line">    GetModuleFileNameA(NULL, szCurProc, MAX_PATH);</span><br><span class="line">    p = strrchr(szCurProc, &apos;\\&apos;);</span><br><span class="line">    if( (p != NULL) &amp;&amp; !_stricmp(p+1, &quot;HideProc.exe&quot;) )</span><br><span class="line">        return TRUE;</span><br><span class="line"> </span><br><span class="line">    switch( fdwReason )</span><br><span class="line">    &#123;</span><br><span class="line">        // #2. API Hooking</span><br><span class="line">        case DLL_PROCESS_ATTACH : </span><br><span class="line">        hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, </span><br><span class="line">                     (PROC)NewZwQuerySystemInformation, g_pOrgBytes);</span><br><span class="line">        break;</span><br><span class="line"> </span><br><span class="line">        // #3. API Unhooking </span><br><span class="line">        case DLL_PROCESS_DETACH :</span><br><span class="line">        unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, </span><br><span class="line">                       g_pOrgBytes);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先比较字符串，若进程名为HideProc.exe则不钩取API。发生DLL_PROCESS_ATTACH事件时，调用hook_by_code函数钩取API；发生DLL_PROCESS_DETACH事件时，调用unhook_by_code函数取消API钩取。</p>
<h3 id="hook-by-code"><a href="#hook-by-code" class="headerlink" title="hook_by_code()"></a>hook_by_code()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">BOOL hook_by_code(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew, PBYTE pOrgBytes)</span><br><span class="line">&#123;</span><br><span class="line">    FARPROC pfnOrg;</span><br><span class="line">    DWORD dwOldProtect, dwAddress;</span><br><span class="line">    BYTE pBuf[5] = &#123;0xE9, 0, &#125;;</span><br><span class="line">    PBYTE pByte;</span><br><span class="line"> </span><br><span class="line">    // 获取要钩取的API地址</span><br><span class="line">    pfnOrg = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">    pByte = (PBYTE)pfnOrg;</span><br><span class="line"> </span><br><span class="line">    // 若已经被钩取则返回FALSE</span><br><span class="line">    if( pByte[0] == 0xE9 )</span><br><span class="line">        return FALSE;</span><br><span class="line"> </span><br><span class="line">    // 向内存添加写属性</span><br><span class="line">    VirtualProtect((LPVOID)pfnOrg, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"> </span><br><span class="line">    // 备份原有代码(5字节)</span><br><span class="line">    memcpy(pOrgBytes, pfnOrg, 5);</span><br><span class="line"> </span><br><span class="line">    // 计算JMP地址 (E9 XXXX)</span><br><span class="line">    // =&gt; XXXX = pfnNew - pfnOrg - 5</span><br><span class="line">    dwAddress = (DWORD)pfnNew - (DWORD)pfnOrg - 5;</span><br><span class="line">    memcpy(&amp;pBuf[1], &amp;dwAddress, 4);</span><br><span class="line"> </span><br><span class="line">    // Hook:修改5 byte(JMP XXXX)</span><br><span class="line">    memcpy(pfnOrg, pBuf, 5);</span><br><span class="line"> </span><br><span class="line">    // 恢复内存属性</span><br><span class="line">    VirtualProtect((LPVOID)pfnOrg, 5, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">    </span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它通过修改代码实现API钩取操作。JMP指令的实际形式为E9 XXXXXXXX，XXXXXXXX=要跳转的地址-当前指令地址-当前指令长度(5)。</p>
<h3 id="unhook-by-code"><a href="#unhook-by-code" class="headerlink" title="unhook_by_code()"></a>unhook_by_code()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">BOOL unhook_by_code(LPCSTR szDllName, LPCSTR szFuncName, PBYTE pOrgBytes)</span><br><span class="line">&#123;</span><br><span class="line">    FARPROC pFunc;</span><br><span class="line">    DWORD dwOldProtect;</span><br><span class="line">    PBYTE pByte;</span><br><span class="line"> </span><br><span class="line">    // 获取API地址</span><br><span class="line">    pFunc = GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">    pByte = (PBYTE)pFunc;</span><br><span class="line"> </span><br><span class="line">    // 若已经脱钩则返回FALSE</span><br><span class="line">    if( pByte[0] != 0xE9 )</span><br><span class="line">        return FALSE;</span><br><span class="line"> </span><br><span class="line">    // 向内存添加写属性</span><br><span class="line">    VirtualProtect((LPVOID)pFunc, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"> </span><br><span class="line">    // Unhook</span><br><span class="line">    memcpy(pFunc, pOrgBytes, 5);</span><br><span class="line"> </span><br><span class="line">    // 恢复内存属性</span><br><span class="line">    VirtualProtect((LPVOID)pFunc, 5, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"> </span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>unhook_by_code函数是用来取消钩取的函数，原理就是将函数代码开始的前5个字节恢复原值</p>
<h3 id="NewZwQuerySystemInformation（）"><a href="#NewZwQuerySystemInformation（）" class="headerlink" title="NewZwQuerySystemInformation（）"></a>NewZwQuerySystemInformation（）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS WINAPI NewZwQuerySystemInformation(</span><br><span class="line">                SYSTEM_INFORMATION_CLASS SystemInformationClass, </span><br><span class="line">                PVOID SystemInformation, </span><br><span class="line">                ULONG SystemInformationLength, </span><br><span class="line">                PULONG ReturnLength)</span><br><span class="line">&#123;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    FARPROC pFunc;</span><br><span class="line">    PSYSTEM_PROCESS_INFORMATION pCur, pPrev;</span><br><span class="line">    char szProcName[MAX_PATH] = &#123;0,&#125;;</span><br><span class="line">    </span><br><span class="line">    // 开始前先脱钩</span><br><span class="line">    unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, g_pOrgBytes);</span><br><span class="line"> </span><br><span class="line">    // 调用原始API</span><br><span class="line">    pFunc = GetProcAddress(GetModuleHandleA(DEF_NTDLL), </span><br><span class="line">                           DEF_ZWQUERYSYSTEMINFORMATION);</span><br><span class="line">    status = ((PFZWQUERYSYSTEMINFORMATION)pFunc)</span><br><span class="line">              (SystemInformationClass, SystemInformation, </span><br><span class="line">              SystemInformationLength, ReturnLength);</span><br><span class="line"> </span><br><span class="line">    if( status != STATUS_SUCCESS )</span><br><span class="line">        goto __NTQUERYSYSTEMINFORMATION_END;</span><br><span class="line"> </span><br><span class="line">    // 针对SystemProcessInformation类型操作</span><br><span class="line">    if( SystemInformationClass == SystemProcessInformation )</span><br><span class="line">    &#123;</span><br><span class="line">        // SYSTEM_PROCESS_INFORMATION类型转换</span><br><span class="line">        // pCur是单向链表的头</span><br><span class="line">        pCur = (PSYSTEM_PROCESS_INFORMATION)SystemInformation;</span><br><span class="line"> </span><br><span class="line">        while(TRUE)</span><br><span class="line">        &#123;</span><br><span class="line">            // 比较进程名称</span><br><span class="line">            // g_szProcName为要隐藏的进程名称</span><br><span class="line">            // (=&gt; SetProcName()设置)</span><br><span class="line">            if(pCur-&gt;Reserved2[1] != NULL)</span><br><span class="line">            &#123;</span><br><span class="line">                if(!_tcsicmp((PWSTR)pCur-&gt;Reserved2[1], g_szProcName))</span><br><span class="line">                &#123;</span><br><span class="line">                    // 从链表中删除隐藏进程的节点</span><br><span class="line">                    if(pCur-&gt;NextEntryOffset == 0)</span><br><span class="line">                        pPrev-&gt;NextEntryOffset = 0;</span><br><span class="line">                    else</span><br><span class="line">                        pPrev-&gt;NextEntryOffset += pCur-&gt;NextEntryOffset;</span><br><span class="line">                &#125;</span><br><span class="line">                else		</span><br><span class="line">                    pPrev = pCur;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            if(pCur-&gt;NextEntryOffset == 0)</span><br><span class="line">                break;</span><br><span class="line"> </span><br><span class="line">            // 链表的下一项</span><br><span class="line">            pCur = (PSYSTEM_PROCESS_INFORMATION)</span><br><span class="line">                    ((ULONG)pCur + pCur-&gt;NextEntryOffset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">__NTQUERYSYSTEMINFORMATION_END:</span><br><span class="line"> </span><br><span class="line">    // 函数终止前再次执行API钩取操作，为下次调用准备</span><br><span class="line">    hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, </span><br><span class="line">                 (PROC)NewZwQuerySystemInformation, g_pOrgBytes);</span><br><span class="line"> </span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单分析一下 将SystemInformationClass参数设置为SystemProcessInformation（5）后调用ZwQuerySystemInformation（）API，SystemInformation[in/out]参数中储存的是SYSTEM_PROCESS_INFORMATIN结构体单向链表的起始地址 隐藏某进程之前，先要查找与之对应的链表成员，然后断开其与链表的链接。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/09/OD学习记录5-11/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/09/OD学习记录5-11/" itemprop="url">OD学习记录5.11</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-09T19:18:09+08:00">
                2019-05-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="API钩取"><a href="#API钩取" class="headerlink" title="API钩取"></a>API钩取</h1><p>api(application programming interface,应用程序编程接口）。windows系统资源都是由windows os系统直接管理的，用户不能直接访问。用户需要访问系统资源的时候，必须向系统内核（kernel)申请，申请的方法就是使用微软提供的win32api.为了实际运行相应的程序代码，需要加载许多系统库（DLL).所有的进程都会默认加载kernel32.dll,kernel32.dll又会加载ntdll.dll库。</p>
<p><img src="1.png" alt=""><br>用户模式中的应用程序访问系统资源的时候，由ntdll.dll向内核模式提出访问请求。一般常规系统资源的api会经由kernel32.dll与ntdll.dll不断向下调用，最后同故宫SYSENTRY命令进入内核模式。</p>
<p>使用api钩取技术可以实现对某些win32API 的嗲用过程拦截，并获得相应的控制权限，使用api钩取技术的优势如下：<br>1）再api调用前/后运行用户的”钩子“代码。</p>
<p>2）查看或操作传递给api的参数或者传递api的返回值</p>
<p>3）取消对api的调用，或者更改执行流程，运行用户代码</p>
<p>下表列出了api钩取的技术图表：<br><img src="2.png" alt=""><br> 根据对象的不同，api钩取可以分为静态方法与动态方法。静态方法是针对的是“文件”，而动态方法针对的是进程内存。根据钩取的位置不懂，可以分为：</p>
<p>1)iat,将iad内部的api地址更改为钩取函数地址，该方法的优点是实现起来非常见到那，缺点是不能钩取不在iat中的api.</p>
<p>2)代码：系统库（*.dll）映射到进程内存时，从中查找api的实际嗲hi，并直接修改代码，具体的方法分为以下几种：使用jmp指令修改起始代码，覆写函数局部，仅更改必须部分的局部</p>
<p>3）eat:将记录在dll中的eat中的api起始地址更改为钩取函数地址也可以实现api钩取。</p>
<p>根据对应的技术不同，可以分为以下几种技术：</p>
<p>1）调试技术</p>
<p>调试法通过调试目标继承钩取api.调试器拥有被调试者的所有权限（执行控制，内存访问），所以可以向被调试进程的内存任意位置设置钩取函数。这里的调试器是用户编写的用来钩取的程序。在用户编写的程序中使用调试api附加到目标进程，然后设置钩取函数，这样，重启运行时就能偶完全实现api钩取了。也可以向现有的调试器（od,ida,windbg)使用自动化脚本，自动钩取api.</p>
<p>2)注入</p>
<p>向目标进程内存区域进行渗透测试的技术，根据注入对象的不同，可以分为dll注入与代码注入两种技术。</p>
<p>a)dll注入</p>
<p>使用dll注入即使可以使目标进程强制加载用户指定的dll文件。使用该技术的时候需要先在注入的dll中创建钩取代码与设置钩代码，然后再dllmain()中调用设置代码，注入的同时即可完成api钩取。</p>
<p>b）代码注入</p>
<p>代码注入技术广泛用于恶意代码，代码注入技术比dll注入技术更发达。</p>
<h1 id="记事本WriteFile（）API钩取"><a href="#记事本WriteFile（）API钩取" class="headerlink" title="记事本WriteFile（）API钩取"></a>记事本WriteFile（）API钩取</h1><h2 id="运行调试"><a href="#运行调试" class="headerlink" title="运行调试"></a>运行调试</h2><p>这次在windowsXP的虚拟机下调试程序 因为在自己的win10下有问题无法调试 所以就在winXP下去尝试了<br>首先运行notepad.exe 得到其PID 如图<br><img src="3.png" alt=""><br>然后运行hookdbg.exe 如图：<br><img src="4.png" alt=""><br>接下来像记事本里输入小写字母 随便输就行:<br><img src="5.png" alt=""><br>输入完后保存文件 发现刚才CMD黑框里的内容也变了：<br><img src="6.png" alt=""><br>发现刚好是刚才输入的内容和转变位大写的内容.<br>打开保存的记事本文件发现：<br><img src="7.png" alt=""><br>这就是钩取成功的表现了 下面看看其工作原理</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>先来看看WriteFile()定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL WriteFile(</span><br><span class="line">HANDLE  hFile,//文件句柄</span><br><span class="line">LPCVOID lpBuffer,//数据缓存区指针</span><br><span class="line">DWORD   nNumberOfBytesToWrite,//你要写的字节数</span><br><span class="line">LPDWORD lpNumberOfBytesWritten,//用于保存实际写入字节数的存储区域的指针</span><br><span class="line">LPOVERLAPPED lpOverlapped//OVERLAPPED结构体指针</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>参数 类型及说明<br>hFile Long，一个文件的句柄</p>
<p>lpBuffer Any，参数类型:指针,指向将写入文件的 数据缓冲区</p>
<p>nNumberOfBytesToWrite Long，要写入数据的字节数量。如写入零字节，表示什么都不写入，但会更新文件的“上一次修改时间”。针对位于远程系统的命名管道，限制在65535个字节以内</p>
<p>lpNumberOfBytesWritten Long，实际写入文件的字节数量（此变量是用来返回的 ）</p>
<p>lpOverlapped OVERLAPPED，倘若在指定FILE_FLAG_OVERLAPPED的前提下打开文件，这个参数就必须引用一个特殊的结构。那个结构定义了一次异步写操作。否则，该参数应置为空（将声明变为ByVal As Long，并传递零值）</p>
<p>用OD打开notepad 并在每个WriteFile上设置断点<br><img src="8.png" alt=""><br>运行程序并在记事本里输入内容 保存后发现 程序断在了WriteFile()处 并发现到了这4个重要的点<br><img src="9.png" alt=""><br>栈中有（ESP）1个返回值ESP+8中存在数据缓冲区的地址 直接跳转到此地址可以发现刚才输入的字符串 钩取Write/file（）API后 用指定字符串覆盖数据缓冲区的内容即可</p>
<h2 id="源代码分析（hookdng-cpp源代码）"><a href="#源代码分析（hookdng-cpp源代码）" class="headerlink" title="源代码分析（hookdng.cpp源代码）"></a>源代码分析（hookdng.cpp源代码）</h2><h3 id="main"><a href="#main" class="headerlink" title="main()"></a>main()</h3><p><img src="10.png" alt=""><br>Main函数以程序运行参数的形式接收要钩取API的进程的PID，然后通过DebugActiveProcess()API将调试器附加到该运行的进程上，开始调试。然后进入DebugLoop()函数，处理来自被调试者的调试事件。（也可以通过CreateProcess()API，从一开始就直接以调试模式运行进程）</p>
<h3 id="DebugLoop"><a href="#DebugLoop" class="headerlink" title="DebugLoop()"></a>DebugLoop()</h3><p><img src="11.png" alt=""><br>DebugLoop处理了三个DebugEvent，分别是</p>
<p>CREATE_PROCESS_DEBUG_EVENT： 被调试进程启动/附加时触发该事件，调试器调用OnCreateProcessDebugEvent()</p>
<p>EXCEPTION_DEBUG_EVENT：被调试进程遇到iNT 3指令时触发该事件，调试器调用OnExceptionDebugEvent()</p>
<p>EXIT_PROCESS_DEBUG_EVENT：被调试进程终止时触发，在本代码中，调试器在被调试器终止时退出</p>
<p>DebugL oop0函数的工作原理类似于窗口过程函数( WndProc ),它从被调试者处接收事件并处理，然后使被调试者继续运行。DebugLoop(函数代码比较简单，结合代码中的注释就能理解。下面看看其中比较重要的2个API。</p>
<p>顾名思义，WaitForDebugEvent() API (出处: MSDN)是-一个等待被调试者发生调试事件的函数(行为动作类似于WaitForSingleObject() API )。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WaitForDebugEvent(</span><br><span class="line"> </span><br><span class="line">    __in LPDEBUG_EVENT lpDebugEvent,</span><br><span class="line"> </span><br><span class="line">    __in DWORD dwMilliseconds</span><br><span class="line"> </span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>DebugLoop(函数代码中,若发生调试事件, WaitForDebugEvent( API就会将相关事件信息设置到其第- -个参数的变量( DEBUG EVENT结构体对象), 然后立刻返回。DEBUG EVENT结构体定义(出处: MSDN)如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _DEBUG_EVENT &#123;</span><br><span class="line"> </span><br><span class="line">    DWORD dwDebugEventCode;</span><br><span class="line"> </span><br><span class="line">    DWORD dwProcessId;</span><br><span class="line"> </span><br><span class="line">    DWORD dwThreadId;</span><br><span class="line"> </span><br><span class="line">    union &#123;</span><br><span class="line"> </span><br><span class="line">        EXCEPTION_DEBUG_INFO Exception;</span><br><span class="line"> </span><br><span class="line">        CREATE_THREAD_DEBUG_INFO CreateThread;</span><br><span class="line"> </span><br><span class="line">        CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;</span><br><span class="line"> </span><br><span class="line">        EXIT_THREAD_DEBUG_INFO ExitThread;</span><br><span class="line"> </span><br><span class="line">        EXIT_PROCESS_DEBUG_INFO ExitProcess;</span><br><span class="line"> </span><br><span class="line">        LOAD_DLL_DEBUG_INFO LoadDll;</span><br><span class="line"> </span><br><span class="line">        UNLOAD_DLL_DEBUG_INFO UnloadDll;</span><br><span class="line"> </span><br><span class="line">        OUTPUT_DEBUG_STRING_INFO DebugString;</span><br><span class="line"> </span><br><span class="line">        RIP_INFO RipInfo;</span><br><span class="line"> </span><br><span class="line">    &#125; u;</span><br><span class="line"> </span><br><span class="line">&#125; DEBUG_EVENT, *LPDEBUG_EVENT;</span><br></pre></td></tr></table></figure>
<p>前面的讲解中已经提到过，共有9种调试事件。DEBUG_ EVENT.dwDebugEventCode成员 会被设置为9种事件中的一-种，根据相关事件的种类，也会设置适当的DEBUG_EVENTu(union)成员( DEBUG EVENT.u共用体成员内部也由9个结构体组成，它们对应于事件种类的个数)</p>
<p>ContinueDebugEvent是一个使调试器继续运行的API</p>
<p>定义如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ContinueDebugEvent(</span><br><span class="line"> </span><br><span class="line">    __in DWORD dwProcessId,</span><br><span class="line"> </span><br><span class="line">    __in DWORD dwThreadId,</span><br><span class="line"> </span><br><span class="line">    __in DWORD dwContinueStatus</span><br><span class="line"> </span><br><span class="line">    );</span><br></pre></td></tr></table></figure></p>
<p>ContinueDebugEvent() API 的 最 后 一 个 参 数 dwContinueStatus 的 值 为 DBG_CONTINUE 或  DBG_EXCEPTION_NOT_HANDLED。若处理正常，则其值设置为DBG_CONTINUE;若无法处理，或希望在应用程序的SEH中处 理，则其值设置为DBG EXCEPTION NOT HANDLED</p>
<p>DebugLoopO函数处理3种调试事件，如下所示。</p>
<p>□ EXIT_PROCESS_DEBUG_EVENT</p>
<p>□ CREATE_PROCESS_DEBUG_EVENT</p>
<p>□ EXCEPTION_DEBUG_EVENT</p>
<p>下面分别看看这3个事件。<br>EXIT_PROCESS_DEBUG_EVENT</p>
<p>被调试进程终止时会触发该事件。本章的示例代码中发生该事件时，调试器与被调试者将一 起终止。</p>
<p>CREATE_PROCESS_DEBUG_EVENT-OnCreateProcessDebugEvent()</p>
<p>OnCreateProcessDebugEvent()是 CREATE_PROCESS_DEBUG_EVENT 事件句柄，被调试进程启动（或者附加）时即调用执行该函数。</p>
<h3 id="OnCreateProcessDebugEvent"><a href="#OnCreateProcessDebugEvent" class="headerlink" title="OnCreateProcessDebugEvent()"></a>OnCreateProcessDebugEvent()</h3><p><img src="12.png" alt=""><br>代码首先获得WriteFile的内存地址,</p>
<p>然后将函数地址处的第一个字节数据存放在g_chOrgByte变量中，之后将函数地址处第一个字节改为0xCC</p>
<p>由于调试器拥有被调试进程的句柄（带有调试权限，DLL注入时也是首先将进程提升为调试权限[SE_DEBUG_NAME]）所以可以使用ReadProcessMemory和WriteProcessMemory对被调试进程的内存空间自由进行读写操作。</p>
<h3 id="OnExceptionDebugEvent"><a href="#OnExceptionDebugEvent" class="headerlink" title="OnExceptionDebugEvent()"></a>OnExceptionDebugEvent()</h3><p><img src="13.png" alt=""><br><img src="14.png" alt=""><br><img src="15.png" alt=""><br><img src="16.png" alt=""><br>OnExceptionDebugEvent(函数代码有些多，接下来分析核心部分。首先，if语句用于检测异常是否为EXCEPTION_ BREAKPOINT异常(除此之外，还有大约19种异常,请参考前几节内容)。然后，用if语句检测发生断点的地址是否与kernel32!WriteFile(的起始地址一致( OnCreateProcessDebugEvent()已经事先获取了WriteFile()的起始地址)。若满足条件,则继续执行以下代码\</p>
<h4 id="脱钩（恢复原代码）"><a href="#脱钩（恢复原代码）" class="headerlink" title="脱钩（恢复原代码）"></a>脱钩（恢复原代码）</h4><p><img src="17.png" alt=""></p>
<h4 id="获取线程上下文"><a href="#获取线程上下文" class="headerlink" title=".获取线程上下文"></a>.获取线程上下文</h4><p>这是第1次提到“线程上下文”，所有程序在内存中都以进程为单位运行，而进程的实际指令代码以线程为单位运行。Windows OS是一个多线程 ( multi-thread )操作系统，同-进程中可以同时运行多个线程。多任务( multi-tasking )是将CPU资源划分为多个时间片( time-slice),然后平等地逐一 运行所有线程(考虑线程优先级)。 CPU运行完一 个线程的时间片而切换到其他线程时间片时，它必须将先前线程处理的内容准确备份下来，这样再次运行它时才能正常无误。</p>
<p>再次运行先前线程时，必须有运行所需信息，这些重要信息指的就是CPU中各寄存器的值。通过这些值，才能保证CPU能够再次准确运行它(内存信息栈&amp;堆存在于相应进程的虚拟空间,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI</span><br><span class="line">BOOL</span><br><span class="line">WINAPI</span><br><span class="line">GetThreadContext(</span><br><span class="line">    __in    HANDLE hThread,</span><br><span class="line">    __inout LPCONTEXT lpContext</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>像这样调用GetThreadContext() API (出处: MSDN),即可将指定线程( g_ cpdi.hThread)的CONTEXT存储到ctx结构体变量( g_ cpdi.hThread是被调试者的主线程句柄)。</p>
<h4 id="获取WriteFile-的param值"><a href="#获取WriteFile-的param值" class="headerlink" title="获取WriteFile()的param值"></a>获取WriteFile()的param值</h4><p>调用WriteFile()函数时,我们要在传递过来的参数中知道param2 (数据缓冲区地址)与param3(缓冲区大小)这2个参数。函数参数存储在栈中，通过#2中获取的CONTEXT.Esp成员可以分别获得它们的值</p>
<p><img src="18.png" alt=""><br>存储在dwAddrOfBuffer中的数据缓冲区地址是被调试者（notepad.exe）虚拟内存空间中的地址</p>
<h4 id="把小写字母转换为大写字母后覆写在WriteFile-缓冲区"><a href="#把小写字母转换为大写字母后覆写在WriteFile-缓冲区" class="headerlink" title="把小写字母转换为大写字母后覆写在WriteFile()缓冲区"></a>把小写字母转换为大写字母后覆写在WriteFile()缓冲区</h4><p>获取数据缓冲区的地址与大小后,将其内容读到调试器的内存空间，把小写字母转换为大写字母。然后将修改后的大写字母覆写到原位置(被调试者的虚拟内存)。整个代码不难，结合代码中的注释就能轻松理解</p>
<p><img src="19.png" alt=""></p>
<h4 id="把线程上下文的EIP修改为WriteFile-起始地址"><a href="#把线程上下文的EIP修改为WriteFile-起始地址" class="headerlink" title="把线程上下文的EIP修改为WriteFile()起始地址"></a>把线程上下文的EIP修改为WriteFile()起始地址</h4><p><img src="20.png" alt=""><br>将线程上下文的EIP更改为WriteFile()首地址(当前为WriteFile() + 1位置，int3命令之后)</p>
<p>修改好CONTEXT.Eip成员后，调用SetThreadContext()API来修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SetThreadContext(</span><br><span class="line"> </span><br><span class="line">    __in HANDLE hThread,</span><br><span class="line"> </span><br><span class="line">    __in CONST CONTEXT *lpContext</span><br><span class="line"> </span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h5 id="运行调试进程"><a href="#运行调试进程" class="headerlink" title="运行调试进程"></a>运行调试进程</h5><p> 全部准备完成后，接下来就正常调用WriteFile()API了，调用ContinueDebugEvent()API就可以重启被调试进程，使之继续运行。</p>
<h4 id="继续HOOK（达到循环获取的目的）"><a href="#继续HOOK（达到循环获取的目的）" class="headerlink" title="继续HOOK（达到循环获取的目的）"></a>继续HOOK（达到循环获取的目的）</h4><p> 最后设置API“钩子”，方便下次钩取操作(若略去该操作，由于#1中已经“脱钩”, WriteFile()API钩取将完全处于“脱钩”状态)</p>
<p><img src="21.png" alt=""><br>在 OnExceptionDebugEvent()函 数 中 调 用 了 ContinueDebugEvent()函 数 后 ，为 什 么 还 要  调 用Sleep(0)函 数 ？</p>
<font color="#00ffff" size="3">调 用Sleep(0)函 数 可 以 释 放 当 前 线 程 的 剩 余 时 间 片 ， 即 放 弃 当 前 线 程 执 行 的CPU时 间 片。也 就 是 说 ， 调 用Sleep(0)函 数 后 ，CPU会 立 即 执 行 其 他 线 程 。 被 调 试 进 程（Notepad.exe) 的 主 线 程 处 于 运 行 状 态 时 ， 会 正 常 调 用WriteFiIe()API。然 后 经 过 一 定 时 间 ， 控 制 权 再 次 转 移 给HookDbg.exe, Sleep(0)后 面 的 “ 钩子 ” 代 码（WriteProcessMemory()API)会 被 调 用 执 行。若 没 有Sleep(0)语 句 ，Notepad.exe调 用WriteFile()API的 过 程 中 ，HookDbg.exe会尝试将WriteFile()API的首字节修改为OxCC。若运气不佳，这可能会导致内存访问异常。（避免notepad正在调用writefile()API的过程中，后面的钩子代码在调用成功之前执行完毕)</font>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/04/od学习5-4/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/04/od学习5-4/" itemprop="url">od学习5.4</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-04T21:33:15+08:00">
                2019-05-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="windows消息钩取"><a href="#windows消息钩取" class="headerlink" title="windows消息钩取"></a>windows消息钩取</h1><h2 id="简单地说，消息钩取就是偷看、截取信息。"><a href="#简单地说，消息钩取就是偷看、截取信息。" class="headerlink" title="简单地说，消息钩取就是偷看、截取信息。"></a>简单地说，消息钩取就是偷看、截取信息。</h2><h2 id="常规Windows消息流："><a href="#常规Windows消息流：" class="headerlink" title="常规Windows消息流："></a>常规Windows消息流：</h2><p>1、发生键盘输入事件时，WM_KEYDOWN消息被添加到[OS message queue]；</p>
<p>2、OS判断哪个应用程序中发生了事件，然后从[OS message queue]中取出消息，添加到相应应用程序的[application message queue]中；</p>
<p>3、应用程序监视自身的[application message queue]，发现新添加的WM_KEYDOWN消息后，调用相应的事件处理程序处理。</p>
<h2 id="消息钩子："><a href="#消息钩子：" class="headerlink" title="消息钩子："></a>消息钩子：</h2><p>Windows OS向用户提供GUI，其是以事件驱动的方式进行工作的。每当发生这样的事件时，OS会将事先定义好的消息发送给相应的应用程序，应用程序分析收到的信息后执行相应动作。即在敲击键盘时，消息从OS传递到应用程序，此过程中消息钩子可以偷看其中的信息。</p>
<p>消息钩子是Windows OS提供的基本功能，其中最具代表性的是VS Visual Studio中提供的SPY++，其是一个功能强大的消息钩取程序，能够查看OS中来往的所有消息。</p>
<p>如下图，OS消息队列和应用程序消息队列之间存在一条钩链（Hook Chain），设置好键盘消息钩子后，处于钩链中的键盘消息钩子会比应用程序先一步看到相应信息。在键盘消息钩子函数的内部，除了可以查看消息之外，还可以修改消息本身，而且还能对消息实施拦截，阻止消息传递。可以同时设置多个相同的键盘消息钩子，按照设置的顺序依次调用，从而组成的链条称为钩链。</p>
<p><img src="1.jpg" alt=""></p>
<h2 id="Windows消息钩取的实现——SetWindowsHookEx"><a href="#Windows消息钩取的实现——SetWindowsHookEx" class="headerlink" title="Windows消息钩取的实现——SetWindowsHookEx()"></a>Windows消息钩取的实现——SetWindowsHookEx()</h2><p>在Windows编程中，使用SetWindowsHookEx() API可以简便地实现消息钩子，其用于将指定的钩子注册到钩链中，无论在DLL内部或外部都可调用.</p>
<p>SetWindowsHookEx() API定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HHOOK SetWindowsHookEx(</span><br><span class="line">    int idHook,			//hook type</span><br><span class="line">    HOOKPROC lpfn,		//hook procedure</span><br><span class="line">    HINSTANCE hMod,		//hook procedure所属的DLL句柄</span><br><span class="line">    DWORD dwThreadId	//将要挂钩的目标线程ID</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>HHOOK：返回值，钩子句柄，需要保留，等不使用钩子时通过UnhookWindowsHookEx函数卸载钩子。</p>
<p>idHook：钩子的拦截消息类型，选择钩子程序的拦截范围，具体值参考文章结尾的消息类型。</p>
<p>Lpfn：消息的回调函数地址，一般是填函数名。</p>
<p>hMod：钩子函数所在的实例的句柄。对于线程钩子，该参数为NULL；对于系统钩子，该参数为钩子函数所在的DLL句柄。在dll中可通过AfxInitExtensionModule(MousehookDLL, hInstance)获得DLL句柄。</p>
<p>dwThreadId：钩子所监视的线程的线程号，可通过GetCurrentThreadId()获得线程号。对于全局钩子，该参数为NULL(或0)。</p>
<h2 id="调试Windows消息钩取"><a href="#调试Windows消息钩取" class="headerlink" title="调试Windows消息钩取"></a>调试Windows消息钩取</h2><h3 id="1、调试HookMain-exe："><a href="#1、调试HookMain-exe：" class="headerlink" title="1、调试HookMain.exe："></a>1、调试HookMain.exe：</h3><p><img src="2.png" alt=""><br>直接拉到401000处可以看到：<br><img src="3.png" alt=""><br>程序先在401006地址处调用LoadLibraryA(KeyHook.dll)，然后在40104B地址处的CALLEBX指令调用KeyHook.HookStart()函数。跟踪进入该函数查看：</p>
<p><img src="4.png" alt=""><br>在100010EF地址处可以看到，调用了SetWindowsHookExW()函数，其上方两条PUSH指令将该函数的第一、第二两个参数压入栈。其中第一个参数idHook值为2，即WH_KEYBOARD，第二个参数lpfn值为74C21020，该值即为钩子过程的地址。</p>
<p>返回main()函数之后的代码即为接收用户输入的q后即终止钩取</p>
<h3 id="2-调试Notepad-exe："><a href="#2-调试Notepad-exe：" class="headerlink" title="2.调试Notepad.exe："></a>2.调试Notepad.exe：</h3><p><img src="5.png" alt=""><br>在调试界面里的事件选择：<br><img src="6.png" alt=""><br>开启后 每当新的DLL被调试时就会自动暂停调试 在从DLL注入调试时开始调试的情况下很有用<br>运行后发现：<br><img src="7.png" alt=""><br>双击HOOK到达HOOK的EP地址处 给此处设置断点 发现每次发生键盘输入事件时 程序就会停在此处</p>
<h1 id="Dll注入"><a href="#Dll注入" class="headerlink" title="Dll注入"></a>Dll注入</h1><h2 id="用CreateRemoteThread实现DLL注入"><a href="#用CreateRemoteThread实现DLL注入" class="headerlink" title="用CreateRemoteThread实现DLL注入"></a>用CreateRemoteThread实现DLL注入</h2><h3 id="（一）myhack-dll，即要注入的dll程序"><a href="#（一）myhack-dll，即要注入的dll程序" class="headerlink" title="（一）myhack.dll，即要注入的dll程序"></a>（一）myhack.dll，即要注入的dll程序</h3><p>程序流程：<br>（1）当DLL被加载（DLL_PROCESS_ATTACH）时，先输出一个调试字符串，<br>（2）利用CreateThread() 创建一个线程，创建后立即被激活，直接调用ThreadProc函数<br>（3）该函数调用URLDownloadToFile() 下载指定网站的index.html文件<br>首先将InjectDll.exe和myhack.DLl放入一个文件夹<br><img src="13.png" alt=""><br>运行notepad.exe 看到PID是6340<br><img src="14.png" alt=""><br>myhack.dll注入<br><img src="15.png" alt=""><br>结果确认<br><img src="16.png" alt=""><br>发现文件夹里多了文件  打开看看<br><img src="17.png" alt=""><br>虽然看起来与实际主页可能不同 但确实是从该网站下载的index.html文件<br>上述借助创建远程线程的方法可以成功渗透指定进程 进而可以随意操作</p>
<h3 id="（二）InjectDll-exe，即将myhack-dll注入notepad-exe的程序"><a href="#（二）InjectDll-exe，即将myhack-dll注入notepad-exe的程序" class="headerlink" title="（二）InjectDll.exe，即将myhack.dll注入notepad.exe的程序"></a>（二）InjectDll.exe，即将myhack.dll注入notepad.exe的程序</h3><p>程序流程：<br>（1）首先进行提权，如果不提权，OpenProcess()会报GetlastError[5]的错误，同时拿不到句柄。这是因为在xp环境下，虽然账号是管理员，但是权限默认没有启动。<br>（2）利用OpenProcess() 获得目标进程的句柄。这里指notepad.exe<br>（3）用VirtualAllocEx() 在目标进程空间分配一定的内存空间。用来写入DLL的路径<br>（4）用WriteProcessMemory() 将DLL路径字符串写入刚分配的内存。<br>（5）利用GetModuleHandle() 和GetProcessAddress() 得到LoadLibrary() 的地址。用来加载DLL<br>（6）利用CreateRemoteThread() 使LoadLibrary()加载DLL，实现DLL的注入。<br>给进程提权有三种方法：</p>
<h4 id="调试："><a href="#调试：" class="headerlink" title="调试："></a>调试：</h4><p>打开记事本，OD attach ，运行；<br>将OD的选项-&gt;调试设置-&gt;事件-&gt;中断在新模块DLL处选中，则程序当加载新的DLL时就会停住；<br>运行命令行，输入参数，运行InjectDll.exe程序。<br>将notepad.exe拖入Od 查看其PID 如图：<br><img src="18.png" alt=""><br>还是myhack.dll注入<br><img src="19.png" alt=""><br>在调试界面里的事件选择：<br><img src="20.png" alt=""><br>F9运行会发现myhack.dll<br><img src="21.png" alt=""><br>双击来到myhack.dll 入口点附近，下断点，接下来，将OD的中断在新的DLL入口处关闭，运行，就可以调试DLL程序了<br><img src="22.png" alt=""><br>下来F9运行 断在了刚才设置断点的地方 接下来F8单步运行 运行到这里发现myhack.dll字符串：<br><img src="23.png" alt=""><br>继续运行发现到了这里：<br><img src="24.png" alt=""><br>执行完后，说明这个函数实现了拷贝，但是……为啥要拷贝？<br><img src="25.png" alt=""><br>最后调用URLDownloadToFile() 函数实现下载。观察参数明白了，原来拷贝函数是为了得到下载存储的路径的呀！<br><img src="26.png" alt=""><br>运行程序：发现注入成功了！</p>
<h1 id="使用汇编语言编写注入代码"><a href="#使用汇编语言编写注入代码" class="headerlink" title="使用汇编语言编写注入代码"></a>使用汇编语言编写注入代码</h1><h2 id="新的EPI"><a href="#新的EPI" class="headerlink" title="新的EPI"></a>新的EPI</h2><p>在反汇编窗口右键，选择此处为新EIP，可以修改EIP指向选中的位置，与直接通过调试方式转到指定地址不一样的是，寄存器和栈中的内容未改变</p>
<p><img src="8.png" alt=""></p>
<h2 id="编写ThreadProc函数"><a href="#编写ThreadProc函数" class="headerlink" title="编写ThreadProc函数"></a>编写ThreadProc函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PUSH EBP</span><br><span class="line">MOV EBP,ESP                        ; 生成栈桢</span><br><span class="line">MOV ESI,DWORD PTR SS:[EBP+8]       ; ESI = pParam 从栈上获取函数参数       </span><br><span class="line">PUSH 6C6C                      </span><br><span class="line">PUSH 642E3233</span><br><span class="line">PUSH 72657375</span><br><span class="line">PUSH ESP                           ; - &quot;user32.dll&quot;(ESP为字符串首地址)，LoadLibraryA的参数</span><br><span class="line">CALL DWORD PTR DS:[ESI]            ; LoadLibraryA(&quot;user32.dll&quot;)</span><br><span class="line">PUSH 41786F</span><br><span class="line">PUSH 42656761</span><br><span class="line">PUSH 7373654D</span><br><span class="line">PUSH ESP                           ; - &quot;MessageBoxA&quot;(同上&quot;user32.dll&quot;的解释)</span><br><span class="line">PUSH EAX                           ; - hMod(EAX是LoadLibraryA的返回值)</span><br><span class="line">CALL DWORD PTR DS:[ESI+4]          ; GetProcAddress(hMod, &quot;MessageBoxA&quot;)</span><br><span class="line">PUSH 0                             ; - MB_OK (0)</span><br><span class="line">CALL 0040112C</span><br><span class="line">&lt;ASCII&gt;                            ; - &quot;ReverseCore&quot;, 0</span><br><span class="line">CALL 00401145</span><br><span class="line">&lt;ASCII&gt;                            ; - &quot;www.reversecore.com&quot;, 0</span><br><span class="line">PUSH 0                             ; - hWnd (0)</span><br><span class="line">CALL EAX                           ; MessageBoxA(0, &quot;www.reversecore.com&quot;, &quot;ReverseCore&quot;, 0)</span><br><span class="line">XOR EAX,EAX                        </span><br><span class="line">MOV ESP,EBP</span><br><span class="line">POP EBP                            </span><br><span class="line">RETN</span><br></pre></td></tr></table></figure>
<p>这里有些是字符串的代码 由于OD的原因 才会显示成汇编代码</p>
<h3 id="使用push指令将字符串数据压栈"><a href="#使用push指令将字符串数据压栈" class="headerlink" title="使用push指令将字符串数据压栈"></a>使用push指令将字符串数据压栈</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PUSH 41786F</span><br><span class="line">PUSH 42656761</span><br><span class="line">PUSH 7373654D</span><br></pre></td></tr></table></figure>
<p>这段代码还是比较好理解的，实际上是将字符串压到栈上</p>
<p>可以看到运行到call指令前，栈上的情况如下<br><img src="9.png" alt=""><br>字符串’user32.dll‘即为栈上的\x75\x73\x65\x72\x33\x32\x2e\x64\x6c\x6c</p>
<h3 id="使用call指令将字符串数据压栈"><a href="#使用call指令将字符串数据压栈" class="headerlink" title="使用call指令将字符串数据压栈"></a>使用call指令将字符串数据压栈</h3><p>第二种将字符串保存在代码中的方法为使用call指令</p>
<p>call func_address指令的本质为push eip+4，jmp func_address<br><img src="10.png" alt=""><br>在03d8002e处执行call 03d8003f实际上是执行了push 03d80033, jmp 03d8003f</p>
<p>可以在数据窗口中看出从03d80033到03d8003e存储的内容为ReverseCore的字符串，所以push 03d80033实际上是将字符串的首地址压栈</p>
<p>f7跟进call, 可以看到跳转到的内容如下<br><img src="11.png" alt=""><br>这仍然是一个将字符串压栈的过程，第一行的call指令将首地址为03d90044的字符串“<a href="http://www.reversecore.com”压栈" target="_blank" rel="noopener">www.reversecore.com”压栈</a></p>
<p>然后跳转到03d90058</p>
<p><img src="12.png" alt=""><br>该地址的内容如上图，调用了MessageBoxA函数</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/27/周报4-27/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/27/周报4-27/" itemprop="url">周报4.27</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-27T20:18:19+08:00">
                2019-04-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="OD学习记录（真难啊-QAQ）"><a href="#OD学习记录（真难啊-QAQ）" class="headerlink" title="OD学习记录（真难啊~~~QAQ）"></a>OD学习记录（真难啊~~~QAQ）</h1><h2 id="手动修复IAT"><a href="#手动修复IAT" class="headerlink" title="手动修复IAT"></a>手动修复IAT</h2><p>开始修复IAT。<br>第一步还是先找到OEP，到达OEP后，OD和进程本身不能关掉。脱壳过程中不能把程序关掉。<br>操作过程和之前相同，先选进程，右键，完整转存，脱壳完毕。<br>双击脱壳后的程序，无法打开。<br>第二步：使用importrec修复IAT。不是选择dump后的程序，而是到达OEP的加壳程序。为什么不选择脱壳后的程序呢？<br>因为我们需要提取源文件里的信息，放到脱壳后的文件里。然后放到脱壳后的程序 附件进程后，里面有个选项</p>
<p>如何使用填写这几个数字呢：<br>第一个选项是OEP栏：这里填写OEP的相对偏移地址就行<br>第二个选项是RVA：虚拟内存地址，这里填IAT的起始位置<br>大小：填写导入表大小，需要用IAT的末地址减去首地址。哪个是首地址，哪个是尾部地址？<br>有一个小技巧，能帮我们快速定位到IAT的开始和末尾。怎么做呢，在数据窗口右击-长型-地址，那么它的起始位置<br>就非常直观了：<br><img src="1.jpg" alt=""><br>OEP：10000<br>RVA：3184<br>大小：尾部一定得是00000000才行。而且得是最后一个00000000。<br>接下来就是修复PE头了</p>
<h2 id="打补丁"><a href="#打补丁" class="headerlink" title="打补丁"></a>打补丁</h2><p>程序很简单，只有两个窗口<br><img src="13.png" alt=""><img src="14.png" alt=""><br>（一）、使用OD载入程序，按F9跳转到入口点<br><img src="1.png" alt=""><br>（二）步入第一个call调用<br><img src="2.png" alt=""><br>（三）按f8步进来到40109B处<br>仔细分析这段代码，会发现这段代码的是第一轮解密代码，对004010F5到00401249（004010F5+0x154）这个区段的数据异或0x44<br><img src="3.png" alt=""><br>（四）继续按f8步进来到40109B处，可以发现两个循环，这个两个循环都负责解密<br><img src="4.png" alt=""><br>（五）继续按f8步进程序会返回到00401038处，此处需要主意的校验和计算和比较校验和的值。<br><img src="5.png" alt=""><br>（六）继续运行程序，会发现OEP，如下图<br><img src="6.png" alt=""><br>还有下面的跳转表的啦。。。。<br><img src="7.png" alt=""><br>（七）通过查找DialogBoxParamA的api手册，会发现4010F5是指向对话框的指针，跳转到4010F5这个地址之后，在往下滚动，发现字符串（x32dbg将这个区段解析为指令了，ascii码对的上，只能在内存窗口中查看）。</p>
<p><img src="8.png" alt=""><br>通过分析pe结构，我们会发现.text头会有很多代码洞空白区域<br><img src="9.png" alt=""><br>插入代码。.。。<br><img src="10.png" alt=""><br>修改JMP指令<br>修改前：<br><img src="11.png" alt=""><br>修改后：<br><img src="12.png" alt=""><br>然后就成功了。。。。。。不晓得我为啥有点问题QAQ。。。<br>中途想过之前的方法是直接修改数据窗口的内容来让实现修改  尝试以后发现程序有检测的  不能用 就只能用打补丁的方法咯</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/19/插入图片/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/19/插入图片/" itemprop="url">插入图片</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-19T15:17:59+08:00">
                2019-04-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="本地引用"><a href="#本地引用" class="headerlink" title="本地引用"></a>本地引用</h1><h2 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h2><p>当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](/images/image.jpg)</span><br></pre></td></tr></table></figure></p>
<p>图片既可以在首页内容中访问到，也可以在文章正文中访问到</p>
<h2 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h2><p>图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置_config.yml来生成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure></p>
<p>将_config.yml文件中的配置项post_asset_folder设为true后，执行命令$ hexo new post_name，在source/_posts中会生<br>成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](image.jpg)</span><br></pre></td></tr></table></figure></p>
<p>上述图片只能在文章中显示，但无法在首页中正常显示。<br>如果希望图片在文章和首页中同时显示，可以使用标签插件语法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img image.jpg This is an image %&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/17/PE文件结构/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/17/PE文件结构/" itemprop="url">PE文件结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-17T20:01:19+08:00">
                2019-04-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="PE文件结构"><a href="#PE文件结构" class="headerlink" title="PE文件结构"></a>PE文件结构</h1><p><img src="PE结构.png" alt=""></p>
<h2 id="PE文件结构详解（一）基本概念"><a href="#PE文件结构详解（一）基本概念" class="headerlink" title="PE文件结构详解（一）基本概念"></a>PE文件结构详解（一）基本概念</h2><p>1.DOS头是用来兼容MS-DOS操作系统的，目的是当这个文件在MS-DOS上运行时提示一段文字，大部分情况下是：This program cannot be run in DOS mode.还有一个目的，就是指明NT头在文件中的位置。</p>
<p>2.NT头包含windows PE文件的主要信息，其中包括一个‘PE’字样的签名，PE文件头（IMAGE_FILE_HEADER）和PE可选头（IMAGE_OPTIONAL_HEADER32），头部的详细结构以及其具体意义在PE文件头文章中详细描述。</p>
<p>3.节表：是PE文件后续节的描述，windows根据节表的描述加载每个节。<br>4.节：每个节实际上是一个容器，可以包含代码、数据等等，每个节可以有独立的内存权限，比如代码节默认<br>有读/执行权限，节的名字和数量可以自己定义，未必是上图中的三个。<br>当一个PE文件被加载到内存中以后，我们称之为“映象”（image），一般来说，PE文件在硬盘上和在内存里是不完全一样的，被加载到内存以后其占用的虚拟地址空间要比在硬盘上占用的空间大一些，这是因为各个节在硬盘上是连续的，而在内存中是按页对齐的，所以加载到内存以后节之间会出现一些“空洞”。</p>
<p>因为存在这种对齐，所以在PE结构内部，表示某个位置的地址采用了两种方式，针对在硬盘上存储文件中的地址，称为原始存储地址或物理地址表示距离文件头的偏移；另外一种是针对加载到内存以后映象中的地址，称为相对虚拟地址（RVA），表示相对内存映象头的偏移。</p>
<p>然而CPU的某些指令是需要使用绝对地址的，比如取全局变量的地址，传递函数的地址编译以后的汇编指令中肯定需要用到绝对地址而不是相对映象头的偏移，因此PE文件会建议操作系统将其加载到某个内存地址（这个叫基地址），编译器便根据这个地址求出代码中一些全局变量和函数的地址，并将这些地址用到对应的指令中。例如在IDA里看上去是这个样子：<br><img src="1.jpg" alt=""><br>这种表示方式叫做虚拟地址（VA）。</p>
<p>也许有人要问，既然有VA这么简单的表示方式为什么还要有前面的RVA呢？因为虽然PE文件为自己指定加载的基地址，但是windows有茫茫多的DLL，而且每个软件也有自己的DLL，如果指定的地址已经被别的DLL占了怎么办？如果PE文件无法加载到预期的地址，那么系统会帮他重新选择一个合适的基地址将他加载到此处，这时原有的VA就全部失效了，NT头保存了PE文件加载所需的信息，在不知道PE会加载到哪个基地址之前，VA是无效的，所以在PE文件头中大部分是使用RVA来表示地址的，而在代码中是用VA表示全局变量和函数地址的。那又有人要问了，既然加载基址变了以后VA都失效了，那存在于代码中的那些VA怎么办呢？答案是：重定位。系统有自己的办法修正这些值，到后续重定位表的文章中会详细描述。既然有重定位，为什么NT头不能依靠重定位采用VA表示地址呢（十万个为什么）？因为不是所有的PE都有重定位，早期的EXE就是没有重定位的。</p>
<h2 id="PE文件结构详解（二）可执行文件头"><a href="#PE文件结构详解（二）可执行文件头" class="headerlink" title="PE文件结构详解（二）可执行文件头"></a>PE文件结构详解（二）可执行文件头</h2><h3 id="一、DOS头"><a href="#一、DOS头" class="headerlink" title="一、DOS头"></a>一、DOS头</h3><p>DOS头的作用是兼容MS-DOS操作系统中的可执行文件，对于32位PE文件来说，DOS所起的作用就是显示一行文字，提示用户：我需要在32位windows上才可以运行。我认为这是个善意的玩笑，因为他并不像显示的那样不能运行，其实已经运行了，只是在DOS上没有干用户希望看到的工作而已，我们看一下这个头是如何定义的：</p>
<p>我们只需要关注两个域：</p>
<p>e_magic：一个WORD类型，值是一个常数0x4D5A，用文本编辑器查看该值位‘MZ’，可执行文件必须都是’MZ’开头。</p>
<p>e_lfanew：为32位可执行文件扩展的域，用来表示DOS头之后的NT头相对文件起始地址的偏移。<br><img src="2.png" alt=""></p>
<h3 id="二、NT头"><a href="#二、NT头" class="headerlink" title="二、NT头"></a>二、NT头</h3><p>顺着DOS头中的e_lfanew，我们很容易可以找到NT头，这个才是32位PE文件中最有用的头。</p>
<p>IMAGE_FILE_HEADER是PE文件头，c语言的定义是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_FILE_HEADER &#123;</span><br><span class="line">    WORD    Machine;</span><br><span class="line">    WORD    NumberOfSections;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    DWORD   PointerToSymbolTable;</span><br><span class="line">    DWORD   NumberOfSymbols;</span><br><span class="line">    WORD    SizeOfOptionalHeader;</span><br><span class="line">    WORD    Characteristics;</span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure></p>
<p>每个域的具体含义如下：</p>
<p>Machine：该文件的运行平台，是x86、x64还是I64等等，可以是下面值里的某一个。</p>
<p>NumberOfSections：该PE文件中有多少个节，也就是节表中的项数。</p>
<p>TimeDateStamp：PE文件的创建时间，一般有连接器填写。</p>
<p>PointerToSymbolTable：COFF文件符号表在文件中的偏移。</p>
<p>NumberOfSymbols：符号表的数量。</p>
<p>SizeOfOptionalHeader：紧随其后的可选头的大小。</p>
<p>Characteristics：可执行文件的属性，可以是下面这些值按位相或。</p>
<p>可以看出，PE文件头定义了PE文件的一些基本信息和属性，这些属性会在PE加载器加载时用到，如果加载器发现PE文件头中定义的一些属性不满足当前的运行环境，将会终止加载该PE。</p>
<p>另一个重要的头就是PE可选头，别看他名字叫可选头，其实一点都不能少，不过，它在不同的平台下是不一样的，例如32位下是IMAGE_OPTIONAL_HEADER32，而在64位下是IMAGE_OPTIONAL_HEADER64<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_OPTIONAL_HEADER &#123;</span><br><span class="line">    WORD    Magic;</span><br><span class="line">    BYTE    MajorLinkerVersion;</span><br><span class="line">    BYTE    MinorLinkerVersion;</span><br><span class="line">    DWORD   SizeOfCode;</span><br><span class="line">    DWORD   SizeOfInitializedData;</span><br><span class="line">    DWORD   SizeOfUninitializedData;</span><br><span class="line">    DWORD   AddressOfEntryPoint;</span><br><span class="line">    DWORD   BaseOfCode;</span><br><span class="line">    DWORD   BaseOfData;</span><br><span class="line">    DWORD   ImageBase;</span><br><span class="line">    DWORD   SectionAlignment;</span><br><span class="line">    DWORD   FileAlignment;</span><br><span class="line">    WORD    MajorOperatingSystemVersion;</span><br><span class="line">    WORD    MinorOperatingSystemVersion;</span><br><span class="line">    WORD    MajorImageVersion;</span><br><span class="line">    WORD    MinorImageVersion;</span><br><span class="line">    WORD    MajorSubsystemVersion;</span><br><span class="line">    WORD    MinorSubsystemVersion;</span><br><span class="line">    DWORD   Win32VersionValue;</span><br><span class="line">    DWORD   SizeOfImage;</span><br><span class="line">    DWORD   SizeOfHeaders;</span><br><span class="line">    DWORD   CheckSum;</span><br><span class="line">    WORD    Subsystem;</span><br><span class="line">    WORD    DllCharacteristics;</span><br><span class="line">    DWORD   SizeOfStackReserve;</span><br><span class="line">    DWORD   SizeOfStackCommit;</span><br><span class="line">    DWORD   SizeOfHeapReserve;</span><br><span class="line">    DWORD   SizeOfHeapCommit;</span><br><span class="line">    DWORD   LoaderFlags;</span><br><span class="line">    DWORD   NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure></p>
<p>Magic：表示可选头的类型。</p>
<p>MajorLinkerVersion和MinorLinkerVersion：链接器的版本号。</p>
<p>SizeOfCode：代码段的长度，如果有多个代码段，则是代码段长度的总和。</p>
<p>SizeOfInitializedData：初始化的数据长度。</p>
<p>SizeOfUninitializedData：未初始化的数据长度。</p>
<p>AddressOfEntryPoint：程序入口的RVA，对于exe这个地址可以理解为WinMain的RVA。对于DLL，这个地址可以理解为DllMain的RVA，如果是驱动程序，可以理解为DriverEntry的RVA。当然，实际上入口点并非是WinMain，DllMain和DriverEntry，在这些函数之前还有一系列初始化要完成，当然，这些不是本文的重点。</p>
<p>BaseOfCode：代码段起始地址的RVA。</p>
<p>BaseOfData：数据段起始地址的RVA。</p>
<p>ImageBase：映象（加载到内存中的PE文件）的基地址，这个基地址是建议，对于DLL来说，如果无法加载到这个地址，系统会自动为其选择地址。</p>
<p>SectionAlignment：节对齐，PE中的节被加载到内存时会按照这个域指定的值来对齐，比如这个值是0x1000，那么每个节的起始地址的低12位都为0。</p>
<p>FileAlignment：节在文件中按此值对齐，SectionAlignment必须大于或等于FileAlignment。</p>
<p>MajorOperatingSystemVersion、MinorOperatingSystemVersion：所需操作系统的版本号，随着操作系统版本越来越多，这个好像不是那么重要了。</p>
<p>MajorImageVersion、MinorImageVersion：映象的版本号，这个是开发者自己指定的，由连接器填写。</p>
<p>MajorSubsystemVersion、MinorSubsystemVersion：所需子系统版本号。</p>
<p>Win32VersionValue：保留，必须为0。</p>
<p>SizeOfImage：映象的大小，PE文件加载到内存中空间是连续的，这个值指定占用虚拟空间的大小。</p>
<p>SizeOfHeaders：所有文件头（包括节表）的大小，这个值是以FileAlignment对齐的。</p>
<p>CheckSum：映象文件的校验和。</p>
<p>SizeOfStackReserve：运行时为每个线程栈保留内存的大小。</p>
<p>SizeOfStackCommit：运行时每个线程栈初始占用内存大小。</p>
<p>SizeOfHeapReserve：运行时为进程堆保留内存大小。</p>
<p>SizeOfHeapCommit：运行时进程堆初始占用内存大小。</p>
<p>LoaderFlags：保留，必须为0。</p>
<p>NumberOfRvaAndSizes：数据目录的项数，即下面这个数组的项数。</p>
<p>DataDirectory：数据目录，这是一个数组.</p>
<h2 id="PE文件结构详解（三）VA-RVA-FA的概念"><a href="#PE文件结构详解（三）VA-RVA-FA的概念" class="headerlink" title="PE文件结构详解（三）VA,RVA,FA的概念"></a>PE文件结构详解（三）VA,RVA,FA的概念</h2><h3 id="一丶VA概念"><a href="#一丶VA概念" class="headerlink" title="一丶VA概念"></a>一丶VA概念</h3><p>VA (virtual Address) 虚拟地址的意思 ,比如随便打开一个PE,找下它的虚拟地址<br><img src="3.png" alt=""></p>
<h3 id="二丶模块地址-image-Base"><a href="#二丶模块地址-image-Base" class="headerlink" title="二丶模块地址(image Base)"></a>二丶模块地址(image Base)</h3><p>模块地址,就是exe加载到内存的时候,所在的地址,</p>
<p>比如MZ位置,在那个位置,那么对应模块地址就是这个位置</p>
<p>在OD中的内存中查看就是PE头<br><img src="4.png" alt=""></p>
<h3 id="三丶RVA-relative-Virtual-Address-相对虚拟地址偏移"><a href="#三丶RVA-relative-Virtual-Address-相对虚拟地址偏移" class="headerlink" title="三丶RVA(relative Virtual Address) 相对虚拟地址偏移"></a>三丶RVA(relative Virtual Address) 相对虚拟地址偏移</h3><p>假设我们找一个虚拟地址</p>
<p>VA = 0X4001200   (虚拟地址)</p>
<p>那么算出他的相对偏移</p>
<p>那么我们就要看他属于内存中那个节区了<br><img src="5.png" alt=""><br>可以看出,是在401000 ~ 41500之间,那么我们就用401000即可.</p>
<p>RVA = VA - 401000  得出的就是相对于虚拟地址的偏移</p>
<p>简化</p>
<p>RVA = 401200 - 401000 = 200(RVA)  那么偏移就是200了</p>
<h3 id="四丶VAtoRaw-虚拟地址-转化为文件偏移位置-就是虚拟地址的代码-在文件那个偏移位置存储"><a href="#四丶VAtoRaw-虚拟地址-转化为文件偏移位置-就是虚拟地址的代码-在文件那个偏移位置存储" class="headerlink" title="四丶VAtoRaw(虚拟地址,转化为文件偏移位置,就是虚拟地址的代码,在文件那个偏移位置存储)"></a>四丶VAtoRaw(虚拟地址,转化为文件偏移位置,就是虚拟地址的代码,在文件那个偏移位置存储)</h3><p>首先你要明白 RVA 怎么计算,FA怎么看.</p>
<p>我们随便找一个PE文件<br><img src="6.png" alt=""><br>我要找40101A虚拟地址,在文件中的位置.</p>
<p>思路:<br>1.获得虚拟地址(VA)  现在是401013</p>
<p>2.查看属于哪个节区表(点击内存查看,OllyDbg)<br><img src="7.png" alt=""><br>大于401000,小于402000,所以节区属于代码区,也就是code这个区域<br>3.算出RVA(相对虚拟地址偏移)</p>
<p>RVA = VA - 内存中节区地址</p>
<p>代入得到:</p>
<p>RVA = 401013 - 401000 </p>
<p>RVA = 13   (相对虚拟地址偏移是13)<br>4.RVA + 文件中的(相同节表,比如上面是code,那么文件中看的节表就是code这个节表)节表中的PointerToRawData成员记录的大小 得出虚拟地址在文件中的偏移</p>
<p>13 + (文件中节表的偏移) = 实际虚拟地址在文件偏移记录的代码地址.</p>
<p>总结:</p>
<p>　　其实很简单,首先看属于哪个节表的,  那么先算出RVA的值,然后让RVA + 文件中相同节表中的成员(PointRawData)  那么最终就是虚拟地址代码,在文件偏移的位置.</p>
<p>举个例子</p>
<p>VA = 401456</p>
<p>RVA = 401456 - (.text的位置当然这个你得自己看,可能不是,这里默认是了)401000 = 456</p>
<p>FA = 456 + (文件中节表中的PointRawData,我假设是200,这里具体看PE中怎么存储的)200 = 656(十六进制)</p>
<p>那么这个656文件偏移处,记录的就是 虚拟地址(VA)401456的二进制代码.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/14/周报4-20/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/14/周报4-20/" itemprop="url">周报4.20</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-14T10:34:28+08:00">
                2019-04-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="OD学习记录"><a href="#OD学习记录" class="headerlink" title="OD学习记录"></a>OD学习记录</h1><h2 id="通常脱壳的基本步骤如下"><a href="#通常脱壳的基本步骤如下" class="headerlink" title="通常脱壳的基本步骤如下"></a>通常脱壳的基本步骤如下</h2><pre><code>1):寻找OEP
2):转储(PS:传说中的dump)
3):修复IAT(修复导入表)

4):检查目标程序是否存在AntiDump等阻止程序被转储的保护措施,并尝试修复这些问题。以上是脱壳的经典步骤,可能具体到不同的壳的话会有细微的差别。
</code></pre><h2 id="寻找简单壳"><a href="#寻找简单壳" class="headerlink" title="寻找简单壳"></a>寻找简单壳</h2><pre><code>搜索JMP或者CALL指令的机器码(即一步直达法,只适用于少数壳,包括UPX,ASPACK壳).
可以直接搜索长跳转JMP(0E9)或者CALL(0E8)这类长转移的机器码,一般情况下(理想情况)壳在解密完原程序各个区段以后,需要一个长JMP或者CALL跳转到原程序代码段中的OEP处开始执行原程序代码。

除了搜索JMP指令的机器码以外,还可以尝试搜索CALL EAX,CALL EBX,JMP EAX等指令的机器码,因为很多壳是将OEP的值存放在寄存器中,然后通过CALL 某寄存器或者JMP 某寄存器来跳往OEP的。
</code></pre><h2 id="定位OEP"><a href="#定位OEP" class="headerlink" title="定位OEP"></a>定位OEP</h2><pre><code>1).使用OllyDbg自带的功能定位OEP(SFX法)
2).使用Patch过的OD来定位OEP(即内存映像法)
3).堆栈平衡法(即ESP定律法) 适用于一些古老的壳
4).最后一次异常法 在脱壳的过程中发现目标程序产生大量异常的话,就可以使用最后一次异常法

5).利用壳最常用的API函数来定位OEP 壳最常用的API函数,比如GetProcAddress,LoadLibrary。ExitThread有些壳会用。

6).利用应用程序调用的第一个API函数来定位OEP  很多程序(VC++)一开始会调用GetVersion,GetModuleHandleA。
</code></pre><h2 id="什么是IAT？"><a href="#什么是IAT？" class="headerlink" title="什么是IAT？"></a>什么是IAT？</h2><pre><code>拿Cruehead的CrackMe中的MessageBoxA这个API函数来说吧,其入口地址为77D504EA,在我的机器上运行的很好,那些跟我操作系统版本以及User32.dll版本相同的童鞋的机器上该程序运行可能也很正常,但是如果在操作系统版本或者User32.dll的版本跟我的不同童鞋的机器上运行,可能就会出错。为了解决以上兼容问题,操作系统就必须提供一些措施来确保该CrackMe可以在其他版本的Windows操作系统,以及DLL版本下也能正常运行。这时IAT(Import Address Table:输入函数地址表)就应运而生了。
</code></pre><h2 id="手脱UPX-修复IAT"><a href="#手脱UPX-修复IAT" class="headerlink" title="手脱UPX 修复IAT"></a>手脱UPX 修复IAT</h2><pre><code>首先去定位OEP了，用的是加过壳的那个CrackMe的例子，刚好入口地址的函数是PUSHAD就F7单步执行 在寄存器中找到ESP 数据窗口跟随  设置硬件断点 F9运行 就会发现跳转的语句了call或者jmp语句 找到OEP之后 利用PE-TOOL　Dump程序 但是没有修复IAT所以并不能执行，用Import REConstructor修复 下来回到OD 找到IAT函数地址的跳转表 在数据窗口定位到IAT的地址 找到整个IAT的起始地址和终止地址 计算RVA起始地址-映像地址 计算IAT终止地址-起始地址 计算OEP虚拟地址-映像基质 输入到Import REConstructor 单击Get Imports看到Import REConstructor找到了IAT中的每项元素 然后就可以对之前DUMP出来的程序的IAT进行修复了 在用PE TOOL重建PE 之后的程序就可以正常运行啦 然后在OD里修改代码段的虚拟地址就和之前的程序一模一样啦。
</code></pre><h2 id="手脱ASPack"><a href="#手脱ASPack" class="headerlink" title="手脱ASPack"></a>手脱ASPack</h2><pre><code>前面都和UPX壳一样 难点就在IAT这里吧 这两个壳难点都在这里  找到IAT的起始地址和终止地址 题外话  回到正题 不同感觉在于修复IAT那里需要删除垃圾文件 删除完就一样欧克啦。
</code></pre><h2 id="IAT重定向"><a href="#IAT重定向" class="headerlink" title="IAT重定向"></a>IAT重定向</h2><pre><code>这里以telock这个壳为例子，首先还是找OEP  这个跟之前那两个有点不同的是虽是ESP定律 但不能用 说明壳可能有检测硬件断点的东东，然后我使用了OD自带的检测DEP的工具 在调试设置里找到了SFX选择块方式跟踪真正入口 就找到了OPE入口  这个程序的IAT被重新定义过了(这个程序和之前那个程序一样) 在反汇编窗口右键选择查看模块间所有函数调用 可以看到CALL被重新定义到了其他区段 但在里面仔细查看还是能找到直接调用的API函数的 右键跟随 然后找到跳转表 在数据窗口找到IAT 在定位IAT的起始和结束位置的时候,不仅仅要判断是否为系统DLL中的地址还是需要判断其是否为重定向过的地址。
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/10/4-13周记/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/10/4-13周记/" itemprop="url">4.13周ji</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-10T20:01:25+08:00">
                2019-04-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.前3天在南阳上和codevs刷题,大部分都是简单题，主要作用是回忆巩固一下c的知识哈哈哈。<br>2.od学习记录：    1.缓冲区返回的是FFFFFFFF的话表示当前程序正在被调试,如果返回的是0的话,表示当前程序没有被调试。<br>                2.SetUnhandledExceptionFilter：该函数的唯一一个参数为异常处理函数指针。<br>                当程序发生异常是,且程序不处于调试模式(在VS或者其他调试器里运行)则首先调用该异常处理函数。<br>                因此,程序可以主动抛出一个异常来判断当前程序是否正在被调试。<br>                3.UnhandledExceptionFilter：这个API函数用来检测当前程序是否正在被调试。<br>                4.POPAD指令,该指令是从堆栈中恢复各个寄存器的值。<br>                5.加过壳的程序执行的整个流程：    1.执行解压/解密例程<br>                                                2.解压/解密原程序的各个区段的数据<br>                                                3.跳往OEP处<br>                                                4.执行原程序代码<br>3.ACM比赛：算法大法好啊，真的好啊，刷题千千万，比赛照不会，今天比赛和队友总共做出来两题，得了铜奖。。没想到没想到。。<br>            算法体会：比较锻炼思维，对自己能力可以有很大的提升，也可让自己对c语言有很好的体会，更加深入了解c语言。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/01/周报4-6/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/01/周报4-6/" itemprop="url">周报4.6</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-01T16:36:46+08:00">
                2019-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.很多API函数,但都不是用于检测进程名的,可能这些重要的API函数被隐藏起来了,没有出现该列表中。<br>很显然如果程序不直接导入某些API的话,会使用GetProcAddress这个API 函数来获取这些API函数的地址进行间接调用。<br>使用GetProcAddress函数加载的一些API函数并不会出现该API函数列表中,我们给GetProcAddress设置一个断点，运行直到待获取的API是与检测进程名相关的为止。<br>GetModuleBaseNameA：该函数是获取指定进程模块的名称,lpBaseName这个参数是用来保存模块名称的缓冲区首地址。<br>2.算法题目练习，最近要参加校赛，在南阳acm上面刷题。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/31/周报3-31/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/31/周报3-31/" itemprop="url">周报3.31</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-31T10:05:38+08:00">
                2019-03-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.本周主要学习了od的使用以及课设内容的优化，课设有些小bug,不过最后也都改好了，od学习了消息断点 硬编码序列号寻踪  序列号生成算法分析。<br>2.windows窗口至少有一个消息循环，消息循环有特定的API函数构成，最常见的是GetMessage和DispatchMessage函数,有的消息循环也会用到其他的API函数。获取编辑框中文本我们通常使用的API是GetDlgItemTextA或者GetWindowTextA。<br>3.硬编码序列号就是不依赖于用户名来生成,总是由固定的字符和数字构成的固定不变的字符串。找到硬编码序列号再根据汇编代码，在不爆破的情况下找到程序的结果。<br>4.序列号生成算法分析：注册算法的原理是：软件或者用户自己触发了软件的注册模块软件跳转到注册认证模块。弹出注册窗口用户输入注册名＋注册码A，把它们存放在内存中。<br>                                        然后软件的注册码验证部分根据用户输入的注册名生成正确的注册码B并和用户输入的注册码A做对比。如果结果为相同则注册通过，并运行“注册成功”后面的程序分支，比如解除各种软件限制。<br>                                        如果不相同则提示“无效的注册码，请重新输入!”或者“Invalid key！”等等警告。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">loser</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">loser</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
