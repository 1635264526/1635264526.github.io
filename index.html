<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="chinese">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="loser的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="loser的博客">
<meta property="og:locale" content="chinese">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="loser的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>loser的博客</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="chinese">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">loser的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/26/TLS回调函数/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/26/TLS回调函数/" itemprop="url">TLS回调函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-26T17:11:45+08:00">
                2019-05-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="练习-1"><a href="#练习-1" class="headerlink" title="练习#1"></a>练习#1</h1><p>运行练习文件（HelloTls.exe）弹出消息框 单击 确定 结束程序</p>
<p><img src="1.png" alt=""><br>接下来使用OD打开程序并运行TLS文件 出现如图对话框</p>
<p><img src="2.png" alt=""><br>我们发现对话框与源程序的内容不同 单击 确定 终止程序 如图</p>
<p><img src="3.png" alt=""><br>出现这种情况的原因在于程序运行EP代码前先调用了TLS回调函数 而这一函数中含有反调试代码</p>
<h1 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h1><h2 id="IMAGE-DATA-DIRECTORY-9"><a href="#IMAGE-DATA-DIRECTORY-9" class="headerlink" title="IMAGE_DATA_DIRECTORY[9]"></a>IMAGE_DATA_DIRECTORY[9]</h2><p>如果在编程中用了TLS回调函数 PE头文件就会设置TLS表项目 如下图</p>
<p><img src="4.png" alt=""></p>
<h2 id="IMAGE-TLS-DIRECTORY"><a href="#IMAGE-TLS-DIRECTORY" class="headerlink" title="IMAGE_TLS_DIRECTORY"></a>IMAGE_TLS_DIRECTORY</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_DATA_DIRECTORY[9]:IMAGE_TLS_DIRECTOR</span><br><span class="line">Y</span><br><span class="line">typedef struct _IMAGE_TLS_DIRECTORY64 &#123;</span><br><span class="line">ULONGLONG StartAddressOfRawData;</span><br><span class="line">ULONGLONG EndAddressOfRawData;</span><br><span class="line">ULONGLONG AddressOfIndex; // PDWORD</span><br><span class="line">ULONGLONG AddressOfCallBacks; //</span><br><span class="line">PIMAGE_TLS_CALLBACK *;</span><br><span class="line">DWORD SizeOfZeroFill;</span><br><span class="line">DWORD Characteristics;</span><br><span class="line">&#125; IMAGE_TLS_DIRECTORY64;</span><br><span class="line">typedef IMAGE_TLS_DIRECTORY64*PIMAGE_TLS_DIRECTORY64;</span><br><span class="line"></span><br><span class="line">typedef struct_IMAGE_TLS_DIRECTORY32 &#123;</span><br><span class="line">DWORD StartAddressOfRawData;</span><br><span class="line">DWORD EndAddressOfRawData;</span><br><span class="line">DWORD AddressOfIndex; // PDWORD</span><br><span class="line">DWORD AddressOfCallBacks; //</span><br><span class="line">PIMAGE_TLS_CALLBACK *;</span><br><span class="line">DWORD SizeOfZeroFill;</span><br><span class="line">DWORD Characteristics;</span><br><span class="line">&#125; IMAGE_TLS_DIRECTORY32;</span><br><span class="line">typedef IMAGE_TLS_DIRECTORY32*PIMAGE_TLS_DIRECTORY32;</span><br><span class="line">#ifdef _WIN64</span><br><span class="line">typedef IMAGE_TLS_DIRECTORY64	IMAGE_TLS_DIRECTORY;</span><br><span class="line">typedef PIMAGE_TLS_DIRECTORY64	PIMAGE_TLS_DIRECTORY;</span><br><span class="line">#else</span><br><span class="line">typedef IMAGE_TLS_DIRECTORY32	IMAGE_TLS_DIRECTORY;</span><br><span class="line">typedef PIMAGE_TLS_DIRECTORY32	PIMAGE_TLS_DIRECTORY;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>IMAGE_TLS_DIRECTORY结构体有两种版本 分别为32位版本和64位版本 我们用PEView查看IMAGE_TLS_DIRECTORY结构体 成员如图</p>
<p><img src="5.png" alt=""><br>代码逆向中最重要的时Address of Callbacks 该值指向含有TLS回调函数地址的数组 这意味着可以向同一程序注册多个TLS回调函数</p>
<h2 id="回调函数地址数组"><a href="#回调函数地址数组" class="headerlink" title="回调函数地址数组"></a>回调函数地址数组</h2><p>回调函数地址数组<br><img src="6.png" alt=""><br>数组中实际储存的是TLS回调函数的地址 进程启动运行时 逐一调用储存在该数组的函数</p>
<h1 id="TLS回调函数"><a href="#TLS回调函数" class="headerlink" title="TLS回调函数"></a>TLS回调函数</h1><p>TLS(Thread Local Storage,线程局部储存)，主要用于给线程独立的传值，由于线程不拥有进程的资源，所以几个同一进程的几个线程需要独立赋值时的需要通过TLS技术。每个线程创建时都会分配一个index所以，这个索引index是全局变量，线程根据index来获取其他线程传过来的返回值。TLS有一个特点，就是它通常在程序EP前就要运行，所以起始TLS才是个程序真正的开始。利用这一特点，可以用来进行的程序的反调试。</p>
<p>创建和终止某线程时 TLS回调函数都会自动调用执行 前后共两次 执行EP代码前 TLS回调函数会先被执行 常用于反调试技术</p>
<h1 id="练习-2"><a href="#练习-2" class="headerlink" title="练习#2"></a>练习#2</h1><p>TlsTest.exe程序使用VC++编写的 充分展现了TLS回调函数的方法 源代码如图：</p>
<p><img src="7.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;windows.h&gt;</span><br><span class="line"></span><br><span class="line">#pragma comment(linker, &quot;/INCLUDE:__tls_used&quot;)</span><br><span class="line"></span><br><span class="line">void print_console(char* szMsg)</span><br><span class="line">&#123;</span><br><span class="line">    HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE);</span><br><span class="line">    </span><br><span class="line">    WriteConsoleA(hStdout, szMsg, strlen(szMsg), NULL, NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void NTAPI TLS_CALLBACK1(PVOID DllHandle, DWORD Reason, PVOID Reserved)</span><br><span class="line">&#123;</span><br><span class="line">    char szMsg[80] = &#123;0,&#125;;</span><br><span class="line">    wsprintfA(szMsg, &quot;TLS_CALLBACK1() : DllHandle = %X, Reason = %d\n&quot;,</span><br><span class="line">                DllHandle, Reason);</span><br><span class="line">    print_console(szMsg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void NTAPI TLS_CALLBACK2(PVOID DllHandle, DWORD Reason, PVOID Reserved)</span><br><span class="line">&#123;</span><br><span class="line">    char szMsg[80] = &#123;0,&#125;;</span><br><span class="line">    wsprintfA(szMsg, &quot;TLS_CALLBACK2() : DllHandle = %X, Reason = %d\n&quot;,</span><br><span class="line">                DllHandle, Reason);</span><br><span class="line">    print_console(szMsg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma data_seg(&quot;.CRT$XLX&quot;)</span><br><span class="line">    PIMAGE_TLS_CALLBACK pTLS_CALLBACKs[] = &#123;TLS_CALLBACK1, TLS_CALLBACK2, 0&#125;;</span><br><span class="line">#pragma data_seg()</span><br><span class="line"></span><br><span class="line">DWORD WINAPI ThreadProc(LPVOID lParam)</span><br><span class="line">&#123;</span><br><span class="line">    print_console(&quot;ThreadProc() start\n&quot;);</span><br><span class="line">    </span><br><span class="line">    print_console(&quot;ThreadProc() end\n&quot;);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    HANDLE hThread = NULL;</span><br><span class="line">    print_console(&quot;main() start\n&quot;);</span><br><span class="line">    </span><br><span class="line">    hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL);</span><br><span class="line">    WaitForSingleObject(hThread, 60*1000);</span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">    </span><br><span class="line">    print_console(&quot;main() end\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>TlsTest.cpp源代码中注册了2个TLS回调函数（TLS_CALLBACK1 TLS_CALLBACK2）他们也非常简单 只是将DllHandle与Reason这2个参数输出到控制台 然后终止退出 mian（）函数也是 创建用户线程（ThreadProc）后终止 main{}函数与ThreadProc（）内部分别将函数分开/终止日志输出到控制台 程序运行画面</p>
<p><img src="7.png" alt=""><br>接下来时各函数调用顺序</p>
<h2 id="DLL-PROCESS-ATTACH"><a href="#DLL-PROCESS-ATTACH" class="headerlink" title="DLL_PROCESS_ATTACH"></a>DLL_PROCESS_ATTACH</h2><p>进程的主线程调用main()函数前 已经注册的TLS回调函数（TLS_CALLBACK1 TLS_CALLBACK2）会先被执行 此时Reason的值为1（DLL_PROCESS_ATTACH）</p>
<h2 id="DLL-THREAD-ATTACH"><a href="#DLL-THREAD-ATTACH" class="headerlink" title="DLL_THREAD_ATTACH"></a>DLL_THREAD_ATTACH</h2><p>所有TLS回调函数完成调用后 mian（）函数开始执行 创建用户线程（ThreadProc）前 TLS回调函数会被再次执行 此时此时Reason的值为2（DLL_THREAD_ATTACH）</p>
<h2 id="DLL-THREAD-DETACH"><a href="#DLL-THREAD-DETACH" class="headerlink" title="DLL_THREAD_DETACH"></a>DLL_THREAD_DETACH</h2><p>TLS回调函数全部被执行完毕后 ThreadProc（）线程函数开始调用执行 执行完毕后Reason=3（DLL_THREAD_DETACH） TLS回调函数被调用执行</p>
<h2 id="DLL-PROCESS-DETACH"><a href="#DLL-PROCESS-DETACH" class="headerlink" title="DLL_PROCESS_DETACH"></a>DLL_PROCESS_DETACH</h2><p>ThreadProc（）线程函数执行完毕后 一直在等待线程终止的main（）函数也会终止 此时Reason的值为0（DLL_PROCESS_DETACH）TLS回调函数最后一次被调用执行 以上TlsTest.exe中 2个TLS回调函数分别被调用了4次 总共为8次 接下来看看调试方法</p>
<h1 id="调式TLS回调函数"><a href="#调式TLS回调函数" class="headerlink" title="调式TLS回调函数"></a>调式TLS回调函数</h1><p>若直接在调试器中打开有TLS回调函数的程序 则无法打开TLS函数 因为在EP代码执行之前就被调用执行了 使用特定插件存在一个“暂停在TLS回调函数”的选项 使用起来更加方便</p>
<p><img src="10.png" alt=""><br>这样就可以调试TLS回调函数了 这个函数很简单 运行的代码也不多</p>
<h1 id="手动添加TLS回调函数"><a href="#手动添加TLS回调函数" class="headerlink" title="手动添加TLS回调函数"></a>手动添加TLS回调函数</h1><p>首先确定IMAGE_TLS_DIRECTORY结构体与TLS回调函数要放在哪个位置 向某个PE文件添加代码或数据时 有3种方法</p>
<p>1）添加到节区末尾的空白区域<br>2）增加最后一个节区的大小<br>3）在最后添加新节区<br>这里我们采用第二种方法 使用PEView查看Hello.exe文件的最后一个节区（.rsrc）的节区头<br><img src="9.png" alt=""><br>可以看到最后一个节区（.rsrc）的Pointer to Raw Data=9000 Size of Raw Data=200 所以 PE头中定义的文件整体大小为9200 考虑到要添加代码和数据的大小 我们将最后一个节区的大小增加200 使用HXD工具打开文件 光标移至最后一个节区的菜单栏选择编辑-插入字节 如图所示 向字节数中输入200 单击ok后 就可以看到增加了200个字节<br><img src="10.png" alt=""><br><img src="11.png" alt=""></p>
<h2 id="编辑PE文件头"><a href="#编辑PE文件头" class="headerlink" title="编辑PE文件头"></a>编辑PE文件头</h2><h3 id="rsrc节区头"><a href="#rsrc节区头" class="headerlink" title=".rsrc节区头"></a>.rsrc节区头</h3><p>对比图9 分别修改.rsrc节区头中的Size of Raw Data和Characteristics的值 即Size of Raw Data=400 Characteristics=E0000060 如下图<br><img src="12.png" alt=""><br>Characteristics=E0000060的含义如图<br><img src="13.png" alt=""><br>在原有的属性上增加了这三个属性</p>
<h3 id="IMAGE-DATA-DIRECTORY-9-1"><a href="#IMAGE-DATA-DIRECTORY-9-1" class="headerlink" title="IMAGE_DATA_DIRECTORY[9]"></a>IMAGE_DATA_DIRECTORY[9]</h3><p>接下来设置TLS表（IMAGE_NT_HEADERS—IMAGE_OPTIONAL_HEADER—IMAGE_DATA_DIRECTORY[9]）的值 我们可以从图9中看到扩展程序的起始地址为9200（文件偏移） 在PEView在查看该地址为C200 我们将在该地址处创建IMAGE_TLS_DIRECTORY结构体 因此修改PE头中的IMAGE_DATA_DIRECTORY[9] 如图所示</p>
<p><img src="14.png" alt=""><br>完成后保存文件用PEView查看文件<br><img src="15.png" alt=""></p>
<h2 id="设置IMAGE-TLS-DIRECTORY结构体"><a href="#设置IMAGE-TLS-DIRECTORY结构体" class="headerlink" title="设置IMAGE_TLS_DIRECTORY结构体"></a>设置IMAGE_TLS_DIRECTORY结构体</h2><p>接下来设置IMAGE_TLS_DIRECTORY结构体 只要把TLS回调函数注册其中即可 编辑结构体<br><img src="16.png" alt=""><br>我们在文件偏移9200地址处创建了IMAGE_TLS_DIRECTORY结构体 AddressOfCallBacks成员的值为40c224 他是TLS回调函数数组的起始地址 只要把TLS回调函数的地址放入该数组 即可注册成功 使用PEView查看<br><img src="17.png" alt=""></p>
<h2 id="编写TLS回调函数"><a href="#编写TLS回调函数" class="headerlink" title="编写TLS回调函数"></a>编写TLS回调函数</h2><p>上述工作全部完成后 下来开始编写函数 我们在OD中编写如图代码 从40c230处开始<br><img src="18.png" alt=""><br>完成后保存修改都文件即可</p>
<h2 id="最终完成"><a href="#最终完成" class="headerlink" title="最终完成"></a>最终完成</h2><p>打开刚才的文件 就会发现已经ok了 表明已经成功（虽然我这个出了点小差错 但表明TLS回调函数添加成功了哈哈哈哈）<br><img src="19.png" alt=""><br>反正我成功了哈哈哈哈哈哈哈哈哈 我不管！！！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/26/内核6中的DLL注入/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/26/内核6中的DLL注入/" itemprop="url">内核6中的DLL注入</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-26T13:31:36+08:00">
                2019-05-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="再现DLL注入失败"><a href="#再现DLL注入失败" class="headerlink" title="再现DLL注入失败"></a>再现DLL注入失败</h1><p>尝试将Dummy.dll文件注入Windows7的系统时 会出现失败 接下来将再现</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">BOOL InjectDll(DWORD dwPID, LPCTSTR szDllPath)</span><br><span class="line">&#123;</span><br><span class="line">    HANDLE hProcess = NULL, hThread = NULL;</span><br><span class="line">    HMODULE hMod = NULL;</span><br><span class="line">    LPVOID pRemoteBuf = NULL;</span><br><span class="line">    DWORD dwBufSize = (DWORD)(_tcslen(szDllPath) + 1) * sizeof(TCHAR);</span><br><span class="line">    LPTHREAD_START_ROUTINE pThreadProc;</span><br><span class="line">    BOOL bRet = TRUE;</span><br><span class="line"></span><br><span class="line">    if ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) )</span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(L&quot;OpenProcess(%d) failed!!! [%d]\n&quot;, dwPID, GetLastError());</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pRemoteBuf = VirtualAllocEx(hProcess, NULL, dwBufSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">    WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, NULL);</span><br><span class="line"></span><br><span class="line">    hMod = GetModuleHandle(L&quot;kernel32.dll&quot;);</span><br><span class="line">    pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, &quot;LoadLibraryW&quot;);</span><br><span class="line">	</span><br><span class="line">    hThread = CreateRemoteThread(hProcess, NULL, 0, pThreadProc, pRemoteBuf, 0, NULL);</span><br><span class="line">    if( hThread == NULL )</span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(L&quot;[ERROR] CreateRemoteThread() failed!!! [%d]\n&quot;, GetLastError());</span><br><span class="line">        bRet = FALSE;</span><br><span class="line">        goto _ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WaitForSingleObject(hThread, INFINITE);	</span><br><span class="line"></span><br><span class="line">_ERROR:</span><br><span class="line">    </span><br><span class="line">    if( pRemoteBuf )</span><br><span class="line">        VirtualFreeEx(hProcess, pRemoteBuf, 0, MEM_RELEASE);</span><br><span class="line"></span><br><span class="line">    if( hThread )</span><br><span class="line">        CloseHandle(hThread);</span><br><span class="line"></span><br><span class="line">    if( hProcess )</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line"></span><br><span class="line">    return bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是典型的Dll注入代码 在之前已经分析过了<br><strong>Dummy.cpp</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;windows.h&quot;</span><br><span class="line">#include &quot;tchar.h&quot;</span><br><span class="line"></span><br><span class="line">BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span><br><span class="line">&#123;</span><br><span class="line">    TCHAR   szPath[MAX_PATH]    = &#123;0,&#125;;</span><br><span class="line">    TCHAR   szMsg[1024]         = &#123;0,&#125;;</span><br><span class="line">    TCHAR   *p                  = NULL;</span><br><span class="line"></span><br><span class="line">    switch( fdwReason )</span><br><span class="line">    &#123;</span><br><span class="line">        case DLL_PROCESS_ATTACH : </span><br><span class="line">            GetModuleFileName(NULL, szPath, MAX_PATH);</span><br><span class="line">            p = _tcsrchr(szPath, L&apos;\\&apos;);</span><br><span class="line">            if( p != NULL )</span><br><span class="line">            &#123;</span><br><span class="line">                _stprintf_s(szMsg, 1024 - sizeof(TCHAR), </span><br><span class="line">                            L&quot;Injected in %s(%d)&quot;, </span><br><span class="line">                            p + 1,                          // Process Name</span><br><span class="line">                            GetCurrentProcessId());         // PID</span><br><span class="line">                OutputDebugString(szMsg);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>DllMain()函数代码非常简单 若注入成功指定进程 就输出相关调试信息</p>
<h2 id="注入测试"><a href="#注入测试" class="headerlink" title="注入测试"></a>注入测试</h2><p>首先 运行procexp工具 查看目标进程的PID notepad的PID<br><img src="1.png" alt=""><br>然后分别使用InjectDll.exe分别向他们注入dummy.dll文件 注入前先把InjectDll.exe和dummy.dll复制到工作文件夹 使用下图命令注入dll<br><img src="2.png" alt=""><br>搜索dummy.dll<br><img src="3.png" alt=""></p>
<h1 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h1><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>我们向svchost.exe进程注入的过程中 调用CreateRemoteThread()API时失败了 错误代码为8 下面使用OD打开程序 在OPEN窗口中输入相应参数后打开<br><img src="4.png" alt=""><br>我们已经知道调用CreateRemoteThread()API时失败 所以我们直接在此API处设置断点<br><img src="5.png" alt=""><br>F9运行程序 停在断点处<br><img src="6.png" alt=""><br>F8单步执行几步 在OD中可以看到 这一串字符<br><img src="7.png" alt=""><br>我们从OD中看到了失败的情形 但仍然没有找到原因 </p>
<h2 id="调试-2"><a href="#调试-2" class="headerlink" title="调试#2"></a>调试#2</h2><p>重新运行OD 让代码停在CreateRemoteThread()API处<br><img src="6.png" alt=""><br>查看进程栈中的数据<br><img src="8.png" alt=""><br>F7进入函数查看到内部调用了CreateRemoteThreadEx()API函数 继续单步运行到函数里 运行到ZwCreatRemoteThreadEx()API代码处</p>
<p><img src="9.png" alt=""><br>我们继续跟踪进入该API函数 可以看到最终通过SYSENTER指令进入内核模式 无法继续用户模式调试<br><img src="10.png" alt=""><br>实际上 CreateRemoteThreadEx()API函数 ZwCreatRemoteThreadEx()API函数在Vista版本之前是不存在的 所以我们推测是由于系统新增的API导致的DLL注入失败</p>
<p>我们通过搜索发现 在Windows Vista以后的OS中进行DLL注入时 直接调用ZwCreatRemoteThreadEx()API函数而非CreateRemoteThread()API就能成功注入DLL</p>
<p>我们比较参数可以发现 ZwCreatRemoteThreadEx()API的第七个参数值时时白的原因所在</p>
<h1 id="稍作整理"><a href="#稍作整理" class="headerlink" title="稍作整理"></a>稍作整理</h1><p>在编写新的Dll注入程序前 先整理前面学过的内容 由于win7的会话管理机制发生了变化 CreateRemoteThread()API的内部实现代码发生了变化 最终使得注入的Dll无法发挥作用 原因在于 在APi内部创建远线程时采用了挂起模式 若远程进程属于会话0 则不会恢复运行 而是直接返回错误 **在reateRemoteThread()API内部调用ZwCreatRemoteThreadEx()API时 操作他的参数或者强制改变错误条件分支语句 就可以创建远程线程 成功注入DLL</p>
<h1 id="InjectDll-new-exe"><a href="#InjectDll-new-exe" class="headerlink" title="InjectDll_new.exe"></a>InjectDll_new.exe</h1><p>从前面我们知道 在win7中直接调用ZwCreatRemoteThreadEx()API要比CreateRemoteThread()API好得多 下面编写一个新的程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;windows.h&quot;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;tchar.h&quot;</span><br><span class="line"></span><br><span class="line">BOOL SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege) </span><br><span class="line">&#123;</span><br><span class="line">    TOKEN_PRIVILEGES tp;</span><br><span class="line">    HANDLE hToken;</span><br><span class="line">    LUID luid;</span><br><span class="line"></span><br><span class="line">    if( !OpenProcessToken(GetCurrentProcess(),</span><br><span class="line">                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, </span><br><span class="line">			              &amp;hToken) )</span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(L&quot;OpenProcessToken error: %u\n&quot;, GetLastError());</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if( !LookupPrivilegeValue(NULL,             // lookup privilege on local system</span><br><span class="line">                              lpszPrivilege,    // privilege to lookup </span><br><span class="line">                              &amp;luid) )          // receives LUID of privilege</span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(L&quot;LookupPrivilegeValue error: %u\n&quot;, GetLastError() ); </span><br><span class="line">        return FALSE; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tp.PrivilegeCount = 1;</span><br><span class="line">    tp.Privileges[0].Luid = luid;</span><br><span class="line">    if( bEnablePrivilege )</span><br><span class="line">        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">    else</span><br><span class="line">        tp.Privileges[0].Attributes = 0;</span><br><span class="line"></span><br><span class="line">    // Enable the privilege or disable all privileges.</span><br><span class="line">    if( !AdjustTokenPrivileges(hToken, </span><br><span class="line">                               FALSE, </span><br><span class="line">                               &amp;tp, </span><br><span class="line">                               sizeof(TOKEN_PRIVILEGES), </span><br><span class="line">                               (PTOKEN_PRIVILEGES) NULL, </span><br><span class="line">                               (PDWORD) NULL) )</span><br><span class="line">    &#123; </span><br><span class="line">        _tprintf(L&quot;AdjustTokenPrivileges error: %u\n&quot;, GetLastError() ); </span><br><span class="line">        return FALSE; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    if( GetLastError() == ERROR_NOT_ALL_ASSIGNED )</span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(L&quot;The token does not have the specified privilege. \n&quot;);</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef DWORD (WINAPI *PFNTCREATETHREADEX)</span><br><span class="line">( </span><br><span class="line">    PHANDLE                 ThreadHandle,	</span><br><span class="line">    ACCESS_MASK             DesiredAccess,	</span><br><span class="line">    LPVOID                  ObjectAttributes,	</span><br><span class="line">    HANDLE                  ProcessHandle,	</span><br><span class="line">    LPTHREAD_START_ROUTINE  lpStartAddress,	</span><br><span class="line">    LPVOID                  lpParameter,	</span><br><span class="line">    BOOL	                CreateSuspended,	</span><br><span class="line">    DWORD                   dwStackSize,	</span><br><span class="line">    DWORD                   dw1, </span><br><span class="line">    DWORD                   dw2, </span><br><span class="line">    LPVOID                  Unknown </span><br><span class="line">); </span><br><span class="line"></span><br><span class="line">BOOL IsVistaOrLater()</span><br><span class="line">&#123;</span><br><span class="line">    OSVERSIONINFO osvi;</span><br><span class="line"></span><br><span class="line">    ZeroMemory(&amp;osvi, sizeof(OSVERSIONINFO));</span><br><span class="line">    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);</span><br><span class="line"></span><br><span class="line">    GetVersionEx(&amp;osvi);</span><br><span class="line"></span><br><span class="line">    if( osvi.dwMajorVersion &gt;= 6 )</span><br><span class="line">        return TRUE;</span><br><span class="line"></span><br><span class="line">    return FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL MyCreateRemoteThread(HANDLE hProcess, LPTHREAD_START_ROUTINE pThreadProc, LPVOID pRemoteBuf)</span><br><span class="line">&#123;</span><br><span class="line">    HANDLE      hThread = NULL;</span><br><span class="line">    FARPROC     pFunc = NULL;</span><br><span class="line"></span><br><span class="line">    if( IsVistaOrLater() )    // Vista, 7, Server2008</span><br><span class="line">    &#123;</span><br><span class="line">        pFunc = GetProcAddress(GetModuleHandle(L&quot;ntdll.dll&quot;), &quot;NtCreateThreadEx&quot;);</span><br><span class="line">        if( pFunc == NULL )</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;MyCreateRemoteThread() : GetProcAddress(\&quot;NtCreateThreadEx\&quot;) failed!!! [%d]\n&quot;,</span><br><span class="line">                   GetLastError());</span><br><span class="line">            return FALSE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ((PFNTCREATETHREADEX)pFunc)(&amp;hThread,</span><br><span class="line">                                    0x1FFFFF,</span><br><span class="line">                                    NULL,</span><br><span class="line">                                    hProcess,</span><br><span class="line">                                    pThreadProc,</span><br><span class="line">                                    pRemoteBuf,</span><br><span class="line">                                    FALSE,</span><br><span class="line">                                    NULL,</span><br><span class="line">                                    NULL,</span><br><span class="line">                                    NULL,</span><br><span class="line">                                    NULL);</span><br><span class="line">        if( hThread == NULL )</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;MyCreateRemoteThread() : NtCreateThreadEx() failed!!! [%d]\n&quot;, GetLastError());</span><br><span class="line">            return FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else                    // 2000, XP, Server2003</span><br><span class="line">    &#123;</span><br><span class="line">        hThread = CreateRemoteThread(hProcess, </span><br><span class="line">                                     NULL, </span><br><span class="line">                                     0, </span><br><span class="line">                                     pThreadProc, </span><br><span class="line">                                     pRemoteBuf, </span><br><span class="line">                                     0, </span><br><span class="line">                                     NULL);</span><br><span class="line">        if( hThread == NULL )</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;MyCreateRemoteThread() : CreateRemoteThread() failed!!! [%d]\n&quot;, GetLastError());</span><br><span class="line">            return FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	if( WAIT_FAILED == WaitForSingleObject(hThread, INFINITE) )</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;MyCreateRemoteThread() : WaitForSingleObject() failed!!! [%d]\n&quot;, GetLastError());</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL InjectDll(DWORD dwPID, char *szDllName)</span><br><span class="line">&#123;</span><br><span class="line">    HANDLE hProcess = NULL;</span><br><span class="line">    LPVOID pRemoteBuf = NULL;</span><br><span class="line">    FARPROC pThreadProc = NULL;</span><br><span class="line">    DWORD dwBufSize = strlen(szDllName)+1;</span><br><span class="line"></span><br><span class="line">    if ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) )</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;[ERROR] OpenProcess(%d) failed!!! [%d]\n&quot;, </span><br><span class="line">        dwPID, GetLastError());</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pRemoteBuf = VirtualAllocEx(hProcess, NULL, dwBufSize, </span><br><span class="line">                                MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">    WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllName, </span><br><span class="line">                       dwBufSize, NULL);</span><br><span class="line"></span><br><span class="line">    pThreadProc = GetProcAddress(GetModuleHandle(L&quot;kernel32.dll&quot;), </span><br><span class="line">                                 &quot;LoadLibraryA&quot;);</span><br><span class="line"></span><br><span class="line">    if( !MyCreateRemoteThread(hProcess, (LPTHREAD_START_ROUTINE)pThreadProc, pRemoteBuf) )</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;[ERROR] MyCreateRemoteThread() failed!!!\n&quot;);</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    VirtualFreeEx(hProcess, pRemoteBuf, 0, MEM_RELEASE);</span><br><span class="line"></span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line"></span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	// adjust privilege</span><br><span class="line">    SetPrivilege(SE_DEBUG_NAME, TRUE);</span><br><span class="line"></span><br><span class="line">    // InjectDll.exe &lt;PID&gt; &lt;dll_path&gt;</span><br><span class="line">    if( argc != 3 )</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;usage : %s &lt;PID&gt; &lt;dll_path&gt;\n&quot;, argv[0]);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if( !InjectDll((DWORD)atoi(argv[1]), argv[2]) )</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;InjectDll() failed!!!\n&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;InjectDll() succeeded!!!\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个函数中变动的是 函数内部并没有直接调用CreateRemoteThread()API而是调用了为MyCreateRemoteThread()API的用户函数 在MyCreateRemoteThread()API函数内部先获取OS版本 若为Vista版本以上 则调用NtCreateThreadEx()API函数 反之 则调用CreateRemoteThread()API函数</p>
<h2 id="注入练习"><a href="#注入练习" class="headerlink" title="注入练习"></a>注入练习</h2><p>选择一个会话为0的服务进程练习<br><img src="11.png" alt=""><br>接下来运行命令<br><img src="12.png" alt=""><br>用procexp查看可以看到dll<br><img src="13.png" alt=""><br>这样就顺利向服务进程为0的会话中顺利注入DLL了</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/23/ASLR/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/23/ASLR/" itemprop="url">ASLR</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-23T20:08:14+08:00">
                2019-05-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>ASLR是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的的一种技术。</p>
<p>ASLR（Address space layout randomization）是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的。据研究表明ASLR可以有效的降低缓冲区溢出攻击的成功率，如今Linux、FreeBSD、Windows等主流操作系统都已采用了该技术。</p>
<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>用OD载入ASLR和ASLR_no两个程序<br><img src="1.png" alt=""><br><img src="8.png" alt=""><br>看起来基址不一样的 这就是ALSR文件的区别 每次载入都会改变基址 我们用PEView载入程序看看<br><img src="2.png" alt=""><br>节区信息<br>对于普通的EXE文件不存在.reloc文件 只有用了ASLR技术的应用才会有 被加载在内存时 被用作重定位的参考 它不是必须部分 可以删除 </p>
<p>再来看看这两部分 ASLR的characteristics属性字段并不存在这一段 因为ASLR.exe文件中多出来1个.reloc节区 所以Number of Sections值增1</p>
<p><img src="3.png" alt=""><br>ASLR文件的DLL Characteristics中设有这一段 这也就是ASLR文件的标志了<br><img src="4.png" alt=""></p>
<h1 id="删除ALSR功能"><a href="#删除ALSR功能" class="headerlink" title="删除ALSR功能"></a>删除ALSR功能</h1><p>我们使用Stud_PE工具修改ASLR.exe文件 载入可以看到应用的相关信息 并点击这里可以看到<br><img src="5.png" alt=""><br>我们找到DLL Characteristics的地方 并看到他在内存中的值 我们将属性值由8140改成8100 然后保存文件<br><img src="6.png" alt=""><br><img src="7.png" alt=""><br>再次载入ASLR文件 可以看到基址和ASLR_no文件一样了 这样就将文件删除ALSR功能了<br><img src="9.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/20/OD学习5-25/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/20/OD学习5-25/" itemprop="url">OD学习5-25</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-20T19:12:10+08:00">
                2019-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="高级全局API钩取：IE连接控制"><a href="#高级全局API钩取：IE连接控制" class="headerlink" title="高级全局API钩取：IE连接控制"></a>高级全局API钩取：IE连接控制</h1><h2 id="调试IE进程"><a href="#调试IE进程" class="headerlink" title="调试IE进程"></a>调试IE进程</h2><p>常见网络连接库：ws2_32.dll（套接字），wininet.dll，winhttp.dll</p>
<p>使用Process Explorer查看IE加载的DLL</p>
<p>IE不仅加载了ws2_32.dll还加载了wininet.dll，wininet.dll中提供的API中有个名为InternetConnect()的API，这个API用来连接网站</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HINTERNET InternetConnect(</span><br><span class="line">  _In_ HINTERNET     hInternet,</span><br><span class="line">  _In_ LPCTSTR       lpszServerName,</span><br><span class="line">  _In_ INTERNET_PORT nServerPort,</span><br><span class="line">  _In_ LPCTSTR       lpszUsername,</span><br><span class="line">  _In_ LPCTSTR       lpszPassword,</span><br><span class="line">  _In_ DWORD         dwService,</span><br><span class="line">  _In_ DWORD         dwFlags,</span><br><span class="line">  _In_ DWORD_PTR     dwContext</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>首先先打开IE浏览器 等待浏览器加载完：</p>
<p><img src="7.png" alt=""><br>然后打开OD附加进程 这里发现有两个IE的进程 随便加载一个都行</p>
<p><img src="8.png" alt=""><br>加载之后在反汇编窗口右击选择</p>
<p><img src="9.png" alt=""><br>接下来找到InternetConnectW()API函数</p>
<p><img src="10.png" alt=""><br>双击来到这里 设置断点</p>
<p><img src="11.png" alt=""><br>点击F9运行一次 然后在浏览器中输入网址</p>
<p><img src="12.png" alt=""><br>回车发现浏览器并没有跳转 OD处于暂停状态 右下角数据窗口是刚才输入的网址</p>
<p><img src="13.png" alt=""><br>下来在数据窗口跟随 发现网址后更改为另外一个网址</p>
<p><img src="14.png" alt=""><br>取消断点后F9运行程序<br><img src="15.png" alt=""><br>发现已经跳转到更改后的网址了 </p>
<h2 id="IE的进程结构"><a href="#IE的进程结构" class="headerlink" title="IE的进程结构"></a>IE的进程结构</h2><p>IE的每个选项卡对应一个进程，统一由一个父进程管理。所以钩取API时需要使用全局钩取。</p>
<p>这里通过钩取ntdll!ZwResumeThread钩取子进程</p>
<h2 id="全局钩取ntdll-ResumeThread-API"><a href="#全局钩取ntdll-ResumeThread-API" class="headerlink" title="全局钩取ntdll!ResumeThread API"></a>全局钩取ntdll!ResumeThread API</h2><p>因为最终目的是控制IE的网络连接，所以dll注入时仅需向所有的iexplore.exe进程中注入即可，无需对其他无关进程注入dll</p>
<p>我们首先想想创建子进程的API有哪些 创建进程API中最具代表性的绝对是kernel32！CreateProcess{}API 下面调试一个简单的程序来测试CreateProcess（）API ：</p>
<h3 id="cptest-exe"><a href="#cptest-exe" class="headerlink" title="cptest.exe"></a>cptest.exe</h3><p>用OD载入cptest程序 发现这个程序和载入ie程序的一样 反汇编窗口右击查找所有模块名称 然后进入kernel32！CreateProcessW() 发现在内部又调用了kernel32！CreateProcessInternelW()：</p>
<p><img src="16.png" alt=""><br>给kernel32！CreateProcessW()设置断点F9运行 接下来单步跟踪进入kernel32！CreateProcessInternelW()：</p>
<p><img src="17.png" alt=""><br>kernel32！CreateProcessInternelW()是一个相当大的函数 滚动条往下翻就会找到ntdll!ZwCreateUserProcess（） API：</p>
<p><img src="18.png" alt=""><br>查看图中栈中出现了字符串notepad.exe同时在数据窗口也可以看到</p>
<p><img src="19.png" alt=""><br>在process Explorer中可以看到notepad被暂时挂起 分配了PID却没有运行程序<br><img src="20.png" alt=""><br>在OD中继续单步运行程序 可以看到调用ntdll.ZwResumeThread（）API的代码<br><img src="21.png" alt=""><br>而ntdll.ZwResumeThread（）API函数就是用来恢复运行线程的 该线程是子进程（notepad.exe）的主进程 所以运行此代码时 子进程的EP代码才会执行 我们可以看见进程中的Suspended（挂起）已经不见了</p>
<p><img src="51.png" alt=""><br>综上所述 CreateProcessW（）API的调用流程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kernel32！CreateProcessW()</span><br><span class="line">	kernel32！CreateProcessInternelW()</span><br><span class="line">		ntdll!ZwCreateUserProcess（） //创建进程（主线程处于挂起状态）</span><br><span class="line">		ntdll.ZwResumeThread（）	//主线程被恢复运行（运行进程）</span><br></pre></td></tr></table></figure></p>
<p>创建子进程最后调用的是ntdll.ZwResumeThread（）API 所以钩取该API 在子进程的EP代码运行之前 拦截获取控制权 然后钩取指定API </p>
<p>前面的4个API都能实现实现我们的目标—全局API钩取</p>
<h2 id="控制IE浏览器"><a href="#控制IE浏览器" class="headerlink" title="控制IE浏览器"></a>控制IE浏览器</h2><h3 id="运行IE"><a href="#运行IE" class="headerlink" title="运行IE"></a>运行IE</h3><p>首先运行IE浏览器 然后使用process Explorer查看运行中的IE进程的结构</p>
<p>我们可以看到 IE进程以父子进程的形式进行 只要钩取夫进程的ntdll.ZwResumeThread（）API 那么后面的所有子进程都会被钩取</p>
<p><img src="52.png" alt=""></p>
<h3 id="注入DLL"><a href="#注入DLL" class="headerlink" title="注入DLL"></a>注入DLL</h3><p>使用如图InjDll.exe命令 将redirect.dll文件注入IE进程<br><img src="53.png" alt=""><br>查看DLL注入成功<br><img src="54.png" alt=""></p>
<h3 id="卸载DLL"><a href="#卸载DLL" class="headerlink" title="卸载DLL"></a>卸载DLL</h3><p>我们可以看到DLL已经卸载成功<br><img src="55.png" alt=""></p>
<h2 id="源代码分析"><a href="#源代码分析" class="headerlink" title="源代码分析"></a>源代码分析</h2><h3 id="DllMain"><a href="#DllMain" class="headerlink" title="DllMain"></a>DllMain</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span><br><span class="line">&#123;</span><br><span class="line">    char            szCurProc[MAX_PATH] = &#123;0,&#125;;</span><br><span class="line">    char            *p = NULL;</span><br><span class="line"></span><br><span class="line">    switch( fdwReason )</span><br><span class="line">    &#123;</span><br><span class="line">        case DLL_PROCESS_ATTACH : </span><br><span class="line">            DebugLog(&quot;DllMain() : DLL_PROCESS_ATTACH\n&quot;);</span><br><span class="line"></span><br><span class="line">            GetModuleFileNameA(NULL, szCurProc, MAX_PATH);</span><br><span class="line">            p = strrchr(szCurProc, &apos;\\&apos;);</span><br><span class="line">            if( (p != NULL) &amp;&amp; !_stricmp(p+1, &quot;iexplore.exe&quot;) )</span><br><span class="line">            &#123;</span><br><span class="line">                DebugLog(&quot;DllMain() : current process is [iexplore.exe]\n&quot;);</span><br><span class="line"></span><br><span class="line">                //为了防止在Dll注入时wininet.dll还未被加载，所以手动加载一下wininet.dll</span><br><span class="line">                if( NULL == LoadLibrary(L&quot;wininet.dll&quot;) )</span><br><span class="line">                &#123;</span><br><span class="line">                    DebugLog(&quot;DllMain() : LoadLibrary() failed!!! [%d]\n&quot;,</span><br><span class="line">                             GetLastError());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // hook</span><br><span class="line">            hook_by_code(&quot;ntdll.dll&quot;, &quot;ZwResumeThread&quot;, </span><br><span class="line">                         (PROC)NewZwResumeThread, g_pZWRT);</span><br><span class="line">            hook_by_code(&quot;wininet.dll&quot;, &quot;InternetConnectW&quot;, </span><br><span class="line">                         (PROC)NewInternetConnectW, g_pICW);</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case DLL_PROCESS_DETACH :</span><br><span class="line">            DebugLog(&quot;DllMain() : DLL_PROCESS_DETACH\n&quot;);</span><br><span class="line"></span><br><span class="line">            // unhook</span><br><span class="line">            unhook_by_code(&quot;ntdll.dll&quot;, &quot;ZwResumeThread&quot;, </span><br><span class="line">                           g_pZWRT);</span><br><span class="line">            unhook_by_code(&quot;wininet.dll&quot;, &quot;InternetConnectW&quot;, </span><br><span class="line">                           g_pICW);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数的核心功能是ZwResumeThread()和InternetConnectW()API的“挂钩/脱钩”功能 其中有条语句特别明显 若加载进程名为IE.exe时 则加载wininet.dll文件 这和全局API钩取的特性有关 钩取ZwResumeThread（）API时 需要在相关进程开始之前就获得拦截权 此时我们钩取的wininet.dll可能还未加载</p>
<h3 id="NewInternetConnectW"><a href="#NewInternetConnectW" class="headerlink" title="NewInternetConnectW"></a>NewInternetConnectW</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">HINTERNET WINAPI NewInternetConnectW</span><br><span class="line">(</span><br><span class="line">    HINTERNET hInternet,</span><br><span class="line">    LPCWSTR lpszServerName,</span><br><span class="line">    INTERNET_PORT nServerPort,</span><br><span class="line">    LPCTSTR lpszUsername,</span><br><span class="line">    LPCTSTR lpszPassword,</span><br><span class="line">    DWORD dwService,</span><br><span class="line">    DWORD dwFlags,</span><br><span class="line">    DWORD_PTR dwContext</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    HINTERNET hInt = NULL;</span><br><span class="line">    FARPROC pFunc = NULL;</span><br><span class="line">    HMODULE hMod = NULL;</span><br><span class="line"></span><br><span class="line">    // unhook</span><br><span class="line">    if( !unhook_by_code(&quot;wininet.dll&quot;, &quot;InternetConnectW&quot;, g_pICW) )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewInternetConnectW() : unhook_by_code() failed!!!\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // call original API</span><br><span class="line">    hMod = GetModuleHandle(L&quot;wininet.dll&quot;);</span><br><span class="line">    if( hMod == NULL )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewInternetConnectW() : GetModuleHandle() failed!!! [%d]\n&quot;,</span><br><span class="line">                  GetLastError());</span><br><span class="line">        goto __INTERNETCONNECT_EXIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pFunc = GetProcAddress(hMod, &quot;InternetConnectW&quot;);</span><br><span class="line">    if( pFunc == NULL )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewInternetConnectW() : GetProcAddress() failed!!! [%d]\n&quot;,</span><br><span class="line">                  GetLastError());</span><br><span class="line">        goto __INTERNETCONNECT_EXIT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //修改原API调用时的第二个参数</span><br><span class="line">    if( !_tcsicmp(lpszServerName, L&quot;www.naver.com&quot;) ||</span><br><span class="line">        !_tcsicmp(lpszServerName, L&quot;www.daum.net&quot;) ||</span><br><span class="line">        !_tcsicmp(lpszServerName, L&quot;www.nate.com&quot;) || </span><br><span class="line">        !_tcsicmp(lpszServerName, L&quot;www.yahoo.com&quot;) )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;[redirect] naver, daum, nate, yahoo =&gt; reversecore\n&quot;);</span><br><span class="line">        hInt = ((PFINTERNETCONNECTW)pFunc)(hInternet,</span><br><span class="line">                                           L&quot;www.reversecore.com&quot;,</span><br><span class="line">                                           nServerPort,</span><br><span class="line">                                           lpszUsername,</span><br><span class="line">                                           lpszPassword,</span><br><span class="line">                                           dwService,</span><br><span class="line">                                           dwFlags,</span><br><span class="line">                                           dwContext);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;[no redirect]\n&quot;);</span><br><span class="line">        hInt = ((PFINTERNETCONNECTW)pFunc)(hInternet,</span><br><span class="line">                                           lpszServerName,</span><br><span class="line">                                           nServerPort,</span><br><span class="line">                                           lpszUsername,</span><br><span class="line">                                           lpszPassword,</span><br><span class="line">                                           dwService,</span><br><span class="line">                                           dwFlags,</span><br><span class="line">                                           dwContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">__INTERNETCONNECT_EXIT:</span><br><span class="line"></span><br><span class="line">    // hook</span><br><span class="line">    if( !hook_by_code(&quot;wininet.dll&quot;, &quot;InternetConnectW&quot;, </span><br><span class="line">                      (PROC)NewInternetConnectW, g_pICW) )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewInternetConnectW() : hook_by_code() failed!!!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return hInt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InternetConnectW()的钩取函数为NewInternetConnectW()函数 他负责监视IE的连接地址 IE连接到特定网站时 将其转到我们的指定网站</p>
<h3 id="NewZwResumeThread"><a href="#NewZwResumeThread" class="headerlink" title="NewZwResumeThread"></a>NewZwResumeThread</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">//ThreadHandle是要恢复运行的线程的句柄(即子进程的主线程)</span><br><span class="line">NTSTATUS WINAPI NewZwResumeThread(HANDLE ThreadHandle, PULONG SuspendCount)</span><br><span class="line">&#123;</span><br><span class="line">    NTSTATUS status, statusThread;</span><br><span class="line">    FARPROC pFunc = NULL, pFuncThread = NULL;</span><br><span class="line">    DWORD dwPID = 0;</span><br><span class="line">    static DWORD dwPrevPID = 0;</span><br><span class="line">    THREAD_BASIC_INFORMATION tbi;</span><br><span class="line">    HMODULE hMod = NULL;</span><br><span class="line">    TCHAR szModPath[MAX_PATH] = &#123;0,&#125;;</span><br><span class="line"></span><br><span class="line">    DebugLog(&quot;NewZwResumeThread() : start!!!\n&quot;);</span><br><span class="line"></span><br><span class="line">    hMod = GetModuleHandle(L&quot;ntdll.dll&quot;);</span><br><span class="line">    if( hMod == NULL )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewZwResumeThread() : GetModuleHandle() failed!!! [%d]\n&quot;,</span><br><span class="line">                  GetLastError());</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 调用ntdll!ZwQueryInformationThread()，通过线程句柄获取其对应进程PID</span><br><span class="line">    pFuncThread = GetProcAddress(hMod, &quot;ZwQueryInformationThread&quot;);</span><br><span class="line">    if( pFuncThread == NULL )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewZwResumeThread() : GetProcAddress() failed!!! [%d]\n&quot;,</span><br><span class="line">                  GetLastError());</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    statusThread = ((PFZWQUERYINFORMATIONTHREAD)pFuncThread)</span><br><span class="line">                   (ThreadHandle, 0, &amp;tbi, sizeof(tbi), NULL);</span><br><span class="line">    if( statusThread != STATUS_SUCCESS )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewZwResumeThread() : pFuncThread() failed!!! [%d]\n&quot;, </span><br><span class="line">                 GetLastError());</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //子进程PID</span><br><span class="line">    dwPID = (DWORD)tbi.ClientId.UniqueProcess;</span><br><span class="line">    if ( (dwPID != GetCurrentProcessId()) &amp;&amp; (dwPID != dwPrevPID) )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewZwResumeThread() =&gt; call InjectDll()\n&quot;);</span><br><span class="line"></span><br><span class="line">        dwPrevPID = dwPID;</span><br><span class="line"></span><br><span class="line">        // change privilege</span><br><span class="line">        // 打开SeDebugPrivilege特权</span><br><span class="line">        if( !SetPrivilege(SE_DEBUG_NAME, TRUE) )</span><br><span class="line">            DebugLog(&quot;NewZwResumeThread() : SetPrivilege() failed!!!\n&quot;);</span><br><span class="line"></span><br><span class="line">        // 获取要注入的dll的路径</span><br><span class="line">        GetModuleFileName(GetModuleHandle(STR_MODULE_NAME), </span><br><span class="line">                          szModPath, </span><br><span class="line">                          MAX_PATH);</span><br><span class="line">        // 注入dll</span><br><span class="line">        if( !InjectDll(dwPID, szModPath) )</span><br><span class="line">            DebugLog(&quot;NewZwResumeThread() : InjectDll(%d) failed!!!\n&quot;, dwPID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // call ntdll!ZwResumeThread()</span><br><span class="line">    if( !unhook_by_code(&quot;ntdll.dll&quot;, &quot;ZwResumeThread&quot;, g_pZWRT) )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewZwResumeThread() : unhook_by_code() failed!!!\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pFunc = GetProcAddress(hMod, &quot;ZwResumeThread&quot;);</span><br><span class="line">    if( pFunc == NULL )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewZwResumeThread() : GetProcAddress() failed!!! [%d]\n&quot;,</span><br><span class="line">                  GetLastError());</span><br><span class="line">        goto __NTRESUMETHREAD_END;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = ((PFZWRESUMETHREAD)pFunc)(ThreadHandle, SuspendCount);</span><br><span class="line">    if( status != STATUS_SUCCESS )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewZwResumeThread() : pFunc() failed!!! [%d]\n&quot;, GetLastError());</span><br><span class="line">        goto __NTRESUMETHREAD_END;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">__NTRESUMETHREAD_END:</span><br><span class="line"></span><br><span class="line">    if( !hook_by_code(&quot;ntdll.dll&quot;, &quot;ZwResumeThread&quot;, </span><br><span class="line">                      (PROC)NewZwResumeThread, g_pZWRT) )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewZwResumeThread() : hook_by_code() failed!!!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DebugLog(&quot;NewZwResumeThread() : end!!!\n&quot;);</span><br><span class="line"></span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数负责对ntdll.ZwResumeThread（）API进行全局钩取</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/15/OD学习5-18/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/15/OD学习5-18/" itemprop="url">OD学习5-18</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-15T17:16:31+08:00">
                2019-05-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="计算器显示成文字"><a href="#计算器显示成文字" class="headerlink" title="计算器显示成文字"></a>计算器显示成文字</h1><h2 id="OD法更改"><a href="#OD法更改" class="headerlink" title="OD法更改"></a>OD法更改</h2><p>首先利用OD修改内存中的值来实现计算器显示中文数字（这次还是在XP虚拟机里运行的）</p>
<p>用OD打开calc.exe 快捷键ctrl+N查看目标文件的API函数 </p>
<p><img src="22.png" alt=""><br>这里我们发现的两个值得关注的API函数 SetWinsowTextW（）和SetDlgItemTextW（） 他们负责向计算器的文本显示框中显示文本 来看看SetWinsowTextW（）API定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOLSetWindowText(</span><br><span class="line">HWNDhwnd,</span><br><span class="line">LPCTSTRlpString</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>hWnd</strong><br>要改变文本内容的窗口或控件的句柄。不能改变在其他应用程序中的控件的文本内容，如果需要可以用另外一个SendMessage函数发送一条WM_SETTEXT消息。</p>
<p><strong>lpString</strong><br>指向一个空结束的字符串的指针，该字符串将作为窗口或控件的新文本。</p>
<p>这里我们关注第二个参考——字符串指针（lpString）钩取时查看字符串（lpString）中的内容 将其中的阿拉伯数字改成中文就行</p>
<p>然后在刚才关注的那两个API函数上设置断点<br><img src="23.png" alt=""><br>运行<br><img src="24.png" alt=""><br>第一次运行断在了SetwindowTextW这里 右下角堆栈窗口发现字符0就是计算器开始的在字符0<br><img src="25.png" alt=""><br>在运行断在了SetDlgItemTextW（）处 再次运行一下 计算器的页面出现了 为了继续调试 我们望计算器中输入7 发现OD自动在SetwindowTextW这里停了</p>
<p><img src="26.png" alt=""><br>看到了刚才说的那两个参数 在数据窗口跟随TEXT那一项发现了储存的数字7<br><img src="27.png" alt=""><br>将中文数字 七 的Unicode码（4e03）覆写到地址处 这里记得要逆序（034e）写入<br><img src="28.png" alt=""><br>发现数字7已经变成汉字七了！<br><img src="29.png" alt=""><br>运行程序在计算器中看到已经变了：<br><img src="30.png" alt=""><br>这里就算完成了OD的过程 对SetWinsowTextW（）API验证结束 接下来看看IAT钩取操作及其实现原理 </p>
<h2 id="IAT钩取工作原理"><a href="#IAT钩取工作原理" class="headerlink" title="IAT钩取工作原理"></a>IAT钩取工作原理</h2><p>IAT钩取通过修改IAT中保存的API地址来钩取某个API 如图：<br><img src="5.png" alt=""><br><img src="6.png" alt=""><br>钩取IAT前 首先向计算器进程注入hookiat.dll文件<br>原理：在保持运行代码不变的情况下 讲IAT中保存的API起始地址变为用户函数的起始地址</p>
<h2 id="练习示例"><a href="#练习示例" class="headerlink" title="练习示例"></a>练习示例</h2><p>先复制文件到工作目录（c:work）然后运行calc.exe程序 再打开任务管理器查看其PID 如图：<br><img src="31.png" alt=""><br>然后在命令窗口执行如图命令：<br><img src="32.png" alt=""><br>接下来在计算器随便输入一些数值 如图：<br><img src="33.png" alt=""><br>我们可以看到 输入的数值已经变成了中文 计算器也在正常运行（其实我自己调试的这个InjectDLL.exe注入的hookiat.dll注入之后计算器显示的是韩文 可能是韩国人整的DLL文件吧 但确实是钩取成功了！！）</p>
<h2 id="源代码分析（hookiat-dll）"><a href="#源代码分析（hookiat-dll）" class="headerlink" title="源代码分析（hookiat.dll）"></a>源代码分析（hookiat.dll）</h2><h3 id="Dllmain（）"><a href="#Dllmain（）" class="headerlink" title="Dllmain（）"></a>Dllmain（）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span><br><span class="line">&#123;</span><br><span class="line">	switch( fdwReason )</span><br><span class="line">	&#123;</span><br><span class="line">		case DLL_PROCESS_ATTACH : </span><br><span class="line">            // 保存原始API的地址</span><br><span class="line">           	g_pOrgFunc = GetProcAddress(GetModuleHandle(L&quot;user32.dll&quot;), </span><br><span class="line">                                        &quot;SetWindowTextW&quot;);</span><br><span class="line"> </span><br><span class="line">            // # hook</span><br><span class="line">            //   用hookiat.MySetWindowText钩取user32.SetWindowTextW</span><br><span class="line">			hook_iat(&quot;user32.dll&quot;, g_pOrgFunc, (PROC)MySetWindowTextW);</span><br><span class="line">			break;</span><br><span class="line"> </span><br><span class="line">		case DLL_PROCESS_DETACH :</span><br><span class="line">            // # unhook</span><br><span class="line">            //   将calc.exe的IAT恢复原值</span><br><span class="line">            hook_iat(&quot;user32.dll&quot;, (PROC)MySetWindowTextW, g_pOrgFunc);</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在DLL_PROCESS_ATTACH事件中先获取user32.SetWindowTextW的地址，然后保存到全局变量g_pOrgFunc中，后面脱钩会用到这个地址。</p>
<h3 id="MySetWindowTextW"><a href="#MySetWindowTextW" class="headerlink" title="MySetWindowTextW()"></a>MySetWindowTextW()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI MySetWindowTextW(HWND hWnd, LPWSTR lpString)</span><br><span class="line">&#123;</span><br><span class="line">    wchar_t* pNum = L&quot;零一二三四五六七八九&quot;;</span><br><span class="line">    wchar_t temp[2] = &#123;0,&#125;;</span><br><span class="line">    int i = 0, nLen = 0, nIndex = 0;</span><br><span class="line"> </span><br><span class="line">    nLen = wcslen(lpString);</span><br><span class="line">    for(i = 0; i &lt; nLen; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //   将阿拉伯数字转换为中文数字</span><br><span class="line">        //   lpString是宽字符版本(2个字节)字符串</span><br><span class="line">        if( L&apos;0&apos; &lt;= lpString[i] &amp;&amp; lpString[i] &lt;= L&apos;9&apos; )</span><br><span class="line">        &#123;</span><br><span class="line">            temp[0] = lpString[i];</span><br><span class="line">            nIndex = _wtoi(temp);</span><br><span class="line">            lpString[i] = pNum[nIndex];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //   调用user32.SetWindowTextW</span><br><span class="line">    //   (修改lpString缓冲区中的内容)</span><br><span class="line">    return ((PFSETWINDOWTEXTW)g_pOrgFunc)(hWnd, lpString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lpString参数是一块缓冲区，该缓冲区用来存放要输出显示的字符串。for循环将存放在lpString的阿拉伯数字字符串转换为中文数字字符串。for循环结束后，最后再调用函数指针g_pOrgFunc。</p>
<p>hook_iat()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">BOOL hook_iat(LPCSTR szDllName, PROC pfnOrg, PROC pfnNew)</span><br><span class="line">&#123;</span><br><span class="line">	HMODULE hMod;</span><br><span class="line">	LPCSTR szLibName;</span><br><span class="line">	PIMAGE_IMPORT_DESCRIPTOR pImportDesc; </span><br><span class="line">	PIMAGE_THUNK_DATA pThunk;</span><br><span class="line">	DWORD dwOldProtect, dwRVA;</span><br><span class="line">	PBYTE pAddr;</span><br><span class="line"> </span><br><span class="line">    // hMod, pAddr = ImageBase of calc.exe</span><br><span class="line">    //             = VA to MZ signature (IMAGE_DOS_HEADER)</span><br><span class="line">	hMod = GetModuleHandle(NULL);</span><br><span class="line">	pAddr = (PBYTE)hMod;</span><br><span class="line"> </span><br><span class="line">    // pAddr = VA to PE signature (IMAGE_NT_HEADERS)</span><br><span class="line">	pAddr += *((DWORD*)&amp;pAddr[0x3C]);</span><br><span class="line"> </span><br><span class="line">    // dwRVA = RVA to IMAGE_IMPORT_DESCRIPTOR Table</span><br><span class="line">	dwRVA = *((DWORD*)&amp;pAddr[0x80]);</span><br><span class="line"> </span><br><span class="line">    // pImportDesc = VA to IMAGE_IMPORT_DESCRIPTOR Table</span><br><span class="line">	pImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)hMod+dwRVA);</span><br><span class="line"> </span><br><span class="line">	for( ; pImportDesc-&gt;Name; pImportDesc++ )</span><br><span class="line">	&#123;</span><br><span class="line">        // szLibName = VA to IMAGE_IMPORT_DESCRIPTOR.Name</span><br><span class="line">		szLibName = (LPCSTR)((DWORD)hMod + pImportDesc-&gt;Name);</span><br><span class="line">		if( !_stricmp(szLibName, szDllName) )</span><br><span class="line">		&#123;</span><br><span class="line">            // pThunk = IMAGE_IMPORT_DESCRIPTOR.FirstThunk</span><br><span class="line">            //        = VA to IAT(Import Address Table)</span><br><span class="line">			pThunk = (PIMAGE_THUNK_DATA)((DWORD)hMod + </span><br><span class="line">                                         pImportDesc-&gt;FirstThunk);</span><br><span class="line"> </span><br><span class="line">            // pThunk-&gt;u1.Function = VA to API</span><br><span class="line">			for( ; pThunk-&gt;u1.Function; pThunk++ )</span><br><span class="line">			&#123;</span><br><span class="line">				if( pThunk-&gt;u1.Function == (DWORD)pfnOrg )</span><br><span class="line">				&#123;</span><br><span class="line">                </span><br><span class="line">					VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, </span><br><span class="line">                                   4, </span><br><span class="line">                                   PAGE_EXECUTE_READWRITE, </span><br><span class="line">                                   &amp;dwOldProtect);</span><br><span class="line"> </span><br><span class="line">                    pThunk-&gt;u1.Function = (DWORD)pfnNew;</span><br><span class="line">				</span><br><span class="line">                    VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, </span><br><span class="line">                                   4, </span><br><span class="line">                                   dwOldProtect, </span><br><span class="line">                                   &amp;dwOldProtect);						</span><br><span class="line"> </span><br><span class="line">					return TRUE;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	return FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数主要负责钩取API</p>
<p>首先从ImageBase开始经由PE签名找到IDT<br><img src="34.png" alt=""><br><img src="35.png" alt=""><br><img src="36.png" alt=""><br>pImportDesc变量中存储着IMAGE_IMPORT_DESCRIPTOR结构体的起始地址，后者是calc.exe进程IDT的第一个结构体。IDT是由IMAGE_IMPORT_DESCRIPTOR结构体组成的数组。若想查找到IAT，先要查找到这个位置。使用PEView查看该地址(00012B80+01000000=01012B80)，如图所示。</p>
<p><img src="37.png" alt=""><br>在for循环中通过比较查找到user32.dll的IMAGE_IMPORT_DESCRIPTOR结构体地址，从上图可以看出最终pImportDesc的值为01012BF4。接下来进入user32的IAT，pImportDesc-&gt;FirstThunk成员所指的就是IAT。使用PEView查看该地址(000010A4+01000000=010010A4)，如图所示</p>
<p><img src="38.png" alt=""><br>接下来又在for循环中查找SetWindowTextW的IAT地址(01001110)，然后修改它的值。因为计算器进程的IAT内存区域是只读的，所以需要使用VirtualProtect在钩取之前将相应的区域改为可读写的，钩取之后再改回来。</p>
<h1 id="调试被注入的DLL文件"><a href="#调试被注入的DLL文件" class="headerlink" title="调试被注入的DLL文件"></a>调试被注入的DLL文件</h1><p>首先运行calc程序 查看其PID的值<br><img src="39.png" alt=""><br>将程序进程附加到OD中 然后在事件中选定中断于新DLL进程 然后将hookiat.dll注入计算器进程<br><img src="41.png" alt=""><br>运行程序发现：<br><img src="40.png" alt=""><br>双击进入hookiat.dll中 接下来取消刚才事件中的中断于新DLL的选项 然后在hookiat模块查找参考字符串寻找DllMain（）代码 当然也可以F7单步跟踪查找 DllMain()函数中使用的字符串有“user32.dll”和“SetWindowTextW”</p>
<p><img src="42.png" alt=""><br>我们发现“user32.dll”有两处“SetWindowTextW”有一处 转到“SetWindowTextW”处：</p>
<p><img src="43.png" alt=""><br>框出来的内容就是DllMain（）函数了</p>
<p>这就是调试注入进程Dll的方法了</p>
<h2 id="Dllmain（）-1"><a href="#Dllmain（）-1" class="headerlink" title="Dllmain（）"></a>Dllmain（）</h2><p><img src="44.png" alt=""><br>这个call语句就是调用hook_iat()<br>步入刚才那个call语句进入hook_iat()</p>
<h2 id="hook-iat"><a href="#hook-iat" class="headerlink" title="hook_iat()"></a>hook_iat()</h2><h3 id="查找IMAGE-IMPORT-DESCRIPTION-Table"><a href="#查找IMAGE-IMPORT-DESCRIPTION-Table" class="headerlink" title="查找IMAGE_IMPORT_DESCRIPTION Table"></a>查找IMAGE_IMPORT_DESCRIPTION Table</h3><p>hook_iat()是负责具体实施IAT钩取的核心函数 下面是调试一下：<br><img src="45.png" alt=""><br>框起来的部分就是IMAGE_IMPORT_DESCRIPTION Table（下面简称“IID Table”）的过程 一时难分代码仅仅用了4行代码就找到了ID Table</p>
<p><img src="46.png" alt=""><br>这个call指令用于调用stricmp（）函数。</p>
<h3 id="在IAT中查找SetWindowTextW-API位置"><a href="#在IAT中查找SetWindowTextW-API位置" class="headerlink" title="在IAT中查找SetWindowTextW API位置"></a>在IAT中查找SetWindowTextW API位置</h3><p>通过便利IID Table比较IID.Name于“user32.dll”字符串 查找到user32.dll的IID  找到之后 下面代码用来查找SetWindowTextW API位置 然后修改其中内容 从而实现对API的钩取</p>
<p><img src="47.png" alt=""><br>cmp语句中ESI的值为user32.dll的IAT起始地址 EBP的值为SetWindowTextW的地址 代码循环进入IAT SetWindowTextW的地址值（ebp的值）</p>
<h3 id="IAT钩取"><a href="#IAT钩取" class="headerlink" title="IAT钩取"></a>IAT钩取</h3><p>IAT钩取代码<br><img src="48.png" alt=""><br>MOV指令用来将MySetWindowTextW的地址覆写到前面从IAT中获取的SetWindowTextW的地址 执行后就变成了执行MySetWindowTextW地址的代码 也就是将数字变成汉字的代码段</p>
<h1 id="隐藏进程"><a href="#隐藏进程" class="headerlink" title="隐藏进程"></a>隐藏进程</h1><h2 id="API代码修改技术的原理"><a href="#API代码修改技术的原理" class="headerlink" title="API代码修改技术的原理"></a>API代码修改技术的原理</h2><p>IAT钩取通过操作进程的特定IAT值来实现API钩取 而API代码修改技术则将API代码的前5个字节修改为JMP XXXXXXXXXX指令来钩取API 调用执行被钩取的API时 JMP XXXXXXXXX就会被执行 转而控制hooking函数 后面描述的是 向process explorer进程（procexp.exe）注入stealth.dll文件后钩取ntdll.ZwQuery-SystemInformation（）API的整个过程（ntdll.ZwQuery-SystemInformation（）API是为了隐藏进程而需要钩取的API）</p>
<h3 id="注入之前"><a href="#注入之前" class="headerlink" title="注入之前"></a>注入之前</h3><p>首先看一下钩取之前正常调用API的进程内存。下图描述的是( 钩取之前)正常调用API的情形<br><img src="49.png" alt=""><br>procexp.exe代码调用ntdll.ZwQuerySystemInformation) API时，程序执行流顺序如下。</p>
<p>①procexp.exe的00422CF7地址处的CALL DWORD PTR DS:[48C69C]指令调 用ntdll.ZwQuerySystemInformation( API ( 48C69C地址在进程的IAT区域中，其值为7C93D92E，它是ntdll.ZwQuerySystemInformation() API的起始地址)。</p>
<p>②相应API执行完毕后，返回到调用代码的下一条指令的地址处。</p>
<h3 id="注入之后"><a href="#注入之后" class="headerlink" title="注入之后"></a>注入之后</h3><p>下面看看钩取指定API后程序执行的过程。先把stealth.dll注人目标进程( procexp.exe),直接修改ntdll.ZwQuerySystemInformation( API的代码( Code Patch ),如图所示。<br><img src="50.png" alt=""><br> 首先把stealth.dll注人目标进程，钩取ntll.ZwQuerySystemInformation( API。ntdll.ZwQuery-SystemInformation(O) API起始地址( 7C93D92E)的5个字节代码被修改为JMP 10001120 (仅修改5个字节代码)。10001 120是stealth.MyZwQuerySystemInformation(函数的地址。此时,在procexp.exe代码中调用ntdll.ZwQuerySystemInformation( API,程序将按如下顺序执行</p>
<p>①在422CF7地址处调用ntdll.ZwQuerySystemInformation() API ( 7C93D92E )。</p>
<p>②位于7C93D92E地址处的( 修改后的) JMP 10001 120指令将执行流转到10001120地址处( hooking函数)。10001 16A地址处的CALL unhook()指令用来将ntdll.ZwQuerySystemInformation(API的起始5个字节恢复原值。</p>
<p>③位于1000119B地址处的CALL EAX(7C93D92E)指令将调用原来的函数（ntdll.ZwQuery-SystemlnformationOAPI)(由于前面已经“脱钩”，所以可以正常调用执行）。</p>
<p>④ntdll.ZwQuerySystemlnformation（）执行完毕后，由7C93D93A地址处的RETN 10指令返回到 stealth.dll代码区域（调用自身的位置）。然后10001212地址处的CALL hook()指令再次钩取 ntdll.ZwQuerySystemlnformation（）API(即将开始的5字节修改为JMP10001120指令）</p>
<p>⑤stealth.MyZwQuerySystemInformation(函数执行完毕后，由10001233地址处的RETN 10命令返回到procexp.exe进程的代码区域，继续执行。</p>
<p>上述过程刚开始看似很难，多看几遍，慢慢就会明白的。<br>使用API代码修改技术的好处是可以钩取进程中使用的任意API。前面讲过的IAT钩取技术仅适用于可钩取的API,而API代码修改技术无此限制，(虽然代码会更复杂一些)使用起来要自由得多。使用API代码修改技术的唯- -限制是， 要钩取的API代码长度要大于5个字节，但是由于所有API代码长度都大于5个字节 所以事实上这个限制是不存在的</p>
<h2 id="练习（HideProc-exe，stealth-dll）"><a href="#练习（HideProc-exe，stealth-dll）" class="headerlink" title="练习（HideProc.exe，stealth.dll）"></a>练习（HideProc.exe，stealth.dll）</h2><p>HideProc exe负责将stealth.dll文件注人所有运行中的进程。Stealth.dll负责钩取(注人stealth.dll文件的)进程的ntdll.ZwQuerySystemInformation() API。接下来我们使用上面2个文件隐藏notepad.exe进程。<br><img src="2.png" alt=""></p>
<h3 id="运行notepad-exe-procexp-exe-taskmgr-exe"><a href="#运行notepad-exe-procexp-exe-taskmgr-exe" class="headerlink" title="运行notepad.exe procexp.exe taskmgr.exe"></a>运行notepad.exe procexp.exe taskmgr.exe</h3><p>首先运行要隐藏的进程notepad.exe(要隐藏的进程) procexp.exe（钩取对象1） taskmgr.exe（钩取对象2）</p>
<h3 id="运行HideProc-exe"><a href="#运行HideProc-exe" class="headerlink" title="运行HideProc.exe"></a>运行HideProc.exe</h3><p>运行HideProc.exe 将stealth.dll文件注入当前运行的所有程序：<br><img src="1.png" alt=""><br>简要介绍一下HideProc.exe命令的几个参数:<br>-hide/-show: -hide 用于隐藏，-show 用于取消隐藏。<br>process name:要隐藏的进程名称。<br>dllpath:要注入的DLL文件路径。</p>
<h3 id="查看进程是否隐藏成功"><a href="#查看进程是否隐藏成功" class="headerlink" title="查看进程是否隐藏成功"></a>查看进程是否隐藏成功</h3><p><img src="3.png" alt=""><br>我们发现任务管理器中的进程已经消失了 可是程序依然在运行 这就证明注入成功了</p>
<h3 id="取消进程隐藏"><a href="#取消进程隐藏" class="headerlink" title="取消进程隐藏"></a>取消进程隐藏</h3><p><img src="4.png" alt=""><br>我们可以发现在procexp.exe taskmgr.exe又能看到进程了</p>
<h2 id="源代码分析"><a href="#源代码分析" class="headerlink" title="源代码分析"></a>源代码分析</h2><h3 id="HideProc-cpp"><a href="#HideProc-cpp" class="headerlink" title="HideProc.cpp"></a>HideProc.cpp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">BOOL InjectAllProcess(int nMode, LPCTSTR szDllPath)</span><br><span class="line">&#123;</span><br><span class="line">	DWORD                   dwPID = 0;</span><br><span class="line">	HANDLE                  hSnapShot = INVALID_HANDLE_VALUE;</span><br><span class="line">	PROCESSENTRY32          pe;</span><br><span class="line"> </span><br><span class="line">	// Get the snapshot of the system</span><br><span class="line">	pe.dwSize = sizeof( PROCESSENTRY32 );</span><br><span class="line">	hSnapShot = CreateToolhelp32Snapshot( TH32CS_SNAPALL, NULL );</span><br><span class="line"> </span><br><span class="line">	// find process</span><br><span class="line">	Process32First(hSnapShot, &amp;pe);</span><br><span class="line">	do</span><br><span class="line">	&#123;</span><br><span class="line">		dwPID = pe.th32ProcessID;</span><br><span class="line"> </span><br><span class="line">        // 鉴于系统安全性的考虑</span><br><span class="line">        // 对于PID小于100的系统进程</span><br><span class="line">        // 不执行DLL注入操作</span><br><span class="line">		if( dwPID &lt; 100 )</span><br><span class="line">			continue;</span><br><span class="line"> </span><br><span class="line">        if( nMode == INJECTION_MODE )</span><br><span class="line">		    InjectDll(dwPID, szDllPath);</span><br><span class="line">        else</span><br><span class="line">            EjectDll(dwPID, szDllPath);</span><br><span class="line">	&#125;</span><br><span class="line">	while( Process32Next(hSnapShot, &amp;pe) );</span><br><span class="line"> </span><br><span class="line">	CloseHandle(hSnapShot);</span><br><span class="line"> </span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先通过SetPrivilege函数调用AdjustTokenPrivileges提升权限，然后在InjectAllProcess中使用CreateToolhelp32Snapshot获取系统中运行的所有进程的列表，使用Process32First与Process32Next将获得的进程信息存放到PROCESSENTRY32结构体变量pe中，进而获取进程的PID。获取了进程的PID后，要根据所用的命令选项来选择调用InjectDll函数还是EjectDll函数。当某进程的PID小于100时，鉴于系统安全性的考虑，忽略对它的操作。</p>
<h3 id="Stealth-dll"><a href="#Stealth-dll" class="headerlink" title="Stealth.dll"></a>Stealth.dll</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// global variable (in sharing memory)</span><br><span class="line">#pragma comment(linker, &quot;/SECTION:.SHARE,RWS&quot;)</span><br><span class="line">#pragma data_seg(&quot;.SHARE&quot;)</span><br><span class="line">    TCHAR g_szProcName[MAX_PATH] = &#123;0,&#125;;</span><br><span class="line">#pragma data_seg()</span><br><span class="line"> </span><br><span class="line">// export function</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line">__declspec(dllexport) void SetProcName(LPCTSTR szProcName)</span><br><span class="line">&#123;</span><br><span class="line">    _tcscpy_s(g_szProcName, szProcName);</span><br><span class="line">&#125;</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>首先看导出函数SetProcName。先创建名为.SHARE的共享内存节区，然后创建g_szProcName缓冲区，最后再由导出函数SetProcName将要隐藏的进程名称保存到g_szProcName中。</p>
<h3 id="DllMain"><a href="#DllMain" class="headerlink" title="DllMain()"></a>DllMain()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span><br><span class="line">&#123;</span><br><span class="line">    char            szCurProc[MAX_PATH] = &#123;0,&#125;;</span><br><span class="line">    char            *p = NULL;</span><br><span class="line"> </span><br><span class="line">    // #1. 异常处理</span><br><span class="line">    // 若当前进程为HookProc.exe则终止，不进行钩取操作</span><br><span class="line">    GetModuleFileNameA(NULL, szCurProc, MAX_PATH);</span><br><span class="line">    p = strrchr(szCurProc, &apos;\\&apos;);</span><br><span class="line">    if( (p != NULL) &amp;&amp; !_stricmp(p+1, &quot;HideProc.exe&quot;) )</span><br><span class="line">        return TRUE;</span><br><span class="line"> </span><br><span class="line">    switch( fdwReason )</span><br><span class="line">    &#123;</span><br><span class="line">        // #2. API Hooking</span><br><span class="line">        case DLL_PROCESS_ATTACH : </span><br><span class="line">        hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, </span><br><span class="line">                     (PROC)NewZwQuerySystemInformation, g_pOrgBytes);</span><br><span class="line">        break;</span><br><span class="line"> </span><br><span class="line">        // #3. API Unhooking </span><br><span class="line">        case DLL_PROCESS_DETACH :</span><br><span class="line">        unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, </span><br><span class="line">                       g_pOrgBytes);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先比较字符串，若进程名为HideProc.exe则不钩取API。发生DLL_PROCESS_ATTACH事件时，调用hook_by_code函数钩取API；发生DLL_PROCESS_DETACH事件时，调用unhook_by_code函数取消API钩取。</p>
<h3 id="hook-by-code"><a href="#hook-by-code" class="headerlink" title="hook_by_code()"></a>hook_by_code()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">BOOL hook_by_code(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew, PBYTE pOrgBytes)</span><br><span class="line">&#123;</span><br><span class="line">    FARPROC pfnOrg;</span><br><span class="line">    DWORD dwOldProtect, dwAddress;</span><br><span class="line">    BYTE pBuf[5] = &#123;0xE9, 0, &#125;;</span><br><span class="line">    PBYTE pByte;</span><br><span class="line"> </span><br><span class="line">    // 获取要钩取的API地址</span><br><span class="line">    pfnOrg = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">    pByte = (PBYTE)pfnOrg;</span><br><span class="line"> </span><br><span class="line">    // 若已经被钩取则返回FALSE</span><br><span class="line">    if( pByte[0] == 0xE9 )</span><br><span class="line">        return FALSE;</span><br><span class="line"> </span><br><span class="line">    // 向内存添加写属性</span><br><span class="line">    VirtualProtect((LPVOID)pfnOrg, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"> </span><br><span class="line">    // 备份原有代码(5字节)</span><br><span class="line">    memcpy(pOrgBytes, pfnOrg, 5);</span><br><span class="line"> </span><br><span class="line">    // 计算JMP地址 (E9 XXXX)</span><br><span class="line">    // =&gt; XXXX = pfnNew - pfnOrg - 5</span><br><span class="line">    dwAddress = (DWORD)pfnNew - (DWORD)pfnOrg - 5;</span><br><span class="line">    memcpy(&amp;pBuf[1], &amp;dwAddress, 4);</span><br><span class="line"> </span><br><span class="line">    // Hook:修改5 byte(JMP XXXX)</span><br><span class="line">    memcpy(pfnOrg, pBuf, 5);</span><br><span class="line"> </span><br><span class="line">    // 恢复内存属性</span><br><span class="line">    VirtualProtect((LPVOID)pfnOrg, 5, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">    </span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它通过修改代码实现API钩取操作。JMP指令的实际形式为E9 XXXXXXXX，XXXXXXXX=要跳转的地址-当前指令地址-当前指令长度(5)。</p>
<h3 id="unhook-by-code"><a href="#unhook-by-code" class="headerlink" title="unhook_by_code()"></a>unhook_by_code()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">BOOL unhook_by_code(LPCSTR szDllName, LPCSTR szFuncName, PBYTE pOrgBytes)</span><br><span class="line">&#123;</span><br><span class="line">    FARPROC pFunc;</span><br><span class="line">    DWORD dwOldProtect;</span><br><span class="line">    PBYTE pByte;</span><br><span class="line"> </span><br><span class="line">    // 获取API地址</span><br><span class="line">    pFunc = GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">    pByte = (PBYTE)pFunc;</span><br><span class="line"> </span><br><span class="line">    // 若已经脱钩则返回FALSE</span><br><span class="line">    if( pByte[0] != 0xE9 )</span><br><span class="line">        return FALSE;</span><br><span class="line"> </span><br><span class="line">    // 向内存添加写属性</span><br><span class="line">    VirtualProtect((LPVOID)pFunc, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"> </span><br><span class="line">    // Unhook</span><br><span class="line">    memcpy(pFunc, pOrgBytes, 5);</span><br><span class="line"> </span><br><span class="line">    // 恢复内存属性</span><br><span class="line">    VirtualProtect((LPVOID)pFunc, 5, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"> </span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>unhook_by_code函数是用来取消钩取的函数，原理就是将函数代码开始的前5个字节恢复原值</p>
<h3 id="NewZwQuerySystemInformation（）"><a href="#NewZwQuerySystemInformation（）" class="headerlink" title="NewZwQuerySystemInformation（）"></a>NewZwQuerySystemInformation（）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS WINAPI NewZwQuerySystemInformation(</span><br><span class="line">                SYSTEM_INFORMATION_CLASS SystemInformationClass, </span><br><span class="line">                PVOID SystemInformation, </span><br><span class="line">                ULONG SystemInformationLength, </span><br><span class="line">                PULONG ReturnLength)</span><br><span class="line">&#123;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    FARPROC pFunc;</span><br><span class="line">    PSYSTEM_PROCESS_INFORMATION pCur, pPrev;</span><br><span class="line">    char szProcName[MAX_PATH] = &#123;0,&#125;;</span><br><span class="line">    </span><br><span class="line">    // 开始前先脱钩</span><br><span class="line">    unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, g_pOrgBytes);</span><br><span class="line"> </span><br><span class="line">    // 调用原始API</span><br><span class="line">    pFunc = GetProcAddress(GetModuleHandleA(DEF_NTDLL), </span><br><span class="line">                           DEF_ZWQUERYSYSTEMINFORMATION);</span><br><span class="line">    status = ((PFZWQUERYSYSTEMINFORMATION)pFunc)</span><br><span class="line">              (SystemInformationClass, SystemInformation, </span><br><span class="line">              SystemInformationLength, ReturnLength);</span><br><span class="line"> </span><br><span class="line">    if( status != STATUS_SUCCESS )</span><br><span class="line">        goto __NTQUERYSYSTEMINFORMATION_END;</span><br><span class="line"> </span><br><span class="line">    // 针对SystemProcessInformation类型操作</span><br><span class="line">    if( SystemInformationClass == SystemProcessInformation )</span><br><span class="line">    &#123;</span><br><span class="line">        // SYSTEM_PROCESS_INFORMATION类型转换</span><br><span class="line">        // pCur是单向链表的头</span><br><span class="line">        pCur = (PSYSTEM_PROCESS_INFORMATION)SystemInformation;</span><br><span class="line"> </span><br><span class="line">        while(TRUE)</span><br><span class="line">        &#123;</span><br><span class="line">            // 比较进程名称</span><br><span class="line">            // g_szProcName为要隐藏的进程名称</span><br><span class="line">            // (=&gt; SetProcName()设置)</span><br><span class="line">            if(pCur-&gt;Reserved2[1] != NULL)</span><br><span class="line">            &#123;</span><br><span class="line">                if(!_tcsicmp((PWSTR)pCur-&gt;Reserved2[1], g_szProcName))</span><br><span class="line">                &#123;</span><br><span class="line">                    // 从链表中删除隐藏进程的节点</span><br><span class="line">                    if(pCur-&gt;NextEntryOffset == 0)</span><br><span class="line">                        pPrev-&gt;NextEntryOffset = 0;</span><br><span class="line">                    else</span><br><span class="line">                        pPrev-&gt;NextEntryOffset += pCur-&gt;NextEntryOffset;</span><br><span class="line">                &#125;</span><br><span class="line">                else		</span><br><span class="line">                    pPrev = pCur;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            if(pCur-&gt;NextEntryOffset == 0)</span><br><span class="line">                break;</span><br><span class="line"> </span><br><span class="line">            // 链表的下一项</span><br><span class="line">            pCur = (PSYSTEM_PROCESS_INFORMATION)</span><br><span class="line">                    ((ULONG)pCur + pCur-&gt;NextEntryOffset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">__NTQUERYSYSTEMINFORMATION_END:</span><br><span class="line"> </span><br><span class="line">    // 函数终止前再次执行API钩取操作，为下次调用准备</span><br><span class="line">    hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, </span><br><span class="line">                 (PROC)NewZwQuerySystemInformation, g_pOrgBytes);</span><br><span class="line"> </span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单分析一下 将SystemInformationClass参数设置为SystemProcessInformation（5）后调用ZwQuerySystemInformation（）API，SystemInformation[in/out]参数中储存的是SYSTEM_PROCESS_INFORMATIN结构体单向链表的起始地址 隐藏某进程之前，先要查找与之对应的链表成员，然后断开其与链表的链接。</p>
<h2 id="利用热补丁技术钩取API"><a href="#利用热补丁技术钩取API" class="headerlink" title="利用热补丁技术钩取API"></a>利用热补丁技术钩取API</h2><p>前面demo程序中通过代码修改技术进行API Hook存在的缺点</p>
<p>1.频繁脱钩，挂钩会造成整体性能下降</p>
<p>2.多线程环境，当一个线程尝试运行某段代码，而另一进程刚好在对该代码进行写操作，这时就会发生冲突，会引起非法访问异常（Access Violation）。《windows核心编程》指出，利用代码修改技术钩取API会对系统安全造成威胁</p>
<h3 id="热补丁（修改7Byte代码）"><a href="#热补丁（修改7Byte代码）" class="headerlink" title="热补丁（修改7Byte代码）"></a>热补丁（修改7Byte代码）</h3><p>Windows系统库中的函数，如kernel32.CreateProcessA/W, user32.MessageBoxA，gdi32.TextOutW有一个相似点</p>
<p>1.API以MOV EDI, EDI指令开始(IA-32 0X8bff)<br>2.API上方有5个NOP指令(IA-32 0X90)<br>微软做此设计的目的就是方便打热补丁。</p>
<p>使用热补丁Hook API的过程如下</p>
<p>1.修改API开始的两个字节MOV EDI,EDI为SHORT JMP指令EB F9, 跳转的目标地址是address_of_api - 5，即5个NOP指令的第一条<br>2.修改5个NOP指令为长跳转E9 XXXXXXXX，跳转到用户自定义API<br>3.用户自定义代码调用原始API时，直接以API+2的地址为API地址调用原API，这样就不会引起内存非法访问</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="DllMain（）"><a href="#DllMain（）" class="headerlink" title="DllMain（）"></a>DllMain（）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span><br><span class="line">&#123;</span><br><span class="line">    char            szCurProc[MAX_PATH] = &#123;0,&#125;;</span><br><span class="line">    char            *p = NULL;</span><br><span class="line"></span><br><span class="line">    // 判断进程名称，不向HideProc2.exe注入dll</span><br><span class="line">    GetModuleFileNameA(NULL, szCurProc, MAX_PATH);</span><br><span class="line">    p = strrchr(szCurProc, &apos;\\&apos;);</span><br><span class="line">    if( (p != NULL) &amp;&amp; !_stricmp(p+1, &quot;HideProc2.exe&quot;) )</span><br><span class="line">        return TRUE;</span><br><span class="line"></span><br><span class="line">    // change privilege</span><br><span class="line">    SetPrivilege(SE_DEBUG_NAME, TRUE);</span><br><span class="line"></span><br><span class="line">    switch( fdwReason )</span><br><span class="line">    &#123;</span><br><span class="line">        case DLL_PROCESS_ATTACH : </span><br><span class="line">            // hook</span><br><span class="line">            hook_by_hotpatch(&quot;kernel32.dll&quot;, &quot;CreateProcessA&quot;, </span><br><span class="line">                             (PROC)NewCreateProcessA);</span><br><span class="line">            hook_by_hotpatch(&quot;kernel32.dll&quot;, &quot;CreateProcessW&quot;, </span><br><span class="line">                             (PROC)NewCreateProcessW);</span><br><span class="line">            //可以看到这里没有对ZwQuerySystemInformation使用热补丁Hook，具体原因见&quot;3.热补丁Hook的缺点&quot;</span><br><span class="line">            hook_by_code(&quot;ntdll.dll&quot;, &quot;ZwQuerySystemInformation&quot;, </span><br><span class="line">                         (PROC)NewZwQuerySystemInformation, g_pOrgZwQSI);</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case DLL_PROCESS_DETACH :</span><br><span class="line">            // unhook</span><br><span class="line">            unhook_by_hotpatch(&quot;kernel32.dll&quot;, &quot;CreateProcessA&quot;);</span><br><span class="line">            unhook_by_hotpatch(&quot;kernel32.dll&quot;, &quot;CreateProcessW&quot;);</span><br><span class="line">            unhook_by_code(&quot;ntdll.dll&quot;, &quot;ZwQuerySystemInformation&quot;, </span><br><span class="line">                           g_pOrgZwQSI);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和之前代码一样，在Dll附加进程的时候调用hook方法，在dll卸载时调用unhook方法</p>
<h4 id="hook-by-hotpatch"><a href="#hook-by-hotpatch" class="headerlink" title="hook_by_hotpatch()"></a>hook_by_hotpatch()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">BOOL hook_by_hotpatch(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew)</span><br><span class="line">&#123;</span><br><span class="line">    FARPROC pFunc;</span><br><span class="line">    DWORD dwOldProtect, dwAddress;</span><br><span class="line">    BYTE pBuf[5] = &#123; 0xE9, 0, &#125;;</span><br><span class="line">    BYTE pBuf2[2] = &#123; 0xEB, 0xF9 &#125;;</span><br><span class="line">    PBYTE pByte;</span><br><span class="line"></span><br><span class="line">    pFunc = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">    pByte = (PBYTE)pFunc;</span><br><span class="line">    if( pByte[0] == 0xEB )</span><br><span class="line">        return FALSE;</span><br><span class="line"></span><br><span class="line">    VirtualProtect((LPVOID)((DWORD)pFunc - 5), 7, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    // 1. NOP (0x90)</span><br><span class="line">    dwAddress = (DWORD)pfnNew - (DWORD)pFunc;</span><br><span class="line">    memcpy(&amp;pBuf[1], &amp;dwAddress, 4);</span><br><span class="line">    memcpy((LPVOID)((DWORD)pFunc - 5), pBuf, 5);</span><br><span class="line">    </span><br><span class="line">    // 2. MOV EDI, EDI (0x8BFF)</span><br><span class="line">    memcpy(pFunc, pBuf2, 2);</span><br><span class="line"></span><br><span class="line">    VirtualProtect((LPVOID)((DWORD)pFunc - 5), 7, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改API中无用的7字节数据，跳转到用户自定义Hook函数</p>
<h4 id="unhook-by-hotpatch"><a href="#unhook-by-hotpatch" class="headerlink" title="unhook_by_hotpatch"></a>unhook_by_hotpatch</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">BOOL unhook_by_hotpatch(LPCSTR szDllName, LPCSTR szFuncName)</span><br><span class="line">&#123;</span><br><span class="line">    FARPROC pFunc;</span><br><span class="line">    DWORD dwOldProtect;</span><br><span class="line">    PBYTE pByte;</span><br><span class="line">    BYTE pBuf[5] = &#123; 0x90, 0x90, 0x90, 0x90, 0x90 &#125;;</span><br><span class="line">    BYTE pBuf2[2] = &#123; 0x8B, 0xFF &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pFunc = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">    pByte = (PBYTE)pFunc;</span><br><span class="line">    if( pByte[0] != 0xEB )</span><br><span class="line">        return FALSE;</span><br><span class="line"></span><br><span class="line">    VirtualProtect((LPVOID)pFunc, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    // 1. NOP (0x90)</span><br><span class="line">    memcpy((LPVOID)((DWORD)pFunc - 5), pBuf, 5);</span><br><span class="line">    </span><br><span class="line">    // 2. MOV EDI, EDI (0x8BFF)</span><br><span class="line">    memcpy(pFunc, pBuf2, 2);</span><br><span class="line"></span><br><span class="line">    VirtualProtect((LPVOID)pFunc, 5, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将7字节数据修改为原数据</p>
<h4 id="NewCreateProcess"><a href="#NewCreateProcess" class="headerlink" title="NewCreateProcess"></a>NewCreateProcess</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI NewCreateProcessA(</span><br><span class="line">    LPCTSTR lpApplicationName,</span><br><span class="line">    LPTSTR lpCommandLine,</span><br><span class="line">    LPSECURITY_ATTRIBUTES lpProcessAttributes,</span><br><span class="line">    LPSECURITY_ATTRIBUTES lpThreadAttributes,</span><br><span class="line">    BOOL bInheritHandles,</span><br><span class="line">    DWORD dwCreationFlags,</span><br><span class="line">    LPVOID lpEnvironment,</span><br><span class="line">    LPCTSTR lpCurrentDirectory,</span><br><span class="line">    LPSTARTUPINFO lpStartupInfo,</span><br><span class="line">    LPPROCESS_INFORMATION lpProcessInformation</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    BOOL bRet;</span><br><span class="line">    FARPROC pFunc;</span><br><span class="line"></span><br><span class="line">    pFunc = GetProcAddress(GetModuleHandleA(&quot;kernel32.dll&quot;), &quot;CreateProcessA&quot;);</span><br><span class="line">    //以API地址+2为函数地址调用CreateProcessA函数</span><br><span class="line">    pFunc = (FARPROC)((DWORD)pFunc + 2);</span><br><span class="line">    bRet = ((PFCREATEPROCESSA)pFunc)(lpApplicationName,</span><br><span class="line">                                     lpCommandLine,</span><br><span class="line">                                     lpProcessAttributes,</span><br><span class="line">                                     lpThreadAttributes,</span><br><span class="line">                                     bInheritHandles,</span><br><span class="line">                                     dwCreationFlags,</span><br><span class="line">                                     lpEnvironment,</span><br><span class="line">                                     lpCurrentDirectory,</span><br><span class="line">                                     lpStartupInfo,</span><br><span class="line">                                     lpProcessInformation);</span><br><span class="line"></span><br><span class="line">    // 注入steach3.dll</span><br><span class="line">    if( bRet )</span><br><span class="line">        InjectDll2(lpProcessInformation-&gt;hProcess, STR_MODULE_NAME);</span><br><span class="line"></span><br><span class="line">    return bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意一点，在使用之前的hook方法进行API钩取时，在用户自定义NewCreateProcess函数开头需要调用unhook方法(防止进入钩取的死循环)，函数结尾需要调用hook方法进行重新钩取。</p>
<p>但是使用热补丁Hook时不需要这样反复脱钩，挂钩，只需在调用原始API时，使用address of API + 2的地址调用API即可</p>
<h3 id="使用热补丁进行Hook的缺点"><a href="#使用热补丁进行Hook的缺点" class="headerlink" title="使用热补丁进行Hook的缺点"></a>使用热补丁进行Hook的缺点</h3><p>热补丁钩取技术有个明显的缺点，即不符合钩取条件（7字节无用代码）的API无法使用热补丁钩取</p>
<p>这样的API有，ntdll.dll提供的API 和kernel32.GetStartInfoA() 等</p>
<p>并非所有API都能使用热补丁钩取，所以使用前需要先确认要钩取的API是否支持，若不支持则需使用前面的5字节代码修改技术</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/09/OD学习记录5-11/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/09/OD学习记录5-11/" itemprop="url">OD学习记录5.11</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-09T19:18:09+08:00">
                2019-05-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="API钩取"><a href="#API钩取" class="headerlink" title="API钩取"></a>API钩取</h1><p>api(application programming interface,应用程序编程接口）。windows系统资源都是由windows os系统直接管理的，用户不能直接访问。用户需要访问系统资源的时候，必须向系统内核（kernel)申请，申请的方法就是使用微软提供的win32api.为了实际运行相应的程序代码，需要加载许多系统库（DLL).所有的进程都会默认加载kernel32.dll,kernel32.dll又会加载ntdll.dll库。</p>
<p><img src="1.png" alt=""><br>用户模式中的应用程序访问系统资源的时候，由ntdll.dll向内核模式提出访问请求。一般常规系统资源的api会经由kernel32.dll与ntdll.dll不断向下调用，最后同故宫SYSENTRY命令进入内核模式。</p>
<p>使用api钩取技术可以实现对某些win32API 的嗲用过程拦截，并获得相应的控制权限，使用api钩取技术的优势如下：<br>1）再api调用前/后运行用户的”钩子“代码。</p>
<p>2）查看或操作传递给api的参数或者传递api的返回值</p>
<p>3）取消对api的调用，或者更改执行流程，运行用户代码</p>
<p>下表列出了api钩取的技术图表：<br><img src="2.png" alt=""><br> 根据对象的不同，api钩取可以分为静态方法与动态方法。静态方法是针对的是“文件”，而动态方法针对的是进程内存。根据钩取的位置不懂，可以分为：</p>
<p>1)iat,将iad内部的api地址更改为钩取函数地址，该方法的优点是实现起来非常见到那，缺点是不能钩取不在iat中的api.</p>
<p>2)代码：系统库（*.dll）映射到进程内存时，从中查找api的实际嗲hi，并直接修改代码，具体的方法分为以下几种：使用jmp指令修改起始代码，覆写函数局部，仅更改必须部分的局部</p>
<p>3）eat:将记录在dll中的eat中的api起始地址更改为钩取函数地址也可以实现api钩取。</p>
<p>根据对应的技术不同，可以分为以下几种技术：</p>
<p>1）调试技术</p>
<p>调试法通过调试目标继承钩取api.调试器拥有被调试者的所有权限（执行控制，内存访问），所以可以向被调试进程的内存任意位置设置钩取函数。这里的调试器是用户编写的用来钩取的程序。在用户编写的程序中使用调试api附加到目标进程，然后设置钩取函数，这样，重启运行时就能偶完全实现api钩取了。也可以向现有的调试器（od,ida,windbg)使用自动化脚本，自动钩取api.</p>
<p>2)注入</p>
<p>向目标进程内存区域进行渗透测试的技术，根据注入对象的不同，可以分为dll注入与代码注入两种技术。</p>
<p>a)dll注入</p>
<p>使用dll注入即使可以使目标进程强制加载用户指定的dll文件。使用该技术的时候需要先在注入的dll中创建钩取代码与设置钩代码，然后再dllmain()中调用设置代码，注入的同时即可完成api钩取。</p>
<p>b）代码注入</p>
<p>代码注入技术广泛用于恶意代码，代码注入技术比dll注入技术更发达。</p>
<h1 id="记事本WriteFile（）API钩取"><a href="#记事本WriteFile（）API钩取" class="headerlink" title="记事本WriteFile（）API钩取"></a>记事本WriteFile（）API钩取</h1><h2 id="运行调试"><a href="#运行调试" class="headerlink" title="运行调试"></a>运行调试</h2><p>这次在windowsXP的虚拟机下调试程序 因为在自己的win10下有问题无法调试 所以就在winXP下去尝试了<br>首先运行notepad.exe 得到其PID 如图<br><img src="3.png" alt=""><br>然后运行hookdbg.exe 如图：<br><img src="4.png" alt=""><br>接下来像记事本里输入小写字母 随便输就行:<br><img src="5.png" alt=""><br>输入完后保存文件 发现刚才CMD黑框里的内容也变了：<br><img src="6.png" alt=""><br>发现刚好是刚才输入的内容和转变位大写的内容.<br>打开保存的记事本文件发现：<br><img src="7.png" alt=""><br>这就是钩取成功的表现了 下面看看其工作原理</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>先来看看WriteFile()定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL WriteFile(</span><br><span class="line">HANDLE  hFile,//文件句柄</span><br><span class="line">LPCVOID lpBuffer,//数据缓存区指针</span><br><span class="line">DWORD   nNumberOfBytesToWrite,//你要写的字节数</span><br><span class="line">LPDWORD lpNumberOfBytesWritten,//用于保存实际写入字节数的存储区域的指针</span><br><span class="line">LPOVERLAPPED lpOverlapped//OVERLAPPED结构体指针</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>参数 类型及说明<br>hFile Long，一个文件的句柄</p>
<p>lpBuffer Any，参数类型:指针,指向将写入文件的 数据缓冲区</p>
<p>nNumberOfBytesToWrite Long，要写入数据的字节数量。如写入零字节，表示什么都不写入，但会更新文件的“上一次修改时间”。针对位于远程系统的命名管道，限制在65535个字节以内</p>
<p>lpNumberOfBytesWritten Long，实际写入文件的字节数量（此变量是用来返回的 ）</p>
<p>lpOverlapped OVERLAPPED，倘若在指定FILE_FLAG_OVERLAPPED的前提下打开文件，这个参数就必须引用一个特殊的结构。那个结构定义了一次异步写操作。否则，该参数应置为空（将声明变为ByVal As Long，并传递零值）</p>
<p>用OD打开notepad 并在每个WriteFile上设置断点<br><img src="8.png" alt=""><br>运行程序并在记事本里输入内容 保存后发现 程序断在了WriteFile()处 并发现到了这4个重要的点<br><img src="9.png" alt=""><br>栈中有（ESP）1个返回值ESP+8中存在数据缓冲区的地址 直接跳转到此地址可以发现刚才输入的字符串 钩取Write/file（）API后 用指定字符串覆盖数据缓冲区的内容即可</p>
<h2 id="源代码分析（hookdng-cpp源代码）"><a href="#源代码分析（hookdng-cpp源代码）" class="headerlink" title="源代码分析（hookdng.cpp源代码）"></a>源代码分析（hookdng.cpp源代码）</h2><h3 id="main"><a href="#main" class="headerlink" title="main()"></a>main()</h3><p><img src="10.png" alt=""><br>Main函数以程序运行参数的形式接收要钩取API的进程的PID，然后通过DebugActiveProcess()API将调试器附加到该运行的进程上，开始调试。然后进入DebugLoop()函数，处理来自被调试者的调试事件。（也可以通过CreateProcess()API，从一开始就直接以调试模式运行进程）</p>
<h3 id="DebugLoop"><a href="#DebugLoop" class="headerlink" title="DebugLoop()"></a>DebugLoop()</h3><p><img src="11.png" alt=""><br>DebugLoop处理了三个DebugEvent，分别是</p>
<p>CREATE_PROCESS_DEBUG_EVENT： 被调试进程启动/附加时触发该事件，调试器调用OnCreateProcessDebugEvent()</p>
<p>EXCEPTION_DEBUG_EVENT：被调试进程遇到iNT 3指令时触发该事件，调试器调用OnExceptionDebugEvent()</p>
<p>EXIT_PROCESS_DEBUG_EVENT：被调试进程终止时触发，在本代码中，调试器在被调试器终止时退出</p>
<p>DebugL oop0函数的工作原理类似于窗口过程函数( WndProc ),它从被调试者处接收事件并处理，然后使被调试者继续运行。DebugLoop(函数代码比较简单，结合代码中的注释就能理解。下面看看其中比较重要的2个API。</p>
<p>顾名思义，WaitForDebugEvent() API (出处: MSDN)是-一个等待被调试者发生调试事件的函数(行为动作类似于WaitForSingleObject() API )。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WaitForDebugEvent(</span><br><span class="line"> </span><br><span class="line">    __in LPDEBUG_EVENT lpDebugEvent,</span><br><span class="line"> </span><br><span class="line">    __in DWORD dwMilliseconds</span><br><span class="line"> </span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>DebugLoop(函数代码中,若发生调试事件, WaitForDebugEvent( API就会将相关事件信息设置到其第- -个参数的变量( DEBUG EVENT结构体对象), 然后立刻返回。DEBUG EVENT结构体定义(出处: MSDN)如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _DEBUG_EVENT &#123;</span><br><span class="line"> </span><br><span class="line">    DWORD dwDebugEventCode;</span><br><span class="line"> </span><br><span class="line">    DWORD dwProcessId;</span><br><span class="line"> </span><br><span class="line">    DWORD dwThreadId;</span><br><span class="line"> </span><br><span class="line">    union &#123;</span><br><span class="line"> </span><br><span class="line">        EXCEPTION_DEBUG_INFO Exception;</span><br><span class="line"> </span><br><span class="line">        CREATE_THREAD_DEBUG_INFO CreateThread;</span><br><span class="line"> </span><br><span class="line">        CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;</span><br><span class="line"> </span><br><span class="line">        EXIT_THREAD_DEBUG_INFO ExitThread;</span><br><span class="line"> </span><br><span class="line">        EXIT_PROCESS_DEBUG_INFO ExitProcess;</span><br><span class="line"> </span><br><span class="line">        LOAD_DLL_DEBUG_INFO LoadDll;</span><br><span class="line"> </span><br><span class="line">        UNLOAD_DLL_DEBUG_INFO UnloadDll;</span><br><span class="line"> </span><br><span class="line">        OUTPUT_DEBUG_STRING_INFO DebugString;</span><br><span class="line"> </span><br><span class="line">        RIP_INFO RipInfo;</span><br><span class="line"> </span><br><span class="line">    &#125; u;</span><br><span class="line"> </span><br><span class="line">&#125; DEBUG_EVENT, *LPDEBUG_EVENT;</span><br></pre></td></tr></table></figure>
<p>前面的讲解中已经提到过，共有9种调试事件。DEBUG_ EVENT.dwDebugEventCode成员 会被设置为9种事件中的一-种，根据相关事件的种类，也会设置适当的DEBUG_EVENTu(union)成员( DEBUG EVENT.u共用体成员内部也由9个结构体组成，它们对应于事件种类的个数)</p>
<p>ContinueDebugEvent是一个使调试器继续运行的API</p>
<p>定义如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ContinueDebugEvent(</span><br><span class="line"> </span><br><span class="line">    __in DWORD dwProcessId,</span><br><span class="line"> </span><br><span class="line">    __in DWORD dwThreadId,</span><br><span class="line"> </span><br><span class="line">    __in DWORD dwContinueStatus</span><br><span class="line"> </span><br><span class="line">    );</span><br></pre></td></tr></table></figure></p>
<p>ContinueDebugEvent() API 的 最 后 一 个 参 数 dwContinueStatus 的 值 为 DBG_CONTINUE 或  DBG_EXCEPTION_NOT_HANDLED。若处理正常，则其值设置为DBG_CONTINUE;若无法处理，或希望在应用程序的SEH中处 理，则其值设置为DBG EXCEPTION NOT HANDLED</p>
<p>DebugLoopO函数处理3种调试事件，如下所示。</p>
<p>□ EXIT_PROCESS_DEBUG_EVENT</p>
<p>□ CREATE_PROCESS_DEBUG_EVENT</p>
<p>□ EXCEPTION_DEBUG_EVENT</p>
<p>下面分别看看这3个事件。<br>EXIT_PROCESS_DEBUG_EVENT</p>
<p>被调试进程终止时会触发该事件。本章的示例代码中发生该事件时，调试器与被调试者将一 起终止。</p>
<p>CREATE_PROCESS_DEBUG_EVENT-OnCreateProcessDebugEvent()</p>
<p>OnCreateProcessDebugEvent()是 CREATE_PROCESS_DEBUG_EVENT 事件句柄，被调试进程启动（或者附加）时即调用执行该函数。</p>
<h3 id="OnCreateProcessDebugEvent"><a href="#OnCreateProcessDebugEvent" class="headerlink" title="OnCreateProcessDebugEvent()"></a>OnCreateProcessDebugEvent()</h3><p><img src="12.png" alt=""><br>代码首先获得WriteFile的内存地址,</p>
<p>然后将函数地址处的第一个字节数据存放在g_chOrgByte变量中，之后将函数地址处第一个字节改为0xCC</p>
<p>由于调试器拥有被调试进程的句柄（带有调试权限，DLL注入时也是首先将进程提升为调试权限[SE_DEBUG_NAME]）所以可以使用ReadProcessMemory和WriteProcessMemory对被调试进程的内存空间自由进行读写操作。</p>
<h3 id="OnExceptionDebugEvent"><a href="#OnExceptionDebugEvent" class="headerlink" title="OnExceptionDebugEvent()"></a>OnExceptionDebugEvent()</h3><p><img src="13.png" alt=""><br><img src="14.png" alt=""><br><img src="15.png" alt=""><br><img src="16.png" alt=""><br>OnExceptionDebugEvent(函数代码有些多，接下来分析核心部分。首先，if语句用于检测异常是否为EXCEPTION_ BREAKPOINT异常(除此之外，还有大约19种异常,请参考前几节内容)。然后，用if语句检测发生断点的地址是否与kernel32!WriteFile(的起始地址一致( OnCreateProcessDebugEvent()已经事先获取了WriteFile()的起始地址)。若满足条件,则继续执行以下代码\</p>
<h4 id="脱钩（恢复原代码）"><a href="#脱钩（恢复原代码）" class="headerlink" title="脱钩（恢复原代码）"></a>脱钩（恢复原代码）</h4><p><img src="17.png" alt=""></p>
<h4 id="获取线程上下文"><a href="#获取线程上下文" class="headerlink" title=".获取线程上下文"></a>.获取线程上下文</h4><p>这是第1次提到“线程上下文”，所有程序在内存中都以进程为单位运行，而进程的实际指令代码以线程为单位运行。Windows OS是一个多线程 ( multi-thread )操作系统，同-进程中可以同时运行多个线程。多任务( multi-tasking )是将CPU资源划分为多个时间片( time-slice),然后平等地逐一 运行所有线程(考虑线程优先级)。 CPU运行完一 个线程的时间片而切换到其他线程时间片时，它必须将先前线程处理的内容准确备份下来，这样再次运行它时才能正常无误。</p>
<p>再次运行先前线程时，必须有运行所需信息，这些重要信息指的就是CPU中各寄存器的值。通过这些值，才能保证CPU能够再次准确运行它(内存信息栈&amp;堆存在于相应进程的虚拟空间,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI</span><br><span class="line">BOOL</span><br><span class="line">WINAPI</span><br><span class="line">GetThreadContext(</span><br><span class="line">    __in    HANDLE hThread,</span><br><span class="line">    __inout LPCONTEXT lpContext</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>像这样调用GetThreadContext() API (出处: MSDN),即可将指定线程( g_ cpdi.hThread)的CONTEXT存储到ctx结构体变量( g_ cpdi.hThread是被调试者的主线程句柄)。</p>
<h4 id="获取WriteFile-的param值"><a href="#获取WriteFile-的param值" class="headerlink" title="获取WriteFile()的param值"></a>获取WriteFile()的param值</h4><p>调用WriteFile()函数时,我们要在传递过来的参数中知道param2 (数据缓冲区地址)与param3(缓冲区大小)这2个参数。函数参数存储在栈中，通过#2中获取的CONTEXT.Esp成员可以分别获得它们的值</p>
<p><img src="18.png" alt=""><br>存储在dwAddrOfBuffer中的数据缓冲区地址是被调试者（notepad.exe）虚拟内存空间中的地址</p>
<h4 id="把小写字母转换为大写字母后覆写在WriteFile-缓冲区"><a href="#把小写字母转换为大写字母后覆写在WriteFile-缓冲区" class="headerlink" title="把小写字母转换为大写字母后覆写在WriteFile()缓冲区"></a>把小写字母转换为大写字母后覆写在WriteFile()缓冲区</h4><p>获取数据缓冲区的地址与大小后,将其内容读到调试器的内存空间，把小写字母转换为大写字母。然后将修改后的大写字母覆写到原位置(被调试者的虚拟内存)。整个代码不难，结合代码中的注释就能轻松理解</p>
<p><img src="19.png" alt=""></p>
<h4 id="把线程上下文的EIP修改为WriteFile-起始地址"><a href="#把线程上下文的EIP修改为WriteFile-起始地址" class="headerlink" title="把线程上下文的EIP修改为WriteFile()起始地址"></a>把线程上下文的EIP修改为WriteFile()起始地址</h4><p><img src="20.png" alt=""><br>将线程上下文的EIP更改为WriteFile()首地址(当前为WriteFile() + 1位置，int3命令之后)</p>
<p>修改好CONTEXT.Eip成员后，调用SetThreadContext()API来修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SetThreadContext(</span><br><span class="line"> </span><br><span class="line">    __in HANDLE hThread,</span><br><span class="line"> </span><br><span class="line">    __in CONST CONTEXT *lpContext</span><br><span class="line"> </span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h5 id="运行调试进程"><a href="#运行调试进程" class="headerlink" title="运行调试进程"></a>运行调试进程</h5><p> 全部准备完成后，接下来就正常调用WriteFile()API了，调用ContinueDebugEvent()API就可以重启被调试进程，使之继续运行。</p>
<h4 id="继续HOOK（达到循环获取的目的）"><a href="#继续HOOK（达到循环获取的目的）" class="headerlink" title="继续HOOK（达到循环获取的目的）"></a>继续HOOK（达到循环获取的目的）</h4><p> 最后设置API“钩子”，方便下次钩取操作(若略去该操作，由于#1中已经“脱钩”, WriteFile()API钩取将完全处于“脱钩”状态)</p>
<p><img src="21.png" alt=""><br>在 OnExceptionDebugEvent()函 数 中 调 用 了 ContinueDebugEvent()函 数 后 ，为 什 么 还 要  调 用Sleep(0)函 数 ？</p>
<font color="#00ffff" size="3">调 用Sleep(0)函 数 可 以 释 放 当 前 线 程 的 剩 余 时 间 片 ， 即 放 弃 当 前 线 程 执 行 的CPU时 间 片。也 就 是 说 ， 调 用Sleep(0)函 数 后 ，CPU会 立 即 执 行 其 他 线 程 。 被 调 试 进 程（Notepad.exe) 的 主 线 程 处 于 运 行 状 态 时 ， 会 正 常 调 用WriteFiIe()API。然 后 经 过 一 定 时 间 ， 控 制 权 再 次 转 移 给HookDbg.exe, Sleep(0)后 面 的 “ 钩子 ” 代 码（WriteProcessMemory()API)会 被 调 用 执 行。若 没 有Sleep(0)语 句 ，Notepad.exe调 用WriteFile()API的 过 程 中 ，HookDbg.exe会尝试将WriteFile()API的首字节修改为OxCC。若运气不佳，这可能会导致内存访问异常。（避免notepad正在调用writefile()API的过程中，后面的钩子代码在调用成功之前执行完毕)</font>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/04/od学习5-4/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/04/od学习5-4/" itemprop="url">od学习5.4</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-04T21:33:15+08:00">
                2019-05-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="windows消息钩取"><a href="#windows消息钩取" class="headerlink" title="windows消息钩取"></a>windows消息钩取</h1><h2 id="简单地说，消息钩取就是偷看、截取信息。"><a href="#简单地说，消息钩取就是偷看、截取信息。" class="headerlink" title="简单地说，消息钩取就是偷看、截取信息。"></a>简单地说，消息钩取就是偷看、截取信息。</h2><h2 id="常规Windows消息流："><a href="#常规Windows消息流：" class="headerlink" title="常规Windows消息流："></a>常规Windows消息流：</h2><p>1、发生键盘输入事件时，WM_KEYDOWN消息被添加到[OS message queue]；</p>
<p>2、OS判断哪个应用程序中发生了事件，然后从[OS message queue]中取出消息，添加到相应应用程序的[application message queue]中；</p>
<p>3、应用程序监视自身的[application message queue]，发现新添加的WM_KEYDOWN消息后，调用相应的事件处理程序处理。</p>
<h2 id="消息钩子："><a href="#消息钩子：" class="headerlink" title="消息钩子："></a>消息钩子：</h2><p>Windows OS向用户提供GUI，其是以事件驱动的方式进行工作的。每当发生这样的事件时，OS会将事先定义好的消息发送给相应的应用程序，应用程序分析收到的信息后执行相应动作。即在敲击键盘时，消息从OS传递到应用程序，此过程中消息钩子可以偷看其中的信息。</p>
<p>消息钩子是Windows OS提供的基本功能，其中最具代表性的是VS Visual Studio中提供的SPY++，其是一个功能强大的消息钩取程序，能够查看OS中来往的所有消息。</p>
<p>如下图，OS消息队列和应用程序消息队列之间存在一条钩链（Hook Chain），设置好键盘消息钩子后，处于钩链中的键盘消息钩子会比应用程序先一步看到相应信息。在键盘消息钩子函数的内部，除了可以查看消息之外，还可以修改消息本身，而且还能对消息实施拦截，阻止消息传递。可以同时设置多个相同的键盘消息钩子，按照设置的顺序依次调用，从而组成的链条称为钩链。</p>
<p><img src="1.jpg" alt=""></p>
<h2 id="Windows消息钩取的实现——SetWindowsHookEx"><a href="#Windows消息钩取的实现——SetWindowsHookEx" class="headerlink" title="Windows消息钩取的实现——SetWindowsHookEx()"></a>Windows消息钩取的实现——SetWindowsHookEx()</h2><p>在Windows编程中，使用SetWindowsHookEx() API可以简便地实现消息钩子，其用于将指定的钩子注册到钩链中，无论在DLL内部或外部都可调用.</p>
<p>SetWindowsHookEx() API定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HHOOK SetWindowsHookEx(</span><br><span class="line">    int idHook,			//hook type</span><br><span class="line">    HOOKPROC lpfn,		//hook procedure</span><br><span class="line">    HINSTANCE hMod,		//hook procedure所属的DLL句柄</span><br><span class="line">    DWORD dwThreadId	//将要挂钩的目标线程ID</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>HHOOK：返回值，钩子句柄，需要保留，等不使用钩子时通过UnhookWindowsHookEx函数卸载钩子。</p>
<p>idHook：钩子的拦截消息类型，选择钩子程序的拦截范围，具体值参考文章结尾的消息类型。</p>
<p>Lpfn：消息的回调函数地址，一般是填函数名。</p>
<p>hMod：钩子函数所在的实例的句柄。对于线程钩子，该参数为NULL；对于系统钩子，该参数为钩子函数所在的DLL句柄。在dll中可通过AfxInitExtensionModule(MousehookDLL, hInstance)获得DLL句柄。</p>
<p>dwThreadId：钩子所监视的线程的线程号，可通过GetCurrentThreadId()获得线程号。对于全局钩子，该参数为NULL(或0)。</p>
<h2 id="调试Windows消息钩取"><a href="#调试Windows消息钩取" class="headerlink" title="调试Windows消息钩取"></a>调试Windows消息钩取</h2><h3 id="1、调试HookMain-exe："><a href="#1、调试HookMain-exe：" class="headerlink" title="1、调试HookMain.exe："></a>1、调试HookMain.exe：</h3><p><img src="2.png" alt=""><br>直接拉到401000处可以看到：<br><img src="3.png" alt=""><br>程序先在401006地址处调用LoadLibraryA(KeyHook.dll)，然后在40104B地址处的CALLEBX指令调用KeyHook.HookStart()函数。跟踪进入该函数查看：</p>
<p><img src="4.png" alt=""><br>在100010EF地址处可以看到，调用了SetWindowsHookExW()函数，其上方两条PUSH指令将该函数的第一、第二两个参数压入栈。其中第一个参数idHook值为2，即WH_KEYBOARD，第二个参数lpfn值为74C21020，该值即为钩子过程的地址。</p>
<p>返回main()函数之后的代码即为接收用户输入的q后即终止钩取</p>
<h3 id="2-调试Notepad-exe："><a href="#2-调试Notepad-exe：" class="headerlink" title="2.调试Notepad.exe："></a>2.调试Notepad.exe：</h3><p><img src="5.png" alt=""><br>在调试界面里的事件选择：<br><img src="6.png" alt=""><br>开启后 每当新的DLL被调试时就会自动暂停调试 在从DLL注入调试时开始调试的情况下很有用<br>运行后发现：<br><img src="7.png" alt=""><br>双击HOOK到达HOOK的EP地址处 给此处设置断点 发现每次发生键盘输入事件时 程序就会停在此处</p>
<h1 id="Dll注入"><a href="#Dll注入" class="headerlink" title="Dll注入"></a>Dll注入</h1><h2 id="用CreateRemoteThread实现DLL注入"><a href="#用CreateRemoteThread实现DLL注入" class="headerlink" title="用CreateRemoteThread实现DLL注入"></a>用CreateRemoteThread实现DLL注入</h2><h3 id="（一）myhack-dll，即要注入的dll程序"><a href="#（一）myhack-dll，即要注入的dll程序" class="headerlink" title="（一）myhack.dll，即要注入的dll程序"></a>（一）myhack.dll，即要注入的dll程序</h3><p>程序流程：<br>（1）当DLL被加载（DLL_PROCESS_ATTACH）时，先输出一个调试字符串，<br>（2）利用CreateThread() 创建一个线程，创建后立即被激活，直接调用ThreadProc函数<br>（3）该函数调用URLDownloadToFile() 下载指定网站的index.html文件<br>首先将InjectDll.exe和myhack.DLl放入一个文件夹<br><img src="13.png" alt=""><br>运行notepad.exe 看到PID是6340<br><img src="14.png" alt=""><br>myhack.dll注入<br><img src="15.png" alt=""><br>结果确认<br><img src="16.png" alt=""><br>发现文件夹里多了文件  打开看看<br><img src="17.png" alt=""><br>虽然看起来与实际主页可能不同 但确实是从该网站下载的index.html文件<br>上述借助创建远程线程的方法可以成功渗透指定进程 进而可以随意操作</p>
<h3 id="（二）InjectDll-exe，即将myhack-dll注入notepad-exe的程序"><a href="#（二）InjectDll-exe，即将myhack-dll注入notepad-exe的程序" class="headerlink" title="（二）InjectDll.exe，即将myhack.dll注入notepad.exe的程序"></a>（二）InjectDll.exe，即将myhack.dll注入notepad.exe的程序</h3><p>程序流程：<br>（1）首先进行提权，如果不提权，OpenProcess()会报GetlastError[5]的错误，同时拿不到句柄。这是因为在xp环境下，虽然账号是管理员，但是权限默认没有启动。<br>（2）利用OpenProcess() 获得目标进程的句柄。这里指notepad.exe<br>（3）用VirtualAllocEx() 在目标进程空间分配一定的内存空间。用来写入DLL的路径<br>（4）用WriteProcessMemory() 将DLL路径字符串写入刚分配的内存。<br>（5）利用GetModuleHandle() 和GetProcessAddress() 得到LoadLibrary() 的地址。用来加载DLL<br>（6）利用CreateRemoteThread() 使LoadLibrary()加载DLL，实现DLL的注入。<br>给进程提权有三种方法：</p>
<h4 id="调试："><a href="#调试：" class="headerlink" title="调试："></a>调试：</h4><p>打开记事本，OD attach ，运行；<br>将OD的选项-&gt;调试设置-&gt;事件-&gt;中断在新模块DLL处选中，则程序当加载新的DLL时就会停住；<br>运行命令行，输入参数，运行InjectDll.exe程序。<br>将notepad.exe拖入Od 查看其PID 如图：<br><img src="18.png" alt=""><br>还是myhack.dll注入<br><img src="19.png" alt=""><br>在调试界面里的事件选择：<br><img src="20.png" alt=""><br>F9运行会发现myhack.dll<br><img src="21.png" alt=""><br>双击来到myhack.dll 入口点附近，下断点，接下来，将OD的中断在新的DLL入口处关闭，运行，就可以调试DLL程序了<br><img src="22.png" alt=""><br>下来F9运行 断在了刚才设置断点的地方 接下来F8单步运行 运行到这里发现myhack.dll字符串：<br><img src="23.png" alt=""><br>继续运行发现到了这里：<br><img src="24.png" alt=""><br>执行完后，说明这个函数实现了拷贝，但是……为啥要拷贝？<br><img src="25.png" alt=""><br>最后调用URLDownloadToFile() 函数实现下载。观察参数明白了，原来拷贝函数是为了得到下载存储的路径的呀！<br><img src="26.png" alt=""><br>运行程序：发现注入成功了！</p>
<h1 id="使用汇编语言编写注入代码"><a href="#使用汇编语言编写注入代码" class="headerlink" title="使用汇编语言编写注入代码"></a>使用汇编语言编写注入代码</h1><h2 id="新的EPI"><a href="#新的EPI" class="headerlink" title="新的EPI"></a>新的EPI</h2><p>在反汇编窗口右键，选择此处为新EIP，可以修改EIP指向选中的位置，与直接通过调试方式转到指定地址不一样的是，寄存器和栈中的内容未改变</p>
<p><img src="8.png" alt=""></p>
<h2 id="编写ThreadProc函数"><a href="#编写ThreadProc函数" class="headerlink" title="编写ThreadProc函数"></a>编写ThreadProc函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PUSH EBP</span><br><span class="line">MOV EBP,ESP                        ; 生成栈桢</span><br><span class="line">MOV ESI,DWORD PTR SS:[EBP+8]       ; ESI = pParam 从栈上获取函数参数       </span><br><span class="line">PUSH 6C6C                      </span><br><span class="line">PUSH 642E3233</span><br><span class="line">PUSH 72657375</span><br><span class="line">PUSH ESP                           ; - &quot;user32.dll&quot;(ESP为字符串首地址)，LoadLibraryA的参数</span><br><span class="line">CALL DWORD PTR DS:[ESI]            ; LoadLibraryA(&quot;user32.dll&quot;)</span><br><span class="line">PUSH 41786F</span><br><span class="line">PUSH 42656761</span><br><span class="line">PUSH 7373654D</span><br><span class="line">PUSH ESP                           ; - &quot;MessageBoxA&quot;(同上&quot;user32.dll&quot;的解释)</span><br><span class="line">PUSH EAX                           ; - hMod(EAX是LoadLibraryA的返回值)</span><br><span class="line">CALL DWORD PTR DS:[ESI+4]          ; GetProcAddress(hMod, &quot;MessageBoxA&quot;)</span><br><span class="line">PUSH 0                             ; - MB_OK (0)</span><br><span class="line">CALL 0040112C</span><br><span class="line">&lt;ASCII&gt;                            ; - &quot;ReverseCore&quot;, 0</span><br><span class="line">CALL 00401145</span><br><span class="line">&lt;ASCII&gt;                            ; - &quot;www.reversecore.com&quot;, 0</span><br><span class="line">PUSH 0                             ; - hWnd (0)</span><br><span class="line">CALL EAX                           ; MessageBoxA(0, &quot;www.reversecore.com&quot;, &quot;ReverseCore&quot;, 0)</span><br><span class="line">XOR EAX,EAX                        </span><br><span class="line">MOV ESP,EBP</span><br><span class="line">POP EBP                            </span><br><span class="line">RETN</span><br></pre></td></tr></table></figure>
<p>这里有些是字符串的代码 由于OD的原因 才会显示成汇编代码</p>
<h3 id="使用push指令将字符串数据压栈"><a href="#使用push指令将字符串数据压栈" class="headerlink" title="使用push指令将字符串数据压栈"></a>使用push指令将字符串数据压栈</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PUSH 41786F</span><br><span class="line">PUSH 42656761</span><br><span class="line">PUSH 7373654D</span><br></pre></td></tr></table></figure>
<p>这段代码还是比较好理解的，实际上是将字符串压到栈上</p>
<p>可以看到运行到call指令前，栈上的情况如下<br><img src="9.png" alt=""><br>字符串’user32.dll‘即为栈上的\x75\x73\x65\x72\x33\x32\x2e\x64\x6c\x6c</p>
<h3 id="使用call指令将字符串数据压栈"><a href="#使用call指令将字符串数据压栈" class="headerlink" title="使用call指令将字符串数据压栈"></a>使用call指令将字符串数据压栈</h3><p>第二种将字符串保存在代码中的方法为使用call指令</p>
<p>call func_address指令的本质为push eip+4，jmp func_address<br><img src="10.png" alt=""><br>在03d8002e处执行call 03d8003f实际上是执行了push 03d80033, jmp 03d8003f</p>
<p>可以在数据窗口中看出从03d80033到03d8003e存储的内容为ReverseCore的字符串，所以push 03d80033实际上是将字符串的首地址压栈</p>
<p>f7跟进call, 可以看到跳转到的内容如下<br><img src="11.png" alt=""><br>这仍然是一个将字符串压栈的过程，第一行的call指令将首地址为03d90044的字符串“<a href="http://www.reversecore.com”压栈" target="_blank" rel="noopener">www.reversecore.com”压栈</a></p>
<p>然后跳转到03d90058</p>
<p><img src="12.png" alt=""><br>该地址的内容如上图，调用了MessageBoxA函数</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/27/周报4-27/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/27/周报4-27/" itemprop="url">周报4.27</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-27T20:18:19+08:00">
                2019-04-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="OD学习记录（真难啊-QAQ）"><a href="#OD学习记录（真难啊-QAQ）" class="headerlink" title="OD学习记录（真难啊~~~QAQ）"></a>OD学习记录（真难啊~~~QAQ）</h1><h2 id="手动修复IAT"><a href="#手动修复IAT" class="headerlink" title="手动修复IAT"></a>手动修复IAT</h2><p>开始修复IAT。<br>第一步还是先找到OEP，到达OEP后，OD和进程本身不能关掉。脱壳过程中不能把程序关掉。<br>操作过程和之前相同，先选进程，右键，完整转存，脱壳完毕。<br>双击脱壳后的程序，无法打开。<br>第二步：使用importrec修复IAT。不是选择dump后的程序，而是到达OEP的加壳程序。为什么不选择脱壳后的程序呢？<br>因为我们需要提取源文件里的信息，放到脱壳后的文件里。然后放到脱壳后的程序 附件进程后，里面有个选项</p>
<p>如何使用填写这几个数字呢：<br>第一个选项是OEP栏：这里填写OEP的相对偏移地址就行<br>第二个选项是RVA：虚拟内存地址，这里填IAT的起始位置<br>大小：填写导入表大小，需要用IAT的末地址减去首地址。哪个是首地址，哪个是尾部地址？<br>有一个小技巧，能帮我们快速定位到IAT的开始和末尾。怎么做呢，在数据窗口右击-长型-地址，那么它的起始位置<br>就非常直观了：<br><img src="1.jpg" alt=""><br>OEP：10000<br>RVA：3184<br>大小：尾部一定得是00000000才行。而且得是最后一个00000000。<br>接下来就是修复PE头了</p>
<h2 id="打补丁"><a href="#打补丁" class="headerlink" title="打补丁"></a>打补丁</h2><p>程序很简单，只有两个窗口<br><img src="13.png" alt=""><img src="14.png" alt=""><br>（一）、使用OD载入程序，按F9跳转到入口点<br><img src="1.png" alt=""><br>（二）步入第一个call调用<br><img src="2.png" alt=""><br>（三）按f8步进来到40109B处<br>仔细分析这段代码，会发现这段代码的是第一轮解密代码，对004010F5到00401249（004010F5+0x154）这个区段的数据异或0x44<br><img src="3.png" alt=""><br>（四）继续按f8步进来到40109B处，可以发现两个循环，这个两个循环都负责解密<br><img src="4.png" alt=""><br>（五）继续按f8步进程序会返回到00401038处，此处需要主意的校验和计算和比较校验和的值。<br><img src="5.png" alt=""><br>（六）继续运行程序，会发现OEP，如下图<br><img src="6.png" alt=""><br>还有下面的跳转表的啦。。。。<br><img src="7.png" alt=""><br>（七）通过查找DialogBoxParamA的api手册，会发现4010F5是指向对话框的指针，跳转到4010F5这个地址之后，在往下滚动，发现字符串（x32dbg将这个区段解析为指令了，ascii码对的上，只能在内存窗口中查看）。</p>
<p><img src="8.png" alt=""><br>通过分析pe结构，我们会发现.text头会有很多代码洞空白区域<br><img src="9.png" alt=""><br>插入代码。.。。<br><img src="10.png" alt=""><br>修改JMP指令<br>修改前：<br><img src="11.png" alt=""><br>修改后：<br><img src="12.png" alt=""><br>然后就成功了。。。。。。不晓得我为啥有点问题QAQ。。。<br>中途想过之前的方法是直接修改数据窗口的内容来让实现修改  尝试以后发现程序有检测的  不能用 就只能用打补丁的方法咯</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/19/插入图片/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/19/插入图片/" itemprop="url">插入图片</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-19T15:17:59+08:00">
                2019-04-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="本地引用"><a href="#本地引用" class="headerlink" title="本地引用"></a>本地引用</h1><h2 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h2><p>当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](/images/image.jpg)</span><br></pre></td></tr></table></figure></p>
<p>图片既可以在首页内容中访问到，也可以在文章正文中访问到</p>
<h2 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h2><p>图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置_config.yml来生成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure></p>
<p>将_config.yml文件中的配置项post_asset_folder设为true后，执行命令$ hexo new post_name，在source/_posts中会生<br>成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](image.jpg)</span><br></pre></td></tr></table></figure></p>
<p>上述图片只能在文章中显示，但无法在首页中正常显示。<br>如果希望图片在文章和首页中同时显示，可以使用标签插件语法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img image.jpg This is an image %&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/17/PE文件结构/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/17/PE文件结构/" itemprop="url">PE文件结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-17T20:01:19+08:00">
                2019-04-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="PE文件结构"><a href="#PE文件结构" class="headerlink" title="PE文件结构"></a>PE文件结构</h1><p><img src="PE结构.png" alt=""></p>
<h2 id="PE文件结构详解（一）基本概念"><a href="#PE文件结构详解（一）基本概念" class="headerlink" title="PE文件结构详解（一）基本概念"></a>PE文件结构详解（一）基本概念</h2><p>1.DOS头是用来兼容MS-DOS操作系统的，目的是当这个文件在MS-DOS上运行时提示一段文字，大部分情况下是：This program cannot be run in DOS mode.还有一个目的，就是指明NT头在文件中的位置。</p>
<p>2.NT头包含windows PE文件的主要信息，其中包括一个‘PE’字样的签名，PE文件头（IMAGE_FILE_HEADER）和PE可选头（IMAGE_OPTIONAL_HEADER32），头部的详细结构以及其具体意义在PE文件头文章中详细描述。</p>
<p>3.节表：是PE文件后续节的描述，windows根据节表的描述加载每个节。<br>4.节：每个节实际上是一个容器，可以包含代码、数据等等，每个节可以有独立的内存权限，比如代码节默认<br>有读/执行权限，节的名字和数量可以自己定义，未必是上图中的三个。<br>当一个PE文件被加载到内存中以后，我们称之为“映象”（image），一般来说，PE文件在硬盘上和在内存里是不完全一样的，被加载到内存以后其占用的虚拟地址空间要比在硬盘上占用的空间大一些，这是因为各个节在硬盘上是连续的，而在内存中是按页对齐的，所以加载到内存以后节之间会出现一些“空洞”。</p>
<p>因为存在这种对齐，所以在PE结构内部，表示某个位置的地址采用了两种方式，针对在硬盘上存储文件中的地址，称为原始存储地址或物理地址表示距离文件头的偏移；另外一种是针对加载到内存以后映象中的地址，称为相对虚拟地址（RVA），表示相对内存映象头的偏移。</p>
<p>然而CPU的某些指令是需要使用绝对地址的，比如取全局变量的地址，传递函数的地址编译以后的汇编指令中肯定需要用到绝对地址而不是相对映象头的偏移，因此PE文件会建议操作系统将其加载到某个内存地址（这个叫基地址），编译器便根据这个地址求出代码中一些全局变量和函数的地址，并将这些地址用到对应的指令中。例如在IDA里看上去是这个样子：<br><img src="1.jpg" alt=""><br>这种表示方式叫做虚拟地址（VA）。</p>
<p>也许有人要问，既然有VA这么简单的表示方式为什么还要有前面的RVA呢？因为虽然PE文件为自己指定加载的基地址，但是windows有茫茫多的DLL，而且每个软件也有自己的DLL，如果指定的地址已经被别的DLL占了怎么办？如果PE文件无法加载到预期的地址，那么系统会帮他重新选择一个合适的基地址将他加载到此处，这时原有的VA就全部失效了，NT头保存了PE文件加载所需的信息，在不知道PE会加载到哪个基地址之前，VA是无效的，所以在PE文件头中大部分是使用RVA来表示地址的，而在代码中是用VA表示全局变量和函数地址的。那又有人要问了，既然加载基址变了以后VA都失效了，那存在于代码中的那些VA怎么办呢？答案是：重定位。系统有自己的办法修正这些值，到后续重定位表的文章中会详细描述。既然有重定位，为什么NT头不能依靠重定位采用VA表示地址呢（十万个为什么）？因为不是所有的PE都有重定位，早期的EXE就是没有重定位的。</p>
<h2 id="PE文件结构详解（二）可执行文件头"><a href="#PE文件结构详解（二）可执行文件头" class="headerlink" title="PE文件结构详解（二）可执行文件头"></a>PE文件结构详解（二）可执行文件头</h2><h3 id="一、DOS头"><a href="#一、DOS头" class="headerlink" title="一、DOS头"></a>一、DOS头</h3><p>DOS头的作用是兼容MS-DOS操作系统中的可执行文件，对于32位PE文件来说，DOS所起的作用就是显示一行文字，提示用户：我需要在32位windows上才可以运行。我认为这是个善意的玩笑，因为他并不像显示的那样不能运行，其实已经运行了，只是在DOS上没有干用户希望看到的工作而已，我们看一下这个头是如何定义的：</p>
<p>我们只需要关注两个域：</p>
<p>e_magic：一个WORD类型，值是一个常数0x4D5A，用文本编辑器查看该值位‘MZ’，可执行文件必须都是’MZ’开头。</p>
<p>e_lfanew：为32位可执行文件扩展的域，用来表示DOS头之后的NT头相对文件起始地址的偏移。<br><img src="2.png" alt=""></p>
<h3 id="二、NT头"><a href="#二、NT头" class="headerlink" title="二、NT头"></a>二、NT头</h3><p>顺着DOS头中的e_lfanew，我们很容易可以找到NT头，这个才是32位PE文件中最有用的头。</p>
<p>IMAGE_FILE_HEADER是PE文件头，c语言的定义是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_FILE_HEADER &#123;</span><br><span class="line">    WORD    Machine;</span><br><span class="line">    WORD    NumberOfSections;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    DWORD   PointerToSymbolTable;</span><br><span class="line">    DWORD   NumberOfSymbols;</span><br><span class="line">    WORD    SizeOfOptionalHeader;</span><br><span class="line">    WORD    Characteristics;</span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure></p>
<p>每个域的具体含义如下：</p>
<p>Machine：该文件的运行平台，是x86、x64还是I64等等，可以是下面值里的某一个。</p>
<p>NumberOfSections：该PE文件中有多少个节，也就是节表中的项数。</p>
<p>TimeDateStamp：PE文件的创建时间，一般有连接器填写。</p>
<p>PointerToSymbolTable：COFF文件符号表在文件中的偏移。</p>
<p>NumberOfSymbols：符号表的数量。</p>
<p>SizeOfOptionalHeader：紧随其后的可选头的大小。</p>
<p>Characteristics：可执行文件的属性，可以是下面这些值按位相或。</p>
<p>可以看出，PE文件头定义了PE文件的一些基本信息和属性，这些属性会在PE加载器加载时用到，如果加载器发现PE文件头中定义的一些属性不满足当前的运行环境，将会终止加载该PE。</p>
<p>另一个重要的头就是PE可选头，别看他名字叫可选头，其实一点都不能少，不过，它在不同的平台下是不一样的，例如32位下是IMAGE_OPTIONAL_HEADER32，而在64位下是IMAGE_OPTIONAL_HEADER64<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_OPTIONAL_HEADER &#123;</span><br><span class="line">    WORD    Magic;</span><br><span class="line">    BYTE    MajorLinkerVersion;</span><br><span class="line">    BYTE    MinorLinkerVersion;</span><br><span class="line">    DWORD   SizeOfCode;</span><br><span class="line">    DWORD   SizeOfInitializedData;</span><br><span class="line">    DWORD   SizeOfUninitializedData;</span><br><span class="line">    DWORD   AddressOfEntryPoint;</span><br><span class="line">    DWORD   BaseOfCode;</span><br><span class="line">    DWORD   BaseOfData;</span><br><span class="line">    DWORD   ImageBase;</span><br><span class="line">    DWORD   SectionAlignment;</span><br><span class="line">    DWORD   FileAlignment;</span><br><span class="line">    WORD    MajorOperatingSystemVersion;</span><br><span class="line">    WORD    MinorOperatingSystemVersion;</span><br><span class="line">    WORD    MajorImageVersion;</span><br><span class="line">    WORD    MinorImageVersion;</span><br><span class="line">    WORD    MajorSubsystemVersion;</span><br><span class="line">    WORD    MinorSubsystemVersion;</span><br><span class="line">    DWORD   Win32VersionValue;</span><br><span class="line">    DWORD   SizeOfImage;</span><br><span class="line">    DWORD   SizeOfHeaders;</span><br><span class="line">    DWORD   CheckSum;</span><br><span class="line">    WORD    Subsystem;</span><br><span class="line">    WORD    DllCharacteristics;</span><br><span class="line">    DWORD   SizeOfStackReserve;</span><br><span class="line">    DWORD   SizeOfStackCommit;</span><br><span class="line">    DWORD   SizeOfHeapReserve;</span><br><span class="line">    DWORD   SizeOfHeapCommit;</span><br><span class="line">    DWORD   LoaderFlags;</span><br><span class="line">    DWORD   NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure></p>
<p>Magic：表示可选头的类型。</p>
<p>MajorLinkerVersion和MinorLinkerVersion：链接器的版本号。</p>
<p>SizeOfCode：代码段的长度，如果有多个代码段，则是代码段长度的总和。</p>
<p>SizeOfInitializedData：初始化的数据长度。</p>
<p>SizeOfUninitializedData：未初始化的数据长度。</p>
<p>AddressOfEntryPoint：程序入口的RVA，对于exe这个地址可以理解为WinMain的RVA。对于DLL，这个地址可以理解为DllMain的RVA，如果是驱动程序，可以理解为DriverEntry的RVA。当然，实际上入口点并非是WinMain，DllMain和DriverEntry，在这些函数之前还有一系列初始化要完成，当然，这些不是本文的重点。</p>
<p>BaseOfCode：代码段起始地址的RVA。</p>
<p>BaseOfData：数据段起始地址的RVA。</p>
<p>ImageBase：映象（加载到内存中的PE文件）的基地址，这个基地址是建议，对于DLL来说，如果无法加载到这个地址，系统会自动为其选择地址。</p>
<p>SectionAlignment：节对齐，PE中的节被加载到内存时会按照这个域指定的值来对齐，比如这个值是0x1000，那么每个节的起始地址的低12位都为0。</p>
<p>FileAlignment：节在文件中按此值对齐，SectionAlignment必须大于或等于FileAlignment。</p>
<p>MajorOperatingSystemVersion、MinorOperatingSystemVersion：所需操作系统的版本号，随着操作系统版本越来越多，这个好像不是那么重要了。</p>
<p>MajorImageVersion、MinorImageVersion：映象的版本号，这个是开发者自己指定的，由连接器填写。</p>
<p>MajorSubsystemVersion、MinorSubsystemVersion：所需子系统版本号。</p>
<p>Win32VersionValue：保留，必须为0。</p>
<p>SizeOfImage：映象的大小，PE文件加载到内存中空间是连续的，这个值指定占用虚拟空间的大小。</p>
<p>SizeOfHeaders：所有文件头（包括节表）的大小，这个值是以FileAlignment对齐的。</p>
<p>CheckSum：映象文件的校验和。</p>
<p>SizeOfStackReserve：运行时为每个线程栈保留内存的大小。</p>
<p>SizeOfStackCommit：运行时每个线程栈初始占用内存大小。</p>
<p>SizeOfHeapReserve：运行时为进程堆保留内存大小。</p>
<p>SizeOfHeapCommit：运行时进程堆初始占用内存大小。</p>
<p>LoaderFlags：保留，必须为0。</p>
<p>NumberOfRvaAndSizes：数据目录的项数，即下面这个数组的项数。</p>
<p>DataDirectory：数据目录，这是一个数组.</p>
<h2 id="PE文件结构详解（三）VA-RVA-FA的概念"><a href="#PE文件结构详解（三）VA-RVA-FA的概念" class="headerlink" title="PE文件结构详解（三）VA,RVA,FA的概念"></a>PE文件结构详解（三）VA,RVA,FA的概念</h2><h3 id="一丶VA概念"><a href="#一丶VA概念" class="headerlink" title="一丶VA概念"></a>一丶VA概念</h3><p>VA (virtual Address) 虚拟地址的意思 ,比如随便打开一个PE,找下它的虚拟地址<br><img src="3.png" alt=""></p>
<h3 id="二丶模块地址-image-Base"><a href="#二丶模块地址-image-Base" class="headerlink" title="二丶模块地址(image Base)"></a>二丶模块地址(image Base)</h3><p>模块地址,就是exe加载到内存的时候,所在的地址,</p>
<p>比如MZ位置,在那个位置,那么对应模块地址就是这个位置</p>
<p>在OD中的内存中查看就是PE头<br><img src="4.png" alt=""></p>
<h3 id="三丶RVA-relative-Virtual-Address-相对虚拟地址偏移"><a href="#三丶RVA-relative-Virtual-Address-相对虚拟地址偏移" class="headerlink" title="三丶RVA(relative Virtual Address) 相对虚拟地址偏移"></a>三丶RVA(relative Virtual Address) 相对虚拟地址偏移</h3><p>假设我们找一个虚拟地址</p>
<p>VA = 0X4001200   (虚拟地址)</p>
<p>那么算出他的相对偏移</p>
<p>那么我们就要看他属于内存中那个节区了<br><img src="5.png" alt=""><br>可以看出,是在401000 ~ 41500之间,那么我们就用401000即可.</p>
<p>RVA = VA - 401000  得出的就是相对于虚拟地址的偏移</p>
<p>简化</p>
<p>RVA = 401200 - 401000 = 200(RVA)  那么偏移就是200了</p>
<h3 id="四丶VAtoRaw-虚拟地址-转化为文件偏移位置-就是虚拟地址的代码-在文件那个偏移位置存储"><a href="#四丶VAtoRaw-虚拟地址-转化为文件偏移位置-就是虚拟地址的代码-在文件那个偏移位置存储" class="headerlink" title="四丶VAtoRaw(虚拟地址,转化为文件偏移位置,就是虚拟地址的代码,在文件那个偏移位置存储)"></a>四丶VAtoRaw(虚拟地址,转化为文件偏移位置,就是虚拟地址的代码,在文件那个偏移位置存储)</h3><p>首先你要明白 RVA 怎么计算,FA怎么看.</p>
<p>我们随便找一个PE文件<br><img src="6.png" alt=""><br>我要找40101A虚拟地址,在文件中的位置.</p>
<p>思路:<br>1.获得虚拟地址(VA)  现在是401013</p>
<p>2.查看属于哪个节区表(点击内存查看,OllyDbg)<br><img src="7.png" alt=""><br>大于401000,小于402000,所以节区属于代码区,也就是code这个区域<br>3.算出RVA(相对虚拟地址偏移)</p>
<p>RVA = VA - 内存中节区地址</p>
<p>代入得到:</p>
<p>RVA = 401013 - 401000 </p>
<p>RVA = 13   (相对虚拟地址偏移是13)<br>4.RVA + 文件中的(相同节表,比如上面是code,那么文件中看的节表就是code这个节表)节表中的PointerToRawData成员记录的大小 得出虚拟地址在文件中的偏移</p>
<p>13 + (文件中节表的偏移) = 实际虚拟地址在文件偏移记录的代码地址.</p>
<p>总结:</p>
<p>　　其实很简单,首先看属于哪个节表的,  那么先算出RVA的值,然后让RVA + 文件中相同节表中的成员(PointRawData)  那么最终就是虚拟地址代码,在文件偏移的位置.</p>
<p>举个例子</p>
<p>VA = 401456</p>
<p>RVA = 401456 - (.text的位置当然这个你得自己看,可能不是,这里默认是了)401000 = 456</p>
<p>FA = 456 + (文件中节表中的PointRawData,我假设是200,这里具体看PE中怎么存储的)200 = 656(十六进制)</p>
<p>那么这个656文件偏移处,记录的就是 虚拟地址(VA)401456的二进制代码.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">loser</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">loser</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
