<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="chinese">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="loser的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="loser的博客">
<meta property="og:locale" content="chinese">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="loser的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>loser的博客</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="chinese">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">loser的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/03/IA-32指令/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/03/IA-32指令/" itemprop="url">IA-32指令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-03T20:12:38+08:00">
                2019-06-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/29/从TEB到PEB再到SEH/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/29/从TEB到PEB再到SEH/" itemprop="url">从TEB到PEB再到SEH</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-29T22:35:19+08:00">
                2019-05-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="TEB"><a href="#TEB" class="headerlink" title="TEB"></a>TEB</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>TEB指线程环境块 该结构体包含进程中运行线程的各种信息 进程中每个线程都对应一个TEB结构体 不同OS中TEB结构体形态略微不同</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>结构体中有非常多的成员，其中用户模式调试中起着重要作用的成员有两个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+0 NtTib : _NT_TIB</span><br><span class="line">...</span><br><span class="line">+0X30 ProcessEnvironmentBlock : Ptr32_PEB</span><br></pre></td></tr></table></figure></p>
<p>偏移0x30处的ProcessEnvironmentBlock是指向PEB（进程环境块）结构体的指针<br>偏移0处的_NT_TIB结构体内容如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _NT_TIB &#123;</span><br><span class="line">　struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList;</span><br><span class="line">　PVOID StackBase;</span><br><span class="line">　PVOID StackLimit;</span><br><span class="line">　PVOID SubSystemTib;</span><br><span class="line">　union &#123;</span><br><span class="line">　　PVOID FiberData;</span><br><span class="line">　　DWORD Version;</span><br><span class="line">　&#125;;</span><br><span class="line">　PVOID ArbitraryUserPointer;</span><br><span class="line">　struct _NT_TIB *Self;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>ExceptionList成员指向_EXCEPTION_REGISTRATION_RECORD结构体组成的链表，用于Windows OS的SEH（异常处理机制） </p>
<p>Self成员是结构体的自引用指针</p>
<h2 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h2><p>内核模式下可以直接查看内核的内存，但是用户模式下由于没有相关权限，所以只能通过OS提供的API来访问</p>
<h2 id="Ntdll-NtCurrentTeb"><a href="#Ntdll-NtCurrentTeb" class="headerlink" title="Ntdll.NtCurrentTeb()"></a>Ntdll.NtCurrentTeb()</h2><p>Ntdll.NtCurrentTeb()用来返回当前线程的TEB结构体的地址 我们接下来用OD看看函数内部如何实现的 我们打开notepad.exe<br><img src="1.png" alt=""><br>我们跳转到该API代码处<br><img src="2.png" alt=""><br>我们可以看到该API函数代码很简单 只返回FS:[18]的值 FS:[18]的实际地址为003D0018 内存中进入该地址 发现值为003D0000 我们仔细看发现TEB结构体的内存（003D0000）与FS段寄存器所指的段内存的基址是一样的 也就是说 TEB与FS段寄存器有着某种关联</p>
<h2 id="FS段寄存器"><a href="#FS段寄存器" class="headerlink" title="FS段寄存器"></a>FS段寄存器</h2><p>FS段寄存器就是专门用来指示当前线程的TEB结构体的<br>具体方法为<br>FS寄存器指示SDT的索引，其中存放着TEB结构体的地址</p>
<p>SDT位于内核内存区域，地址存放在GDTR（全局描述符表寄存器）中<br>因此GDTR+FS就可以得到TEB结构体的指针了</p>
<p>从而有<br>FS:[0x18] = FS:0<br>（+0x18处就是self指针）<br>FS:[0x30] = &amp;PEB<br>PEB结构体常用于反调试 接下来将讲解<br>FS:[0] = &amp;SEH<br>SEH是windows的结构化异常处理机制 常用于反调试技术</p>
<h1 id="PEB"><a href="#PEB" class="headerlink" title="PEB"></a>PEB</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>PEB（Process Environment Block，进程环境块）存放进程信息，每个进程都有自己的PEB信息。位于用户地址空间。</p>
<p>PEB地址可以通过函数PsGetProcessPeb(EPROCESS)来获得，也可以通过EPROCESS基地址加偏移0x1b0(x86)来获得。</p>
<h3 id="访问方法-1"><a href="#访问方法-1" class="headerlink" title="访问方法"></a>访问方法</h3><p>在前面我们已经知道 TEB.ProcessEnvironmentBlock成员位于距离TEB结构体Offset 30的位置处 我们有以下方法获取地址</p>
<p>#1：直接获取PEB地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV EAX,DWORD PTR FS:[30]  ; FS[30]=address of PEB</span><br></pre></td></tr></table></figure></p>
<p>#2：先获取TEB 再通过TEB.ProcessEnvironmentBlock成员（+30偏移）获取PEB地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV EAX,DWORD PTR FS:[18]  ; FS[18]=address of TEB</span><br><span class="line">MOV EAX,DWORD PTR DS:[EAX+30]  ; DS[EAX+30]=address of PEB</span><br></pre></td></tr></table></figure></p>
<p>接下来用OD打开一个exe文件 在EP代码处输入如图指令<br><img src="3.png" alt=""><br>然后单步执行 EAX寄存器存入FS:[30]的值 即PEB结构体的地址<br><img src="4.png" alt=""><br>我们在数据窗口看看PEB的地址<br><img src="5.png" alt=""></p>
<h3 id="PEB结构体定义"><a href="#PEB结构体定义" class="headerlink" title="PEB结构体定义"></a>PEB结构体定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _UNICODE_STR</span><br><span class="line">&#123;</span><br><span class="line">    USHORT Length;</span><br><span class="line">    USHORT MaximumLength;</span><br><span class="line">    PWSTR pBuffer;</span><br><span class="line">&#125; UNICODE_STR, *PUNICODE_STR;</span><br><span class="line"></span><br><span class="line">typedef struct _LDR_DATA_TABLE_ENTRY</span><br><span class="line">&#123;</span><br><span class="line">    //LIST_ENTRY InLoadOrderLinks; </span><br><span class="line">    LIST_ENTRY InMemoryOrderModuleList;</span><br><span class="line">    LIST_ENTRY InInitializationOrderModuleList;</span><br><span class="line">    PVOID DllBase;</span><br><span class="line">    PVOID EntryPoint;</span><br><span class="line">    ULONG SizeOfImage;</span><br><span class="line">    UNICODE_STR FullDllName;</span><br><span class="line">    UNICODE_STR BaseDllName;</span><br><span class="line">    ULONG Flags;</span><br><span class="line">    SHORT LoadCount;</span><br><span class="line">    SHORT TlsIndex;</span><br><span class="line">    LIST_ENTRY HashTableEntry;</span><br><span class="line">    ULONG TimeDateStamp;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br><span class="line"></span><br><span class="line">typedef struct _PEB_LDR_DATA //, 7 elements, 0x28 bytes</span><br><span class="line">&#123;</span><br><span class="line">    DWORD dwLength;</span><br><span class="line">    DWORD dwInitialized;</span><br><span class="line">    LPVOID lpSsHandle;</span><br><span class="line">    LIST_ENTRY InLoadOrderModuleList;</span><br><span class="line">    LIST_ENTRY InMemoryOrderModuleList;</span><br><span class="line">    LIST_ENTRY InInitializationOrderModuleList;</span><br><span class="line">    LPVOID lpEntryInProgress;</span><br><span class="line">&#125; PEB_LDR_DATA, *PPEB_LDR_DATA;</span><br><span class="line"></span><br><span class="line">typedef struct _PEB_FREE_BLOCK // 2 elements, 0x8 bytes</span><br><span class="line">&#123;</span><br><span class="line">    struct _PEB_FREE_BLOCK * pNext;</span><br><span class="line">    DWORD dwSize;</span><br><span class="line">&#125; PEB_FREE_BLOCK, *PPEB_FREE_BLOCK;</span><br><span class="line"></span><br><span class="line">typedef struct __PEB // 65 elements, 0x210 bytes</span><br><span class="line">&#123;</span><br><span class="line">    BYTE bInheritedAddressSpace;</span><br><span class="line">    BYTE bReadImageFileExecOptions;</span><br><span class="line">    BYTE bBeingDebugged;</span><br><span class="line">    BYTE bSpareBool;</span><br><span class="line">    LPVOID lpMutant;</span><br><span class="line">    LPVOID lpImageBaseAddress;</span><br><span class="line">    PPEB_LDR_DATA pLdr;</span><br><span class="line">    LPVOID lpProcessParameters;</span><br><span class="line">    LPVOID lpSubSystemData;</span><br><span class="line">    LPVOID lpProcessHeap;</span><br><span class="line">    PRTL_CRITICAL_SECTION pFastPebLock;</span><br><span class="line">    LPVOID lpFastPebLockRoutine;</span><br><span class="line">    LPVOID lpFastPebUnlockRoutine;</span><br><span class="line">    DWORD dwEnvironmentUpdateCount;</span><br><span class="line">    LPVOID lpKernelCallbackTable;</span><br><span class="line">    DWORD dwSystemReserved;</span><br><span class="line">    DWORD dwAtlThunkSListPtr32;</span><br><span class="line">    PPEB_FREE_BLOCK pFreeList;</span><br><span class="line">    DWORD dwTlsExpansionCounter;</span><br><span class="line">    LPVOID lpTlsBitmap;</span><br><span class="line">    DWORD dwTlsBitmapBits[2];</span><br><span class="line">    LPVOID lpReadOnlySharedMemoryBase;</span><br><span class="line">    LPVOID lpReadOnlySharedMemoryHeap;</span><br><span class="line">    LPVOID lpReadOnlyStaticServerData;</span><br><span class="line">    LPVOID lpAnsiCodePageData;</span><br><span class="line">    LPVOID lpOemCodePageData;</span><br><span class="line">    LPVOID lpUnicodeCaseTableData;</span><br><span class="line">    DWORD dwNumberOfProcessors;</span><br><span class="line">    DWORD dwNtGlobalFlag;</span><br><span class="line">    LARGE_INTEGER liCriticalSectionTimeout;</span><br><span class="line">    DWORD dwHeapSegmentReserve;</span><br><span class="line">    DWORD dwHeapSegmentCommit;</span><br><span class="line">    DWORD dwHeapDeCommitTotalFreeThreshold;</span><br><span class="line">    DWORD dwHeapDeCommitFreeBlockThreshold;</span><br><span class="line">    DWORD dwNumberOfHeaps;</span><br><span class="line">    DWORD dwMaximumNumberOfHeaps;</span><br><span class="line">    LPVOID lpProcessHeaps;</span><br><span class="line">    LPVOID lpGdiSharedHandleTable;</span><br><span class="line">    LPVOID lpProcessStarterHelper;</span><br><span class="line">    DWORD dwGdiDCAttributeList;</span><br><span class="line">    LPVOID lpLoaderLock;</span><br><span class="line">    DWORD dwOSMajorVersion;</span><br><span class="line">    DWORD dwOSMinorVersion;</span><br><span class="line">    WORD wOSBuildNumber;</span><br><span class="line">    WORD wOSCSDVersion;</span><br><span class="line">    DWORD dwOSPlatformId;</span><br><span class="line">    DWORD dwImageSubsystem;</span><br><span class="line">    DWORD dwImageSubsystemMajorVersion;</span><br><span class="line">    DWORD dwImageSubsystemMinorVersion;</span><br><span class="line">    DWORD dwImageProcessAffinityMask;</span><br><span class="line">    DWORD dwGdiHandleBuffer[34];</span><br><span class="line">    LPVOID lpPostProcessInitRoutine;</span><br><span class="line">    LPVOID lpTlsExpansionBitmap;</span><br><span class="line">    DWORD dwTlsExpansionBitmapBits[32];</span><br><span class="line">    DWORD dwSessionId;</span><br><span class="line">    ULARGE_INTEGER liAppCompatFlags;</span><br><span class="line">    ULARGE_INTEGER liAppCompatFlagsUser;</span><br><span class="line">    LPVOID lppShimData;</span><br><span class="line">    LPVOID lpAppCompatInfo;</span><br><span class="line">    UNICODE_STR usCSDVersion;</span><br><span class="line">    LPVOID lpActivationContextData;</span><br><span class="line">    LPVOID lpProcessAssemblyStorageMap;</span><br><span class="line">    LPVOID lpSystemDefaultActivationContextData;</span><br><span class="line">    LPVOID lpSystemAssemblyStorageMap;</span><br><span class="line">    DWORD dwMinimumStackCommit;</span><br><span class="line">&#125; _PEB, *_PPEB;</span><br></pre></td></tr></table></figure>
<h2 id="PEB的重要成员"><a href="#PEB的重要成员" class="headerlink" title="PEB的重要成员"></a>PEB的重要成员</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+002 BeingDebugged</span><br><span class="line">+008 ImageBaseAddress</span><br><span class="line">+00c Ldr</span><br><span class="line">+018 ProcessHeap</span><br><span class="line">+068 NtGlobaFlag</span><br></pre></td></tr></table></figure>
<h3 id="PEB-BeingDebugged"><a href="#PEB-BeingDebugged" class="headerlink" title="PEB.BeingDebugged"></a>PEB.BeingDebugged</h3><p>Kernel32.dll中有个名为Kernel32！IsDebuggerPresent（）的API 但普通的应用程序开发在并不常用</p>
<p>该API函数用来判断当前进程是否处于调试状态 并判断结果 该API通过检测PEB.BeingDebugged成员来确定是否处于调试状态（是为1 否为0）该API代码：</p>
<p><img src="6.png" alt=""><br>该值通常用于反调试技术 检测该值 若进程处于调试中 就终止调试</p>
<h3 id="PEB-ImageBaseAddress"><a href="#PEB-ImageBaseAddress" class="headerlink" title="PEB.ImageBaseAddress"></a>PEB.ImageBaseAddress</h3><p>PEB.ImageBaseAddress成员用来表示进程的ImageBase<br>GetModuleHandle（）API用来获取ImageBase<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HMODULE WINAPI GetModuleHandle(</span><br><span class="line">_In_opt_LPCTSTR lpModuleName</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>向lpModuleName参数赋值为NULL 调用GetModuleHandle()函数将返回进程被加载的ImageBase GetModuleHandle()的部分API代码：</p>
<p><img src="7.png" alt=""><br>向lpModuleName参数赋值为NULL值后 调用GetModuleHandle（）函数时执行如图代码 我们可以看到 PEB.ImageBaseAddress成员的值被设置到EAX寄存器</p>
<h3 id="PEB-Ldr"><a href="#PEB-Ldr" class="headerlink" title="PEB.Ldr"></a>PEB.Ldr</h3><p>PEB.Ldr成员是指向_PEB_LDR_DATA结构体的指针 代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _PEB_LDR_DATA //, 7 elements, 0x28 bytes</span><br><span class="line">&#123;</span><br><span class="line">    DWORD dwLength;</span><br><span class="line">    DWORD dwInitialized;</span><br><span class="line">    LPVOID lpSsHandle;</span><br><span class="line">    LIST_ENTRY InLoadOrderModuleList;</span><br><span class="line">    LIST_ENTRY InMemoryOrderModuleList;</span><br><span class="line">    LIST_ENTRY InInitializationOrderModuleList;</span><br><span class="line">    LPVOID lpEntryInProgress;</span><br><span class="line">&#125; PEB_LDR_DATA, *PPEB_LDR_DATA;</span><br></pre></td></tr></table></figure></p>
<p>当模块（DLL）加载到进程后 通过PEB.Ldr成员可以直接获取该模块的加载基地址 所以PEB.Ldr是非常重要的成员 _PEB_LDR_DATA 结构体成员有3个_LIST_ENTRY类型的成员（LIST_ENTRY InLoadOrderModuleList;LIST_ENTRY InMemoryOrderModuleList;LIST_ENTRY InInitializationOrderModuleList;）_LIST_ENTRY结构体的定义如代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedefstruct _LIST_ENTRY&#123;</span><br><span class="line">	struct _LIST_ENTRY*Flink</span><br><span class="line">	struct _LIST_ENTRY*Blink</span><br><span class="line">&#125; LIST_ENTRY,*PLIST_ENTRY</span><br></pre></td></tr></table></figure>
<p>我们可以看到_LIST_ENTRY结构体提供了双向链表机制 链表中保存的是_LDR_DATA_TABLE_ENTRY结构体的信息 代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _LDR_DATA_TABLE_ENTRY</span><br><span class="line">&#123;</span><br><span class="line">    //LIST_ENTRY InLoadOrderLinks; </span><br><span class="line">    LIST_ENTRY InMemoryOrderModuleList;</span><br><span class="line">    LIST_ENTRY InInitializationOrderModuleList;</span><br><span class="line">    PVOID DllBase;</span><br><span class="line">    PVOID EntryPoint;</span><br><span class="line">    ULONG SizeOfImage;</span><br><span class="line">    UNICODE_STR FullDllName;</span><br><span class="line">    UNICODE_STR BaseDllName;</span><br><span class="line">    ULONG Flags;</span><br><span class="line">    SHORT LoadCount;</span><br><span class="line">    SHORT TlsIndex;</span><br><span class="line">    LIST_ENTRY HashTableEntry;</span><br><span class="line">    ULONG TimeDateStamp;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br></pre></td></tr></table></figure></p>
<p>每个加载到进程中的DLL模块都有与之对应的_LDR_DATA_TABLE_ENTRY结构体 这些结构体互相链接 最终形成_LIST_ENTRY双向链表 需要注意的是：_PEB_LDR_DATA结构体中存在的3种链表 也就是说 存在多个_LDR_DATA_TABLE_ENTRY结构体 并且有三种链接方法可以将它们链接起来</p>
<h3 id="PEB-ProcessHeap-amp-PEB-NtGlobaFlag"><a href="#PEB-ProcessHeap-amp-PEB-NtGlobaFlag" class="headerlink" title="PEB.ProcessHeap&amp;PEB.NtGlobaFlag"></a>PEB.ProcessHeap&amp;PEB.NtGlobaFlag</h3><p>PEB.ProcessHeap&amp;PEB.NtGlobaFla常用于反调试技术 若处于调试状态 成员就持有特定值</p>
<h1 id="SEH"><a href="#SEH" class="headerlink" title="SEH"></a>SEH</h1><p>windows 提供的异常处理机制实际上只是一个简单的框架。我们通常所用的异常处理（比如 C++ 的 throw、try、catch）都是编译器在系统提供的异常处理机制上进行加工了的增强版本。这里先抛开增强版的不提，先说原始版本。</p>
<p>原始版本的机制很简单：谁都可以触发异常，谁都可以处理异常（只要它能看得见）。但是不管是触发还是处理都得先注册。系统把这些注册信息保存在一个链表里，并且这个链表保存在线程的数据结构里。也就是说，异常所涉及的一些行为都是线程相关的。比如，线程 T1 触发的异常就只能由线程 T1 来处理，其他线程根本就不知道 T1 发生了什么事，更不会处理。等注册完毕后，线程就可以抛出或处理异常了，系统也可以做相应的管理工作了。</p>
<p>系统提供的管理工作简单来说包括（但不限于）：找到触发异常的线程的异常处理链表（前面注册的那个），然后按照规则对该异常进行分发，根据分发后的处理结果再进行下一步的分发或者结束处理。</p>
<h2 id="SEH练习-1"><a href="#SEH练习-1" class="headerlink" title="SEH练习#1"></a>SEH练习#1</h2><p>先简单介绍练习示例seh.exe 该程序故意触发了内存非法访问异常 然后通过SEH机制来处理 并且使用PEB信息向程序添加简单的反调试代码  使程序在正常运行与调试运行时表现出不同的行为动作</p>
<h3 id="正常运行"><a href="#正常运行" class="headerlink" title="正常运行"></a>正常运行</h3><p>该程序非常简单 运行后弹出“Hello:)”字符串<br><img src="8.png" alt=""></p>
<h3 id="调试运行"><a href="#调试运行" class="headerlink" title="调试运行"></a>调试运行</h3><p>用OD打开<br><img src="9.png" alt=""><br>按下F9运行 发生非法访问异常后暂停调试<br><img src="10.png" alt=""><br>401019地址处的MOV指令用来触发异常 当前EAX寄存器的值为0 所以该指令的实际含义是向地址为0处写入1 但试图向未分配的内存地址0处写入某个值时 就会触发内存非法访问异常</p>
<p>在OD中查看状态窗口 如下<br><img src="11.png" alt=""><br><strong>在内存0处发生写入异常 若想将异常抛给程序 请使用Shift+Run/Step</strong></p>
<p>我们根据调试器的提示使用Shift+F9继续运行程序 调试开始运行弹出对话框：</p>
<p><img src="12.png" alt=""><br>可以看到它与正常运行时弹出的对话框是不一样的 以上就是“利用SEH机制的反调试技术”</p>
<h2 id="OS的异常处理方法"><a href="#OS的异常处理方法" class="headerlink" title="OS的异常处理方法"></a>OS的异常处理方法</h2><p>同一程序在正常运行和调试运行时的表现行为是不同的 这是由Winsows OS异常处理方法不同引起的</p>
<h3 id="正常运行时的异常处理方法"><a href="#正常运行时的异常处理方法" class="headerlink" title="正常运行时的异常处理方法"></a>正常运行时的异常处理方法</h3><p>进程运行时发生异常 OS会委托进程处理 若进程代码中存在具体的异常处理（SEH异常处理器）代码 则能顺利处理相关异常 程序继续运行 但如果进程内部没有具体实现SEH 那么相关异常就无法处理 OS就会启动默认的异常处理机制 终止进程运行</p>
<p><img src="13.png" alt=""></p>
<h3 id="调试运行时的异常处理方法"><a href="#调试运行时的异常处理方法" class="headerlink" title="调试运行时的异常处理方法"></a>调试运行时的异常处理方法</h3><p>调试运行中发生异常时，处理方法与上面有些不同。若被调试进程内部发生异常，OS会首先把异常抛给调试进程处理。调试器几乎拥有被调试者的所有权限，它不仅可以运行、终止被调试者，还拥有被调试进程的虚拟内存、寄存器的读写权限。需要特别指出的是，被调试者内部发生的所有异常(错误)都由调试器处理。所以调试过程中发生的所有异常(错误)都要先交由调试器管理(被调试者的SEH依据优先顺序推给调试器)。像这样，被调试者发生异常时，调试器就会暂停运行，必须采取某种措施来处理异常，完成后继续调试。遇到异常时经常采用的几种处理方法如下所示。</p>
<p>(1)直接修改异常:代码、寄存器、内存<br>被调试者发生异常时,调试器会在发生异常的代码处暂停,此时可以通过调试器直接修改有问题的代码 内存 寄存器等 排除异常后 调试器继续运行程序</p>
<p><strong>遇到图10中的异常时，采用直接修改异常的方法进行如下处理.</strong></p>
<p><strong>●由于EAX寄存器所指的地址值错误，所以只要把EAX寄存器的值修改为有效的内存地址即可。</strong></p>
<p><strong>●由于401019地址处的代码触发了异常，使用OllyDbg的汇编( Space)或编辑( Ctrl+E) 功能将相关代码修改为NOP指令，运行后也可排除异常。</strong></p>
<p><strong>●也可以使用OllyDbg的New Origin here(Ctrl+Gray *)功能改变程序的运行路径(因为无法直接修改EIP寄存器，所以需要借助该功能修改)。</strong></p>
<p><strong>请不要随意使用这些修改方法，必须在明确知道程序错误的情形下才能使用。</strong></p>
<p>(2)将异常抛给被调试者处理</p>
<p>如果被调试者内部存在SEH(异常处理函数)能够处理异常，那么异常通知会发送给被调试者，由被调试者自行处理。这与程序正常运行时的异常处理方式是一样的。 前面的seh.exe练习示例中，使用OllyDbg中的Shift+F7/F8/F9命令( StepInto/StepOver/Run )可以直接将当前异常抛还给被调试者。</p>
<p>(3) OS默认的异常处理机制</p>
<p>若调试器与被调试者都无法处理(或故意不处理)当前发生的异常，则OS的默认异常处理机制会处理它，终止被调试进程，同时结束调试。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>学习异常处理前 先了解操作系统中定义的异常<br><img src="14.png" alt=""><br>以上的调试列表 我们调试时会经常遇到5种具有代表性的异常</p>
<h3 id="EXCEPTION-ACCESS-VIOLATION-0xC0000005"><a href="#EXCEPTION-ACCESS-VIOLATION-0xC0000005" class="headerlink" title="EXCEPTION_ ACCESS VIOLATION(0xC0000005)"></a>EXCEPTION_ ACCESS VIOLATION(0xC0000005)</h3><p>试图访问不存在或者不具体访问权限的内存区域时 就会发生EXCEPTION_ ACCESS VIOLATION（非法访问异常 该异常最常见）</p>
<p><strong>MOV DWORD PTR DS:[0], 1<br>-&gt;内存地址0处是尚未分配的区域。<br>ADD DWoRD PTR DS: [401000]，1<br>-&gt;. text 节区的起始地址401000仅具有 “读”权限(无“写” 权限)。<br>XOR DWORD PTR DS: [80000000]，1234<br>-&gt;内存地址80000000属于内核区域，用户模式下无法访问。</strong></p>
<h3 id="EXCEPTION-BREAKPOINT-0x80000003"><a href="#EXCEPTION-BREAKPOINT-0x80000003" class="headerlink" title="EXCEPTION BREAKPOINT(0x80000003)"></a>EXCEPTION BREAKPOINT(0x80000003)</h3><p>在运行代码中设置断点后 CPU尝试执行该地址处的指令时 将发生EXCEPTION BREAKPOINT异常  调试器利用该异常实现断点功能</p>
<p><strong>INT3</strong><br>设置断点对应的汇编指令时INT3 对应的及其指令（IA-32）为0xcc CPU运行代码过程中若遇到汇编指令INT3 则会触发EXCEPTION BREAKPOINT异常 在OD中设置好断点后 确认该地址处是否真的会变成INT3 在OD中打开seh.exe文件 跳转到0040100处 设置好断点：</p>
<p><img src="14.png" alt=""><br>从图中可以看到，虽然401000地址处设置了断点，但是该地址处的指令并未变为INT3(汇编指令),也未由“68”变为“CC”(机器指令)。为什么跟前面讲的不一样呢?其实，这是OllyDbg耍的一个小花招。由于在O1lyDbg中按F2键设置的断点是用户用来调试的临时断点( UserTemporary Break Point ),所以不需要在调试画面中显示。在代码与内存中将用户设置的临时断点全部显示出来，反而会大大降低代码的可读性，给代码调试带来不便。换言之，实际进程内存中401000地址处的指令“68” 已经被更改为“CC”，但是为了调试方便，OllyDbg并 未将其显示出来。将进程内存转储之后可以看到更改后的CC指令,先使用PE Tools工具转储进程内存,如图下图</p>
<p>以seh_dump.exe文件名保存转储文件</p>
<p><img src="15.png" alt=""><br>使用PEView查看00401000地址处的指令<br><img src="16.png" alt=""><br>查看00401000地址处处可以看到cc指令 也就是说进程内存中的实际值为0xcc 但是OD调试器在显示时先将其更改为原来的操作码“68” 然后显示出来</p>
<p>以上就是断点内部工作原理，灵活运用这一原理能为程序调试带来很大便利。比如，使用Hex Editor工具打开PE文件，修改EP地址对应的文件偏移处的第一个字节为CC,然后运行该PE文件就会发生EXCEPTION BREAKPOINT异常，经过OS的默认异常处理后终止运行。若在系统注册表中将默认调试器设置为OllyDbg,那么发生以上异常时OS会自动运行01lyDbg调试器,附加发生异常的进程(第八部分中将详细讲解利用这一原理调试的方法)</p>
<h3 id="EXCEPTION-ILL-EGAL-INSTRUCTION-0xC000001D"><a href="#EXCEPTION-ILL-EGAL-INSTRUCTION-0xC000001D" class="headerlink" title="EXCEPTION ILL EGAL INSTRUCTION(0xC000001D)"></a>EXCEPTION ILL EGAL INSTRUCTION(0xC000001D)</h3><p>CPU在遇到无法解析的指令时引发该异常 比如“0FFF”指令在X86CPU中未定义 CPU遇到该指令将引发EXCEPTION ILL EGAL INSTRUCTION异常</p>
<p>下面用OD打开seh.exe 在EP代码处直接修改指令为0FFF 然后程序引发EXCEPTION ILL EGAL INSTRUCTION异常 暂停调试</p>
<p><img src="17.png" alt=""></p>
<h3 id="EXCEPTION-INT-DIVIDE-BY-ZERO-0xC0000094"><a href="#EXCEPTION-INT-DIVIDE-BY-ZERO-0xC0000094" class="headerlink" title="EXCEPTION INT DIVIDE BY ZERO(0xC0000094 )"></a>EXCEPTION INT DIVIDE BY ZERO(0xC0000094 )</h3><p>INTEGER（整数）除法运算中 若分母为0 则引发EXCEPTION INT DIVIDE BY ZERO异常 编写应用程序时偶尔会引发该异常 分母为变量时 该变量在某个瞬间变为0 执行除法运算就会引发EXCEPTION INT DIVIDE BY ZERO异常 打开seh.exe 使用汇编指令在EP代码处修改代码 如图：</p>
<p><img src="18.png" alt=""><br>401220地址处的DIV ECX指令执行除法运算 然后将结果保存到EAX寄存器 但此时ECX寄存器的值为0 所以引发EXCEPTION INT DIVIDE BY ZERO异常 暂停运行</p>
<h3 id="EXC-EPTION-SINGLE-STEP-0x80000004"><a href="#EXC-EPTION-SINGLE-STEP-0x80000004" class="headerlink" title="EXC EPTION SINGLE STEP(0x80000004 )"></a>EXC EPTION SINGLE STEP(0x80000004 )</h3><p>Single Step(单步)的含义是执行1条指令，然后暂停。CPU进入单步模式后，每执行一条指令就会引发EXCEPTION_ SINGLE STEP异常，暂停运行。将EFLAGS寄存器的TF ( Trap Flag,陷阱标志)位设置为1后，CPU就会进入单步工作模式。</p>
<h2 id="SEH详细说明"><a href="#SEH详细说明" class="headerlink" title="SEH详细说明"></a>SEH详细说明</h2><h3 id="SEH链"><a href="#SEH链" class="headerlink" title="SEH链"></a>SEH链</h3><p>SEH是以链的形式存在 第一个异常处理器若未处理相关异常 它就会被传递到下一个异常处理器 直到被处理 从技术层面来看 SEH是由_EXCEPTION_REGISTRATION_RECORD结构体组成的链表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _EXCEPTION_REGISTRATION_RECORD &#123;</span><br><span class="line">        //指向下一个 EXCEPTION_REGISTRATION_RECORD，由此构成一个异常注册信息链表。</span><br><span class="line">        //链表中的最后一个结点会将 Next 置为 EXCEPTION_CHAIN_END，表示链表到此结束。</span><br><span class="line">        struct _EXCEPTION_REGISTRATION_RECORD *Next;</span><br><span class="line">        PEXCEPTION_ROUTINE Handler;  //指向异常处理函数</span><br><span class="line">&#125; EXCEPTION_REGISTRATION_RECORD;</span><br></pre></td></tr></table></figure>
<h3 id="异常处理函数的定义"><a href="#异常处理函数的定义" class="headerlink" title="异常处理函数的定义"></a>异常处理函数的定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXCEPTION_DISPOSIYION_except_handler (</span><br><span class="line">       EXCEPTION_RECORD	*pRecord,</span><br><span class="line">       EXCEPYION_REGISTRATION_RECORD  *pFrame,</span><br><span class="line">       CONREXT				*pContext,</span><br><span class="line">       PVOID 				pValue,</span><br><span class="line">       );</span><br></pre></td></tr></table></figure>
<p>当接收到异常后，系统找到当前线程的异常链表，从链表中的第一个结点开始遍历，找到一个 EXCEPTION_REGISTRATION_RECORD 就调用它的 Handler，并把该异常(类型为 EXCEPTION_RECORD 的参数)表示传递给该 Handler，Handler 处理并返回一个类型为 EXCEPTION_DISPOSITION 的枚举值。该返回值指示系统下一步该做什么</p>
<p>_EXCEPTION_RECORD结构体的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _EXCEPTION_RECORD &#123;</span><br><span class="line">  DWORD                    ExceptionCode;	//异常代码</span><br><span class="line">  DWORD                    ExceptionFlags;</span><br><span class="line">  struct _EXCEPTION_RECORD *ExceptionRecord;</span><br><span class="line">  PVOID                    ExceptionAddress;	//异常发生地址</span><br><span class="line">  DWORD                    NumberParameters;</span><br><span class="line">  ULONG_PTR                ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];</span><br><span class="line">												//15</span><br><span class="line">  &#125; EXCEPTION_RECORD;</span><br></pre></td></tr></table></figure></p>
<p>异常处理的第三个指针指向CONTEXT结构体的指针 定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _CONTEXT</span><br><span class="line">&#123;</span><br><span class="line">    DWORD           ContextFlags    // -|               +00h</span><br><span class="line">    DWORD           Dr0             //  |               +04h</span><br><span class="line">    DWORD           Dr1             //  |               +08h</span><br><span class="line">    DWORD           Dr2             //  &gt;调试寄存器     +0Ch</span><br><span class="line">    DWORD           Dr3             //  |               +10h</span><br><span class="line">    DWORD           Dr6             //  |               +14h</span><br><span class="line">    DWORD           Dr7             // -|               +18h</span><br><span class="line"></span><br><span class="line">    FLOATING_SAVE_AREA FloatSave;   //浮点寄存器区      +1Ch~~~88h</span><br><span class="line"></span><br><span class="line">    DWORD           SegGs           //-|                +8Ch</span><br><span class="line">    DWORD           SegFs           // |\段寄存器       +90h</span><br><span class="line">    DWORD           SegEs           // |/               +94h</span><br><span class="line">    DWORD           SegDs           //-|                +98h</span><br><span class="line"></span><br><span class="line">    DWORD           Edi             //________          +9Ch</span><br><span class="line">    DWORD           Esi             // |  通用          +A0h</span><br><span class="line">    DWORD           Ebx             // |   寄           +A4h</span><br><span class="line">    DWORD           Edx             // |   存           +A8h</span><br><span class="line">    DWORD           Ecx             // |   器           +ACh</span><br><span class="line">    DWORD           Eax             //_|___组_          +B0h</span><br><span class="line"></span><br><span class="line">    DWORD           Ebp             //++++++            +B4h</span><br><span class="line">    DWORD           Eip             // |控制            +B8h</span><br><span class="line">    DWORD           SegCs           // |寄存            +BCh</span><br><span class="line">    DWORD           EFlag           // |器组            +C0h</span><br><span class="line">    DWORD           Esp             // |                +C4h</span><br><span class="line">    DWORD           SegSs           //++++++            +C8h</span><br><span class="line"></span><br><span class="line">    BYTE    ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];</span><br><span class="line">&#125; CONTEXT;</span><br><span class="line">    typedef     CONTEXT     *PCONTEXT;</span><br><span class="line">    #define     MAXIMUM_SUPPORTED_EXTENSION     512</span><br></pre></td></tr></table></figure></p>
<p> CONTEXT结构体用来备份CPU寄存器的值，因为多线程环境下需要这样做。每个线程内部都拥有1个CONTEXT结构体。CPU暂时离开当前线程去运行其他线程时，CPU寄存器的值就会保存到当前线程的CONTEXT结构体; CPU再次运行该线程时，会使用保存在CONTEXT结构体的值来覆盖CPU寄存器的值，然后从之前暂停的代码处继续执行。通过这种方式，OS可以在多线程环境下安全运行各线程</p>
<p> 异常发生时，执行异常代码的线程就会中断运行，转而运行SEH(异常处理器/异常处理函数),此时OS会把线程的CONTEXT结构体的指针传递给异常处理函数(异常处理器)的相应参数。CONTEXT的结构体成员中有1个Eip成员(偏移量:B8)。在异常处理函数中将参数传递过来的CONTEXT.Eip设置为其他地址，然后返回异常处理函数。这样，之前暂停的线程会执行新设置的EIP地址处的代码( 反调试中经常采用这一技术，练习示例seh.exe中也采用了该技术，后面会详细分析)。在代码异常处理函数代码中 可以看到异常处理函数的返回值为EXCEPTION DISPOSITION枚举类型，下面了解一下该类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> typedef enum _EXCEPTION_DISPOSITION</span><br><span class="line">&#123;</span><br><span class="line">　　ExceptionContinueExecution = 0</span><br><span class="line">   ExceptionContinueSearch = 1</span><br><span class="line">   ExceptionNestedException = 2</span><br><span class="line">   ExceptionCollidedUnwind = 3</span><br><span class="line">&#125;EXCEPTION_DISPOSITION</span><br></pre></td></tr></table></figure>
<p>异常处理后会返回ExceptionContinueExecution（0）从发生异常的代码处继续运行 若当前异常处理器无法处理 则返回ExceptionContinueSearch（1） 将异常传递给下一个异常处理器</p>
<h3 id="TEB-NtTib-ExceptionList"><a href="#TEB-NtTib-ExceptionList" class="headerlink" title="TEB.NtTib.ExceptionList"></a>TEB.NtTib.ExceptionList</h3><p>通过TEB结构体成员很容易的访问进程SEH链<br>TEB.NtTib.ExceptionList成员是PEB结构体的第一个成员 FS段寄存器指向段内存的起始地址 TEB结构体即位于此 我们可以通过以下公式获取</p>
<p>TEB.NtTib.ExceptionList=FS:[0]</p>
<h3 id="SEH安装方法"><a href="#SEH安装方法" class="headerlink" title="SEH安装方法"></a>SEH安装方法</h3><p>在c语言中用<strong>try、</strong>finally和__except等术语可以容易的添加SEH 在汇编中也是一样的简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PUSH @MyHandler				;异常处理器</span><br><span class="line">PUSH DWORD PTR FS:[0]		;Head of SEH Linked List</span><br><span class="line">MOV DWORD PTR FS:[0],ESP	;添加链表</span><br></pre></td></tr></table></figure></p>
<p>看代码就容易理解了。“在程序代码中安装SEH”就是指，将自身的异常处理器添加到已有的SEH链。从技术层面讲，就是将自身的EXCEPTION REGISTRATION RECORD结构体链接到EXCEPTION_ REGISTRATION_ RECORD结构体链表。前面出现的seh.exe程序就是采用上述汇编代码添加的SEH，下面再次调试seh.exe程序以进一步了解添加SEH的方法及其工作原理。</p>
<h2 id="SEH练习-2（seh-exe）"><a href="#SEH练习-2（seh-exe）" class="headerlink" title="SEH练习#2（seh.exe）"></a>SEH练习#2（seh.exe）</h2><p>打开OD使代码运行到00401000处（main函数）<br><img src="20.png" alt=""><br>位于401000 401005 40100c处的三条指令与“SEH安装”的代码是相同的 新添加的异常处理器就是位于40105a处的异常处理函数</p>
<h3 id="查看SEH链"><a href="#查看SEH链" class="headerlink" title="查看SEH链"></a>查看SEH链</h3><p>继续运行代码到401005处 查看FS:[0]的值 其值就是SEH链的起始地址<br><img src="21.png" alt=""><br>从代码信息窗口中可以看到，FS:[0]=[7FFDE000]=12FF78,其中12FF78就是SEH链的起始地址(即EXCEPTION REGISTRATION RECORD结构体链表的起始地址)。在上图的栈窗口中查看地址12FF78,可以发现第一个EXCEPTION REGISTRATION RECORD结构体( Next=12FFC4,Handler-402730 )。异常处理器地址402730存在于seh.exe进程的代码节区(该异常处理器是VC++生成PE文件时默认添加到其启动函数的,请各位自行查看位于402730地址处的异常处理器代码)。然后转到12FFC4地址处，查看链表中的第二个EXCEPTION _REGISTRATION RECORD结构体</p>
<p><img src="22.png" alt=""><br>从图中可以看到，第二个结构体的Next成员值为FFFFFFF,所以第二个EXCEPTION_REGISTRATION RECORD结构体也是SEH链表的最后- - 个结构体。异常处理器地址为7717D74D,它位于ntdll.dll模块的代码区域,是OS的默认异常处理器(创建进程时, OS会自动产生默认的SEH )。</p>
<h3 id="添加SEH"><a href="#添加SEH" class="headerlink" title="添加SEH"></a>添加SEH</h3><p>运行401005处的指令 查看栈窗口<br><img src="23.png" alt=""><br>栈中新创建了EXCEPTION_REGISTRATION RECORD结构体 继续运行40100c处的代码 查看栈窗口</p>
<p><img src="24.png" alt=""><br>栈窗口出现了新生成的SEH的注释 新的异常处理器就是这样添加SEH链</p>
<p>OD中有查看SEH链的功能（Alt+s）<br><img src="25.png" alt=""></p>
<h3 id="发生异常"><a href="#发生异常" class="headerlink" title="发生异常"></a>发生异常</h3><p>如果执行401019地址处的MOV DWORD PTR DS:[EAX],1指令,就会引发EXCEPTION_ ACCESS_ VIOLATION异常(该异常已做说明，此处不再赘述)。此时程序处在调试之中，根据异常处理的顺序，OS会把控制权交给调试器(异常处理器( 40105A)未运行)。在40105A地址处设置断点，然后按Shift+F9组合键，再将异常派送给被调试进程( seh.exe),调试器暂停在设置的断点处( 40105A )。</p>
<p>如图所示，被调试者会调用注册在自身SEH链中的异常处理器来处理异常。设置好断点后，接下来即可调试异常处理器<br><img src="26.png" alt=""></p>
<h3 id="查看异常处理器参数"><a href="#查看异常处理器参数" class="headerlink" title="查看异常处理器参数"></a>查看异常处理器参数</h3><p>调用SEH时 栈中的参数如图<br><img src="27.png" alt=""><br>第一个参数（ESP+4）指向EXCEPTION_RECORD结构体的指针pRecord（12fac0） 数据窗口查看：</p>
<p><img src="28.png" alt=""><br>参考图中以及EXCEPTION_RECORD结构体的定义可知 ExceptionCode（pRecord+0）为C0000005 发生异常的代码地址为401019</p>
<p>第二个参数（ESP+8）是指向EXCEPTION_REGISTRATION RECORD结构体的指针（pFrame） 其值为0012ff3c 是SEH链的起始地址</p>
<p>第三个参数（ESP+c）是指向CONTEXT结构体的指针pContext（0012fadc）查看指针pContext所指的地址空间 如图 COntext是一个非常大的结构体（大部分为NULL）其中特别需要注意的是Eip成员它位于结构体偏移B8的位置 存储着发生异常的代码地址</p>
<p><img src="29.png" alt=""><br>最后一个参数（pValue）（ESP+10）供系统使用 可以忽略</p>
<h3 id="调试异常处理器"><a href="#调试异常处理器" class="headerlink" title="调试异常处理器"></a>调试异常处理器</h3><p>40105a地址处的异常处理器中存在着调试器的检测代码 虽然简单 但非常有代表性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV ESI,DWORD PTR SS:[ESP+0C]	;ESI=pContext</span><br></pre></td></tr></table></figure></p>
<p>[ESP+c]是异常处理器的第三个参数pContext的值 以上命令用来将pContext地址（12fadc）传送入ESI寄存器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV EAX,DWORD PTR FS:[30]</span><br></pre></td></tr></table></figure></p>
<p>上述指令用来将FS：[30]的值传送给EAX FS:[30]就是PEB结构体的起始地址<br><img src="30.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CMP BYTE PTR DS:[EAX+2],1</span><br><span class="line">``` </span><br><span class="line">上述指令用来读取[EAX+2]zi&apos;jie&apos;zhi地址中的1个字节值 然后和1比较 由于EAX当前保存着PEB的起始地址 所以[EAX+2]指的是PEB.BeingDebugged成员 从图中可以看出[EAX+2]=[7ffdf002]=PEB.BeingDebugged的值为1 表示进程处于调试状态</span><br><span class="line"></span><br><span class="line">![](31.png)</span><br></pre></td></tr></table></figure></p>
<p>JNE SHORT 00401076<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">若CMP指令的两个对象不同 则JNE就进行跳转 由于PEB.BeingDebugged的值为1 则不进行跳转</span><br><span class="line">![](32.png)</span><br></pre></td></tr></table></figure></p>
<p>MOV DWORD PTR DS:[ESI+0B8],00401023<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">上述指令用来将pContext-&gt;Eip值改为401023 异常处理器终止时 发生异常的线程会运行401023地址处的代码 弹出“Debugger detected:(”消息框</span><br><span class="line"></span><br><span class="line">![](33.png)</span><br><span class="line">在401023处设置一个断点</span><br></pre></td></tr></table></figure></p>
<p>JMP SHORT 00401080<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于pContext-&gt;Eip值改变 所以执行跳转到异常处理器的终止代码处（401080）</span><br></pre></td></tr></table></figure></p>
<p>MOV DWORD PTR DS:[ESI+0B8],00401039<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">若程序运行在非调试状态下，则执行401068地址处的JNZ指令,跳转到401076地址处。如上所示，401076地址处的指令用来将pContext→Eip值更改为401039， 401039地址处的代码用来弹出消息对话框，显示“Hello:)”消息文本</span><br><span class="line"></span><br><span class="line">![](34.png)</span><br></pre></td></tr></table></figure></p>
<p>XOR EAX,EAX<br>RETN<br><code>`</code><br>最后两条指令中先将返回值( EAX )设置为0,然后异常处理器返回。返回值0代表EXCEPTION_CONTINUE_ EXECUTION,表示异常得到处理，相关线程可以继续运行</p>
<p><strong>本练习示例( seh.exe)的目的在于向各位展示使用SEH进行反调试的技术。所以在代码中故意引发了异常，然后在SEH中根据调试与否修改了运行分支。若熟悉了该技术，调试压缩器/保护器类的文件时会非常有帮助。</strong></p>
<p>运行到401082地址处的RETN指令时，控制权被返回至ntdlI1模块中的代码区域，它属于系统区域，所以在OllyDbg中按F9运行键后，调试会在401023地址处(设置有断点)暂停。</p>
<p>使用StepOver(F8)指令使调试运行到401031地址处的CALL指令,弹出一个消息框。按“确定”按钮关闭消息框后，执行401037地址处的JMP SHORT 40104D指令，跳转到删除SEH的代码处( 40104D )。</p>
<h3 id="删除SEH"><a href="#删除SEH" class="headerlink" title="删除SEH"></a>删除SEH</h3><p>在程序终止前删除已注册的SHE,如图所示。</p>
<p>调试运行到40104D地址处查看栈, EXCEPTION REGISTRATION RECORD结构体存储在其中( 12FF3C ),该结构体是SEH链中最初运行的异常处理器。40104D处的POP DWORD PTR FS:[0]指令用来读取栈值( 12FF78),并将其放人FS:[0]。FS:[0]是TEB.NtTib. ExceptionList, 12FF78就是下一个SEH的起始地址。执行该命令后，前面注册的SEH ( 12FF3C )被从SEH链中删除。然后执行401054地址处的ADD ESP,4指令,将栈中的异常处理器地址( 40105A)也删除。请各位反复调试，查清栈中数据变化的情况。</p>
<p><img src="35.png" alt=""></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>SEH大量应用于压缩器、保护器、恶意程序( Malware ),用来反调试。大家研究与调试SEH的过程中，会进一步加深对Wiondows OS内部结构的认识,提高自身逆向分析技术水平。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/26/TLS回调函数/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/26/TLS回调函数/" itemprop="url">TLS回调函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-26T17:11:45+08:00">
                2019-05-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="练习-1"><a href="#练习-1" class="headerlink" title="练习#1"></a>练习#1</h1><p>运行练习文件（HelloTls.exe）弹出消息框 单击 确定 结束程序</p>
<p><img src="1.png" alt=""><br>接下来使用OD打开程序并运行TLS文件 出现如图对话框</p>
<p><img src="2.png" alt=""><br>我们发现对话框与源程序的内容不同 单击 确定 终止程序 如图</p>
<p><img src="3.png" alt=""><br>出现这种情况的原因在于程序运行EP代码前先调用了TLS回调函数 而这一函数中含有反调试代码</p>
<h1 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h1><h2 id="IMAGE-DATA-DIRECTORY-9"><a href="#IMAGE-DATA-DIRECTORY-9" class="headerlink" title="IMAGE_DATA_DIRECTORY[9]"></a>IMAGE_DATA_DIRECTORY[9]</h2><p>如果在编程中用了TLS回调函数 PE头文件就会设置TLS表项目 如下图</p>
<p><img src="4.png" alt=""></p>
<h2 id="IMAGE-TLS-DIRECTORY"><a href="#IMAGE-TLS-DIRECTORY" class="headerlink" title="IMAGE_TLS_DIRECTORY"></a>IMAGE_TLS_DIRECTORY</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_DATA_DIRECTORY[9]:IMAGE_TLS_DIRECTOR</span><br><span class="line">Y</span><br><span class="line">typedef struct _IMAGE_TLS_DIRECTORY64 &#123;</span><br><span class="line">ULONGLONG StartAddressOfRawData;</span><br><span class="line">ULONGLONG EndAddressOfRawData;</span><br><span class="line">ULONGLONG AddressOfIndex; // PDWORD</span><br><span class="line">ULONGLONG AddressOfCallBacks; //</span><br><span class="line">PIMAGE_TLS_CALLBACK *;</span><br><span class="line">DWORD SizeOfZeroFill;</span><br><span class="line">DWORD Characteristics;</span><br><span class="line">&#125; IMAGE_TLS_DIRECTORY64;</span><br><span class="line">typedef IMAGE_TLS_DIRECTORY64*PIMAGE_TLS_DIRECTORY64;</span><br><span class="line"></span><br><span class="line">typedef struct_IMAGE_TLS_DIRECTORY32 &#123;</span><br><span class="line">DWORD StartAddressOfRawData;</span><br><span class="line">DWORD EndAddressOfRawData;</span><br><span class="line">DWORD AddressOfIndex; // PDWORD</span><br><span class="line">DWORD AddressOfCallBacks; //</span><br><span class="line">PIMAGE_TLS_CALLBACK *;</span><br><span class="line">DWORD SizeOfZeroFill;</span><br><span class="line">DWORD Characteristics;</span><br><span class="line">&#125; IMAGE_TLS_DIRECTORY32;</span><br><span class="line">typedef IMAGE_TLS_DIRECTORY32*PIMAGE_TLS_DIRECTORY32;</span><br><span class="line">#ifdef _WIN64</span><br><span class="line">typedef IMAGE_TLS_DIRECTORY64	IMAGE_TLS_DIRECTORY;</span><br><span class="line">typedef PIMAGE_TLS_DIRECTORY64	PIMAGE_TLS_DIRECTORY;</span><br><span class="line">#else</span><br><span class="line">typedef IMAGE_TLS_DIRECTORY32	IMAGE_TLS_DIRECTORY;</span><br><span class="line">typedef PIMAGE_TLS_DIRECTORY32	PIMAGE_TLS_DIRECTORY;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>IMAGE_TLS_DIRECTORY结构体有两种版本 分别为32位版本和64位版本 我们用PEView查看IMAGE_TLS_DIRECTORY结构体 成员如图</p>
<p><img src="5.png" alt=""><br>代码逆向中最重要的时Address of Callbacks 该值指向含有TLS回调函数地址的数组 这意味着可以向同一程序注册多个TLS回调函数</p>
<h2 id="回调函数地址数组"><a href="#回调函数地址数组" class="headerlink" title="回调函数地址数组"></a>回调函数地址数组</h2><p>回调函数地址数组<br><img src="6.png" alt=""><br>数组中实际储存的是TLS回调函数的地址 进程启动运行时 逐一调用储存在该数组的函数</p>
<h1 id="TLS回调函数"><a href="#TLS回调函数" class="headerlink" title="TLS回调函数"></a>TLS回调函数</h1><p>TLS(Thread Local Storage,线程局部储存)，主要用于给线程独立的传值，由于线程不拥有进程的资源，所以几个同一进程的几个线程需要独立赋值时的需要通过TLS技术。每个线程创建时都会分配一个index所以，这个索引index是全局变量，线程根据index来获取其他线程传过来的返回值。TLS有一个特点，就是它通常在程序EP前就要运行，所以起始TLS才是个程序真正的开始。利用这一特点，可以用来进行的程序的反调试。</p>
<p>创建和终止某线程时 TLS回调函数都会自动调用执行 前后共两次 执行EP代码前 TLS回调函数会先被执行 常用于反调试技术</p>
<h1 id="练习-2"><a href="#练习-2" class="headerlink" title="练习#2"></a>练习#2</h1><p>TlsTest.exe程序使用VC++编写的 充分展现了TLS回调函数的方法 源代码如图：</p>
<p><img src="7.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;windows.h&gt;</span><br><span class="line"></span><br><span class="line">#pragma comment(linker, &quot;/INCLUDE:__tls_used&quot;)</span><br><span class="line"></span><br><span class="line">void print_console(char* szMsg)</span><br><span class="line">&#123;</span><br><span class="line">    HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE);</span><br><span class="line">    </span><br><span class="line">    WriteConsoleA(hStdout, szMsg, strlen(szMsg), NULL, NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void NTAPI TLS_CALLBACK1(PVOID DllHandle, DWORD Reason, PVOID Reserved)</span><br><span class="line">&#123;</span><br><span class="line">    char szMsg[80] = &#123;0,&#125;;</span><br><span class="line">    wsprintfA(szMsg, &quot;TLS_CALLBACK1() : DllHandle = %X, Reason = %d\n&quot;,</span><br><span class="line">                DllHandle, Reason);</span><br><span class="line">    print_console(szMsg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void NTAPI TLS_CALLBACK2(PVOID DllHandle, DWORD Reason, PVOID Reserved)</span><br><span class="line">&#123;</span><br><span class="line">    char szMsg[80] = &#123;0,&#125;;</span><br><span class="line">    wsprintfA(szMsg, &quot;TLS_CALLBACK2() : DllHandle = %X, Reason = %d\n&quot;,</span><br><span class="line">                DllHandle, Reason);</span><br><span class="line">    print_console(szMsg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma data_seg(&quot;.CRT$XLX&quot;)</span><br><span class="line">    PIMAGE_TLS_CALLBACK pTLS_CALLBACKs[] = &#123;TLS_CALLBACK1, TLS_CALLBACK2, 0&#125;;</span><br><span class="line">#pragma data_seg()</span><br><span class="line"></span><br><span class="line">DWORD WINAPI ThreadProc(LPVOID lParam)</span><br><span class="line">&#123;</span><br><span class="line">    print_console(&quot;ThreadProc() start\n&quot;);</span><br><span class="line">    </span><br><span class="line">    print_console(&quot;ThreadProc() end\n&quot;);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    HANDLE hThread = NULL;</span><br><span class="line">    print_console(&quot;main() start\n&quot;);</span><br><span class="line">    </span><br><span class="line">    hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL);</span><br><span class="line">    WaitForSingleObject(hThread, 60*1000);</span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">    </span><br><span class="line">    print_console(&quot;main() end\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>TlsTest.cpp源代码中注册了2个TLS回调函数（TLS_CALLBACK1 TLS_CALLBACK2）他们也非常简单 只是将DllHandle与Reason这2个参数输出到控制台 然后终止退出 mian（）函数也是 创建用户线程（ThreadProc）后终止 main{}函数与ThreadProc（）内部分别将函数分开/终止日志输出到控制台 程序运行画面</p>
<p><img src="7.png" alt=""><br>接下来时各函数调用顺序</p>
<h2 id="DLL-PROCESS-ATTACH"><a href="#DLL-PROCESS-ATTACH" class="headerlink" title="DLL_PROCESS_ATTACH"></a>DLL_PROCESS_ATTACH</h2><p>进程的主线程调用main()函数前 已经注册的TLS回调函数（TLS_CALLBACK1 TLS_CALLBACK2）会先被执行 此时Reason的值为1（DLL_PROCESS_ATTACH）</p>
<h2 id="DLL-THREAD-ATTACH"><a href="#DLL-THREAD-ATTACH" class="headerlink" title="DLL_THREAD_ATTACH"></a>DLL_THREAD_ATTACH</h2><p>所有TLS回调函数完成调用后 mian（）函数开始执行 创建用户线程（ThreadProc）前 TLS回调函数会被再次执行 此时此时Reason的值为2（DLL_THREAD_ATTACH）</p>
<h2 id="DLL-THREAD-DETACH"><a href="#DLL-THREAD-DETACH" class="headerlink" title="DLL_THREAD_DETACH"></a>DLL_THREAD_DETACH</h2><p>TLS回调函数全部被执行完毕后 ThreadProc（）线程函数开始调用执行 执行完毕后Reason=3（DLL_THREAD_DETACH） TLS回调函数被调用执行</p>
<h2 id="DLL-PROCESS-DETACH"><a href="#DLL-PROCESS-DETACH" class="headerlink" title="DLL_PROCESS_DETACH"></a>DLL_PROCESS_DETACH</h2><p>ThreadProc（）线程函数执行完毕后 一直在等待线程终止的main（）函数也会终止 此时Reason的值为0（DLL_PROCESS_DETACH）TLS回调函数最后一次被调用执行 以上TlsTest.exe中 2个TLS回调函数分别被调用了4次 总共为8次 接下来看看调试方法</p>
<h1 id="调式TLS回调函数"><a href="#调式TLS回调函数" class="headerlink" title="调式TLS回调函数"></a>调式TLS回调函数</h1><p>若直接在调试器中打开有TLS回调函数的程序 则无法打开TLS函数 因为在EP代码执行之前就被调用执行了 使用特定插件存在一个“暂停在TLS回调函数”的选项 使用起来更加方便</p>
<p><img src="10.png" alt=""><br>这样就可以调试TLS回调函数了 这个函数很简单 运行的代码也不多</p>
<h1 id="手动添加TLS回调函数"><a href="#手动添加TLS回调函数" class="headerlink" title="手动添加TLS回调函数"></a>手动添加TLS回调函数</h1><p>首先确定IMAGE_TLS_DIRECTORY结构体与TLS回调函数要放在哪个位置 向某个PE文件添加代码或数据时 有3种方法</p>
<p>1）添加到节区末尾的空白区域<br>2）增加最后一个节区的大小<br>3）在最后添加新节区<br>这里我们采用第二种方法 使用PEView查看Hello.exe文件的最后一个节区（.rsrc）的节区头<br><img src="9.png" alt=""><br>可以看到最后一个节区（.rsrc）的Pointer to Raw Data=9000 Size of Raw Data=200 所以 PE头中定义的文件整体大小为9200 考虑到要添加代码和数据的大小 我们将最后一个节区的大小增加200 使用HXD工具打开文件 光标移至最后一个节区的菜单栏选择编辑-插入字节 如图所示 向字节数中输入200 单击ok后 就可以看到增加了200个字节<br><img src="10.png" alt=""><br><img src="11.png" alt=""></p>
<h2 id="编辑PE文件头"><a href="#编辑PE文件头" class="headerlink" title="编辑PE文件头"></a>编辑PE文件头</h2><h3 id="rsrc节区头"><a href="#rsrc节区头" class="headerlink" title=".rsrc节区头"></a>.rsrc节区头</h3><p>对比图9 分别修改.rsrc节区头中的Size of Raw Data和Characteristics的值 即Size of Raw Data=400 Characteristics=E0000060 如下图<br><img src="12.png" alt=""><br>Characteristics=E0000060的含义如图<br><img src="13.png" alt=""><br>在原有的属性上增加了这三个属性</p>
<h3 id="IMAGE-DATA-DIRECTORY-9-1"><a href="#IMAGE-DATA-DIRECTORY-9-1" class="headerlink" title="IMAGE_DATA_DIRECTORY[9]"></a>IMAGE_DATA_DIRECTORY[9]</h3><p>接下来设置TLS表（IMAGE_NT_HEADERS—IMAGE_OPTIONAL_HEADER—IMAGE_DATA_DIRECTORY[9]）的值 我们可以从图9中看到扩展程序的起始地址为9200（文件偏移） 在PEView在查看该地址为C200 我们将在该地址处创建IMAGE_TLS_DIRECTORY结构体 因此修改PE头中的IMAGE_DATA_DIRECTORY[9] 如图所示</p>
<p><img src="14.png" alt=""><br>完成后保存文件用PEView查看文件<br><img src="15.png" alt=""></p>
<h2 id="设置IMAGE-TLS-DIRECTORY结构体"><a href="#设置IMAGE-TLS-DIRECTORY结构体" class="headerlink" title="设置IMAGE_TLS_DIRECTORY结构体"></a>设置IMAGE_TLS_DIRECTORY结构体</h2><p>接下来设置IMAGE_TLS_DIRECTORY结构体 只要把TLS回调函数注册其中即可 编辑结构体<br><img src="16.png" alt=""><br>我们在文件偏移9200地址处创建了IMAGE_TLS_DIRECTORY结构体 AddressOfCallBacks成员的值为40c224 他是TLS回调函数数组的起始地址 只要把TLS回调函数的地址放入该数组 即可注册成功 使用PEView查看<br><img src="17.png" alt=""></p>
<h2 id="编写TLS回调函数"><a href="#编写TLS回调函数" class="headerlink" title="编写TLS回调函数"></a>编写TLS回调函数</h2><p>上述工作全部完成后 下来开始编写函数 我们在OD中编写如图代码 从40c230处开始<br><img src="18.png" alt=""><br>完成后保存修改都文件即可</p>
<h2 id="最终完成"><a href="#最终完成" class="headerlink" title="最终完成"></a>最终完成</h2><p>打开刚才的文件 就会发现已经ok了 表明已经成功（虽然我这个出了点小差错 但表明TLS回调函数添加成功了哈哈哈哈）<br><img src="19.png" alt=""><br>反正我成功了哈哈哈哈哈哈哈哈哈 我不管！！！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/26/内核6中的DLL注入/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/26/内核6中的DLL注入/" itemprop="url">内核6中的DLL注入</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-26T13:31:36+08:00">
                2019-05-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="再现DLL注入失败"><a href="#再现DLL注入失败" class="headerlink" title="再现DLL注入失败"></a>再现DLL注入失败</h1><p>尝试将Dummy.dll文件注入Windows7的系统时 会出现失败 接下来将再现</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">BOOL InjectDll(DWORD dwPID, LPCTSTR szDllPath)</span><br><span class="line">&#123;</span><br><span class="line">    HANDLE hProcess = NULL, hThread = NULL;</span><br><span class="line">    HMODULE hMod = NULL;</span><br><span class="line">    LPVOID pRemoteBuf = NULL;</span><br><span class="line">    DWORD dwBufSize = (DWORD)(_tcslen(szDllPath) + 1) * sizeof(TCHAR);</span><br><span class="line">    LPTHREAD_START_ROUTINE pThreadProc;</span><br><span class="line">    BOOL bRet = TRUE;</span><br><span class="line"></span><br><span class="line">    if ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) )</span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(L&quot;OpenProcess(%d) failed!!! [%d]\n&quot;, dwPID, GetLastError());</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pRemoteBuf = VirtualAllocEx(hProcess, NULL, dwBufSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">    WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, NULL);</span><br><span class="line"></span><br><span class="line">    hMod = GetModuleHandle(L&quot;kernel32.dll&quot;);</span><br><span class="line">    pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, &quot;LoadLibraryW&quot;);</span><br><span class="line">	</span><br><span class="line">    hThread = CreateRemoteThread(hProcess, NULL, 0, pThreadProc, pRemoteBuf, 0, NULL);</span><br><span class="line">    if( hThread == NULL )</span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(L&quot;[ERROR] CreateRemoteThread() failed!!! [%d]\n&quot;, GetLastError());</span><br><span class="line">        bRet = FALSE;</span><br><span class="line">        goto _ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WaitForSingleObject(hThread, INFINITE);	</span><br><span class="line"></span><br><span class="line">_ERROR:</span><br><span class="line">    </span><br><span class="line">    if( pRemoteBuf )</span><br><span class="line">        VirtualFreeEx(hProcess, pRemoteBuf, 0, MEM_RELEASE);</span><br><span class="line"></span><br><span class="line">    if( hThread )</span><br><span class="line">        CloseHandle(hThread);</span><br><span class="line"></span><br><span class="line">    if( hProcess )</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line"></span><br><span class="line">    return bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是典型的Dll注入代码 在之前已经分析过了<br><strong>Dummy.cpp</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;windows.h&quot;</span><br><span class="line">#include &quot;tchar.h&quot;</span><br><span class="line"></span><br><span class="line">BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span><br><span class="line">&#123;</span><br><span class="line">    TCHAR   szPath[MAX_PATH]    = &#123;0,&#125;;</span><br><span class="line">    TCHAR   szMsg[1024]         = &#123;0,&#125;;</span><br><span class="line">    TCHAR   *p                  = NULL;</span><br><span class="line"></span><br><span class="line">    switch( fdwReason )</span><br><span class="line">    &#123;</span><br><span class="line">        case DLL_PROCESS_ATTACH : </span><br><span class="line">            GetModuleFileName(NULL, szPath, MAX_PATH);</span><br><span class="line">            p = _tcsrchr(szPath, L&apos;\\&apos;);</span><br><span class="line">            if( p != NULL )</span><br><span class="line">            &#123;</span><br><span class="line">                _stprintf_s(szMsg, 1024 - sizeof(TCHAR), </span><br><span class="line">                            L&quot;Injected in %s(%d)&quot;, </span><br><span class="line">                            p + 1,                          // Process Name</span><br><span class="line">                            GetCurrentProcessId());         // PID</span><br><span class="line">                OutputDebugString(szMsg);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>DllMain()函数代码非常简单 若注入成功指定进程 就输出相关调试信息</p>
<h2 id="注入测试"><a href="#注入测试" class="headerlink" title="注入测试"></a>注入测试</h2><p>首先 运行procexp工具 查看目标进程的PID notepad的PID<br><img src="1.png" alt=""><br>然后分别使用InjectDll.exe分别向他们注入dummy.dll文件 注入前先把InjectDll.exe和dummy.dll复制到工作文件夹 使用下图命令注入dll<br><img src="2.png" alt=""><br>搜索dummy.dll<br><img src="3.png" alt=""></p>
<h1 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h1><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>我们向svchost.exe进程注入的过程中 调用CreateRemoteThread()API时失败了 错误代码为8 下面使用OD打开程序 在OPEN窗口中输入相应参数后打开<br><img src="4.png" alt=""><br>我们已经知道调用CreateRemoteThread()API时失败 所以我们直接在此API处设置断点<br><img src="5.png" alt=""><br>F9运行程序 停在断点处<br><img src="6.png" alt=""><br>F8单步执行几步 在OD中可以看到 这一串字符<br><img src="7.png" alt=""><br>我们从OD中看到了失败的情形 但仍然没有找到原因 </p>
<h2 id="调试-2"><a href="#调试-2" class="headerlink" title="调试#2"></a>调试#2</h2><p>重新运行OD 让代码停在CreateRemoteThread()API处<br><img src="6.png" alt=""><br>查看进程栈中的数据<br><img src="8.png" alt=""><br>F7进入函数查看到内部调用了CreateRemoteThreadEx()API函数 继续单步运行到函数里 运行到ZwCreatRemoteThreadEx()API代码处</p>
<p><img src="9.png" alt=""><br>我们继续跟踪进入该API函数 可以看到最终通过SYSENTER指令进入内核模式 无法继续用户模式调试<br><img src="10.png" alt=""><br>实际上 CreateRemoteThreadEx()API函数 ZwCreatRemoteThreadEx()API函数在Vista版本之前是不存在的 所以我们推测是由于系统新增的API导致的DLL注入失败</p>
<p>我们通过搜索发现 在Windows Vista以后的OS中进行DLL注入时 直接调用ZwCreatRemoteThreadEx()API函数而非CreateRemoteThread()API就能成功注入DLL</p>
<p>我们比较参数可以发现 ZwCreatRemoteThreadEx()API的第七个参数值时时白的原因所在</p>
<h1 id="稍作整理"><a href="#稍作整理" class="headerlink" title="稍作整理"></a>稍作整理</h1><p>在编写新的Dll注入程序前 先整理前面学过的内容 由于win7的会话管理机制发生了变化 CreateRemoteThread()API的内部实现代码发生了变化 最终使得注入的Dll无法发挥作用 原因在于 在APi内部创建远线程时采用了挂起模式 若远程进程属于会话0 则不会恢复运行 而是直接返回错误 **在reateRemoteThread()API内部调用ZwCreatRemoteThreadEx()API时 操作他的参数或者强制改变错误条件分支语句 就可以创建远程线程 成功注入DLL</p>
<h1 id="InjectDll-new-exe"><a href="#InjectDll-new-exe" class="headerlink" title="InjectDll_new.exe"></a>InjectDll_new.exe</h1><p>从前面我们知道 在win7中直接调用ZwCreatRemoteThreadEx()API要比CreateRemoteThread()API好得多 下面编写一个新的程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;windows.h&quot;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;tchar.h&quot;</span><br><span class="line"></span><br><span class="line">BOOL SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege) </span><br><span class="line">&#123;</span><br><span class="line">    TOKEN_PRIVILEGES tp;</span><br><span class="line">    HANDLE hToken;</span><br><span class="line">    LUID luid;</span><br><span class="line"></span><br><span class="line">    if( !OpenProcessToken(GetCurrentProcess(),</span><br><span class="line">                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, </span><br><span class="line">			              &amp;hToken) )</span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(L&quot;OpenProcessToken error: %u\n&quot;, GetLastError());</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if( !LookupPrivilegeValue(NULL,             // lookup privilege on local system</span><br><span class="line">                              lpszPrivilege,    // privilege to lookup </span><br><span class="line">                              &amp;luid) )          // receives LUID of privilege</span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(L&quot;LookupPrivilegeValue error: %u\n&quot;, GetLastError() ); </span><br><span class="line">        return FALSE; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tp.PrivilegeCount = 1;</span><br><span class="line">    tp.Privileges[0].Luid = luid;</span><br><span class="line">    if( bEnablePrivilege )</span><br><span class="line">        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">    else</span><br><span class="line">        tp.Privileges[0].Attributes = 0;</span><br><span class="line"></span><br><span class="line">    // Enable the privilege or disable all privileges.</span><br><span class="line">    if( !AdjustTokenPrivileges(hToken, </span><br><span class="line">                               FALSE, </span><br><span class="line">                               &amp;tp, </span><br><span class="line">                               sizeof(TOKEN_PRIVILEGES), </span><br><span class="line">                               (PTOKEN_PRIVILEGES) NULL, </span><br><span class="line">                               (PDWORD) NULL) )</span><br><span class="line">    &#123; </span><br><span class="line">        _tprintf(L&quot;AdjustTokenPrivileges error: %u\n&quot;, GetLastError() ); </span><br><span class="line">        return FALSE; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    if( GetLastError() == ERROR_NOT_ALL_ASSIGNED )</span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(L&quot;The token does not have the specified privilege. \n&quot;);</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef DWORD (WINAPI *PFNTCREATETHREADEX)</span><br><span class="line">( </span><br><span class="line">    PHANDLE                 ThreadHandle,	</span><br><span class="line">    ACCESS_MASK             DesiredAccess,	</span><br><span class="line">    LPVOID                  ObjectAttributes,	</span><br><span class="line">    HANDLE                  ProcessHandle,	</span><br><span class="line">    LPTHREAD_START_ROUTINE  lpStartAddress,	</span><br><span class="line">    LPVOID                  lpParameter,	</span><br><span class="line">    BOOL	                CreateSuspended,	</span><br><span class="line">    DWORD                   dwStackSize,	</span><br><span class="line">    DWORD                   dw1, </span><br><span class="line">    DWORD                   dw2, </span><br><span class="line">    LPVOID                  Unknown </span><br><span class="line">); </span><br><span class="line"></span><br><span class="line">BOOL IsVistaOrLater()</span><br><span class="line">&#123;</span><br><span class="line">    OSVERSIONINFO osvi;</span><br><span class="line"></span><br><span class="line">    ZeroMemory(&amp;osvi, sizeof(OSVERSIONINFO));</span><br><span class="line">    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);</span><br><span class="line"></span><br><span class="line">    GetVersionEx(&amp;osvi);</span><br><span class="line"></span><br><span class="line">    if( osvi.dwMajorVersion &gt;= 6 )</span><br><span class="line">        return TRUE;</span><br><span class="line"></span><br><span class="line">    return FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL MyCreateRemoteThread(HANDLE hProcess, LPTHREAD_START_ROUTINE pThreadProc, LPVOID pRemoteBuf)</span><br><span class="line">&#123;</span><br><span class="line">    HANDLE      hThread = NULL;</span><br><span class="line">    FARPROC     pFunc = NULL;</span><br><span class="line"></span><br><span class="line">    if( IsVistaOrLater() )    // Vista, 7, Server2008</span><br><span class="line">    &#123;</span><br><span class="line">        pFunc = GetProcAddress(GetModuleHandle(L&quot;ntdll.dll&quot;), &quot;NtCreateThreadEx&quot;);</span><br><span class="line">        if( pFunc == NULL )</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;MyCreateRemoteThread() : GetProcAddress(\&quot;NtCreateThreadEx\&quot;) failed!!! [%d]\n&quot;,</span><br><span class="line">                   GetLastError());</span><br><span class="line">            return FALSE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ((PFNTCREATETHREADEX)pFunc)(&amp;hThread,</span><br><span class="line">                                    0x1FFFFF,</span><br><span class="line">                                    NULL,</span><br><span class="line">                                    hProcess,</span><br><span class="line">                                    pThreadProc,</span><br><span class="line">                                    pRemoteBuf,</span><br><span class="line">                                    FALSE,</span><br><span class="line">                                    NULL,</span><br><span class="line">                                    NULL,</span><br><span class="line">                                    NULL,</span><br><span class="line">                                    NULL);</span><br><span class="line">        if( hThread == NULL )</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;MyCreateRemoteThread() : NtCreateThreadEx() failed!!! [%d]\n&quot;, GetLastError());</span><br><span class="line">            return FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else                    // 2000, XP, Server2003</span><br><span class="line">    &#123;</span><br><span class="line">        hThread = CreateRemoteThread(hProcess, </span><br><span class="line">                                     NULL, </span><br><span class="line">                                     0, </span><br><span class="line">                                     pThreadProc, </span><br><span class="line">                                     pRemoteBuf, </span><br><span class="line">                                     0, </span><br><span class="line">                                     NULL);</span><br><span class="line">        if( hThread == NULL )</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;MyCreateRemoteThread() : CreateRemoteThread() failed!!! [%d]\n&quot;, GetLastError());</span><br><span class="line">            return FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	if( WAIT_FAILED == WaitForSingleObject(hThread, INFINITE) )</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;MyCreateRemoteThread() : WaitForSingleObject() failed!!! [%d]\n&quot;, GetLastError());</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL InjectDll(DWORD dwPID, char *szDllName)</span><br><span class="line">&#123;</span><br><span class="line">    HANDLE hProcess = NULL;</span><br><span class="line">    LPVOID pRemoteBuf = NULL;</span><br><span class="line">    FARPROC pThreadProc = NULL;</span><br><span class="line">    DWORD dwBufSize = strlen(szDllName)+1;</span><br><span class="line"></span><br><span class="line">    if ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) )</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;[ERROR] OpenProcess(%d) failed!!! [%d]\n&quot;, </span><br><span class="line">        dwPID, GetLastError());</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pRemoteBuf = VirtualAllocEx(hProcess, NULL, dwBufSize, </span><br><span class="line">                                MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">    WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllName, </span><br><span class="line">                       dwBufSize, NULL);</span><br><span class="line"></span><br><span class="line">    pThreadProc = GetProcAddress(GetModuleHandle(L&quot;kernel32.dll&quot;), </span><br><span class="line">                                 &quot;LoadLibraryA&quot;);</span><br><span class="line"></span><br><span class="line">    if( !MyCreateRemoteThread(hProcess, (LPTHREAD_START_ROUTINE)pThreadProc, pRemoteBuf) )</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;[ERROR] MyCreateRemoteThread() failed!!!\n&quot;);</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    VirtualFreeEx(hProcess, pRemoteBuf, 0, MEM_RELEASE);</span><br><span class="line"></span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line"></span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	// adjust privilege</span><br><span class="line">    SetPrivilege(SE_DEBUG_NAME, TRUE);</span><br><span class="line"></span><br><span class="line">    // InjectDll.exe &lt;PID&gt; &lt;dll_path&gt;</span><br><span class="line">    if( argc != 3 )</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;usage : %s &lt;PID&gt; &lt;dll_path&gt;\n&quot;, argv[0]);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if( !InjectDll((DWORD)atoi(argv[1]), argv[2]) )</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;InjectDll() failed!!!\n&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;InjectDll() succeeded!!!\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个函数中变动的是 函数内部并没有直接调用CreateRemoteThread()API而是调用了为MyCreateRemoteThread()API的用户函数 在MyCreateRemoteThread()API函数内部先获取OS版本 若为Vista版本以上 则调用NtCreateThreadEx()API函数 反之 则调用CreateRemoteThread()API函数</p>
<h2 id="注入练习"><a href="#注入练习" class="headerlink" title="注入练习"></a>注入练习</h2><p>选择一个会话为0的服务进程练习<br><img src="11.png" alt=""><br>接下来运行命令<br><img src="12.png" alt=""><br>用procexp查看可以看到dll<br><img src="13.png" alt=""><br>这样就顺利向服务进程为0的会话中顺利注入DLL了</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/23/ASLR/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/23/ASLR/" itemprop="url">ASLR</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-23T20:08:14+08:00">
                2019-05-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>ASLR是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的的一种技术。</p>
<p>ASLR（Address space layout randomization）是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的。据研究表明ASLR可以有效的降低缓冲区溢出攻击的成功率，如今Linux、FreeBSD、Windows等主流操作系统都已采用了该技术。</p>
<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>用OD载入ASLR和ASLR_no两个程序<br><img src="1.png" alt=""><br><img src="8.png" alt=""><br>看起来基址不一样的 这就是ALSR文件的区别 每次载入都会改变基址 我们用PEView载入程序看看<br><img src="2.png" alt=""><br>节区信息<br>对于普通的EXE文件不存在.reloc文件 只有用了ASLR技术的应用才会有 被加载在内存时 被用作重定位的参考 它不是必须部分 可以删除 </p>
<p>再来看看这两部分 ASLR的characteristics属性字段并不存在这一段 因为ASLR.exe文件中多出来1个.reloc节区 所以Number of Sections值增1</p>
<p><img src="3.png" alt=""><br>ASLR文件的DLL Characteristics中设有这一段 这也就是ASLR文件的标志了<br><img src="4.png" alt=""></p>
<h1 id="删除ALSR功能"><a href="#删除ALSR功能" class="headerlink" title="删除ALSR功能"></a>删除ALSR功能</h1><p>我们使用Stud_PE工具修改ASLR.exe文件 载入可以看到应用的相关信息 并点击这里可以看到<br><img src="5.png" alt=""><br>我们找到DLL Characteristics的地方 并看到他在内存中的值 我们将属性值由8140改成8100 然后保存文件<br><img src="6.png" alt=""><br><img src="7.png" alt=""><br>再次载入ASLR文件 可以看到基址和ASLR_no文件一样了 这样就将文件删除ALSR功能了<br><img src="9.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/20/OD学习5-25/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/20/OD学习5-25/" itemprop="url">OD学习5-25</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-20T19:12:10+08:00">
                2019-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="高级全局API钩取：IE连接控制"><a href="#高级全局API钩取：IE连接控制" class="headerlink" title="高级全局API钩取：IE连接控制"></a>高级全局API钩取：IE连接控制</h1><h2 id="调试IE进程"><a href="#调试IE进程" class="headerlink" title="调试IE进程"></a>调试IE进程</h2><p>常见网络连接库：ws2_32.dll（套接字），wininet.dll，winhttp.dll</p>
<p>使用Process Explorer查看IE加载的DLL</p>
<p>IE不仅加载了ws2_32.dll还加载了wininet.dll，wininet.dll中提供的API中有个名为InternetConnect()的API，这个API用来连接网站</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HINTERNET InternetConnect(</span><br><span class="line">  _In_ HINTERNET     hInternet,</span><br><span class="line">  _In_ LPCTSTR       lpszServerName,</span><br><span class="line">  _In_ INTERNET_PORT nServerPort,</span><br><span class="line">  _In_ LPCTSTR       lpszUsername,</span><br><span class="line">  _In_ LPCTSTR       lpszPassword,</span><br><span class="line">  _In_ DWORD         dwService,</span><br><span class="line">  _In_ DWORD         dwFlags,</span><br><span class="line">  _In_ DWORD_PTR     dwContext</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>首先先打开IE浏览器 等待浏览器加载完：</p>
<p><img src="7.png" alt=""><br>然后打开OD附加进程 这里发现有两个IE的进程 随便加载一个都行</p>
<p><img src="8.png" alt=""><br>加载之后在反汇编窗口右击选择</p>
<p><img src="9.png" alt=""><br>接下来找到InternetConnectW()API函数</p>
<p><img src="10.png" alt=""><br>双击来到这里 设置断点</p>
<p><img src="11.png" alt=""><br>点击F9运行一次 然后在浏览器中输入网址</p>
<p><img src="12.png" alt=""><br>回车发现浏览器并没有跳转 OD处于暂停状态 右下角数据窗口是刚才输入的网址</p>
<p><img src="13.png" alt=""><br>下来在数据窗口跟随 发现网址后更改为另外一个网址</p>
<p><img src="14.png" alt=""><br>取消断点后F9运行程序<br><img src="15.png" alt=""><br>发现已经跳转到更改后的网址了 </p>
<h2 id="IE的进程结构"><a href="#IE的进程结构" class="headerlink" title="IE的进程结构"></a>IE的进程结构</h2><p>IE的每个选项卡对应一个进程，统一由一个父进程管理。所以钩取API时需要使用全局钩取。</p>
<p>这里通过钩取ntdll!ZwResumeThread钩取子进程</p>
<h2 id="全局钩取ntdll-ResumeThread-API"><a href="#全局钩取ntdll-ResumeThread-API" class="headerlink" title="全局钩取ntdll!ResumeThread API"></a>全局钩取ntdll!ResumeThread API</h2><p>因为最终目的是控制IE的网络连接，所以dll注入时仅需向所有的iexplore.exe进程中注入即可，无需对其他无关进程注入dll</p>
<p>我们首先想想创建子进程的API有哪些 创建进程API中最具代表性的绝对是kernel32！CreateProcess{}API 下面调试一个简单的程序来测试CreateProcess（）API ：</p>
<h3 id="cptest-exe"><a href="#cptest-exe" class="headerlink" title="cptest.exe"></a>cptest.exe</h3><p>用OD载入cptest程序 发现这个程序和载入ie程序的一样 反汇编窗口右击查找所有模块名称 然后进入kernel32！CreateProcessW() 发现在内部又调用了kernel32！CreateProcessInternelW()：</p>
<p><img src="16.png" alt=""><br>给kernel32！CreateProcessW()设置断点F9运行 接下来单步跟踪进入kernel32！CreateProcessInternelW()：</p>
<p><img src="17.png" alt=""><br>kernel32！CreateProcessInternelW()是一个相当大的函数 滚动条往下翻就会找到ntdll!ZwCreateUserProcess（） API：</p>
<p><img src="18.png" alt=""><br>查看图中栈中出现了字符串notepad.exe同时在数据窗口也可以看到</p>
<p><img src="19.png" alt=""><br>在process Explorer中可以看到notepad被暂时挂起 分配了PID却没有运行程序<br><img src="20.png" alt=""><br>在OD中继续单步运行程序 可以看到调用ntdll.ZwResumeThread（）API的代码<br><img src="21.png" alt=""><br>而ntdll.ZwResumeThread（）API函数就是用来恢复运行线程的 该线程是子进程（notepad.exe）的主进程 所以运行此代码时 子进程的EP代码才会执行 我们可以看见进程中的Suspended（挂起）已经不见了</p>
<p><img src="51.png" alt=""><br>综上所述 CreateProcessW（）API的调用流程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kernel32！CreateProcessW()</span><br><span class="line">	kernel32！CreateProcessInternelW()</span><br><span class="line">		ntdll!ZwCreateUserProcess（） //创建进程（主线程处于挂起状态）</span><br><span class="line">		ntdll.ZwResumeThread（）	//主线程被恢复运行（运行进程）</span><br></pre></td></tr></table></figure></p>
<p>创建子进程最后调用的是ntdll.ZwResumeThread（）API 所以钩取该API 在子进程的EP代码运行之前 拦截获取控制权 然后钩取指定API </p>
<p>前面的4个API都能实现实现我们的目标—全局API钩取</p>
<h2 id="控制IE浏览器"><a href="#控制IE浏览器" class="headerlink" title="控制IE浏览器"></a>控制IE浏览器</h2><h3 id="运行IE"><a href="#运行IE" class="headerlink" title="运行IE"></a>运行IE</h3><p>首先运行IE浏览器 然后使用process Explorer查看运行中的IE进程的结构</p>
<p>我们可以看到 IE进程以父子进程的形式进行 只要钩取夫进程的ntdll.ZwResumeThread（）API 那么后面的所有子进程都会被钩取</p>
<p><img src="52.png" alt=""></p>
<h3 id="注入DLL"><a href="#注入DLL" class="headerlink" title="注入DLL"></a>注入DLL</h3><p>使用如图InjDll.exe命令 将redirect.dll文件注入IE进程<br><img src="53.png" alt=""><br>查看DLL注入成功<br><img src="54.png" alt=""></p>
<h3 id="卸载DLL"><a href="#卸载DLL" class="headerlink" title="卸载DLL"></a>卸载DLL</h3><p>我们可以看到DLL已经卸载成功<br><img src="55.png" alt=""></p>
<h2 id="源代码分析"><a href="#源代码分析" class="headerlink" title="源代码分析"></a>源代码分析</h2><h3 id="DllMain"><a href="#DllMain" class="headerlink" title="DllMain"></a>DllMain</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span><br><span class="line">&#123;</span><br><span class="line">    char            szCurProc[MAX_PATH] = &#123;0,&#125;;</span><br><span class="line">    char            *p = NULL;</span><br><span class="line"></span><br><span class="line">    switch( fdwReason )</span><br><span class="line">    &#123;</span><br><span class="line">        case DLL_PROCESS_ATTACH : </span><br><span class="line">            DebugLog(&quot;DllMain() : DLL_PROCESS_ATTACH\n&quot;);</span><br><span class="line"></span><br><span class="line">            GetModuleFileNameA(NULL, szCurProc, MAX_PATH);</span><br><span class="line">            p = strrchr(szCurProc, &apos;\\&apos;);</span><br><span class="line">            if( (p != NULL) &amp;&amp; !_stricmp(p+1, &quot;iexplore.exe&quot;) )</span><br><span class="line">            &#123;</span><br><span class="line">                DebugLog(&quot;DllMain() : current process is [iexplore.exe]\n&quot;);</span><br><span class="line"></span><br><span class="line">                //为了防止在Dll注入时wininet.dll还未被加载，所以手动加载一下wininet.dll</span><br><span class="line">                if( NULL == LoadLibrary(L&quot;wininet.dll&quot;) )</span><br><span class="line">                &#123;</span><br><span class="line">                    DebugLog(&quot;DllMain() : LoadLibrary() failed!!! [%d]\n&quot;,</span><br><span class="line">                             GetLastError());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // hook</span><br><span class="line">            hook_by_code(&quot;ntdll.dll&quot;, &quot;ZwResumeThread&quot;, </span><br><span class="line">                         (PROC)NewZwResumeThread, g_pZWRT);</span><br><span class="line">            hook_by_code(&quot;wininet.dll&quot;, &quot;InternetConnectW&quot;, </span><br><span class="line">                         (PROC)NewInternetConnectW, g_pICW);</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case DLL_PROCESS_DETACH :</span><br><span class="line">            DebugLog(&quot;DllMain() : DLL_PROCESS_DETACH\n&quot;);</span><br><span class="line"></span><br><span class="line">            // unhook</span><br><span class="line">            unhook_by_code(&quot;ntdll.dll&quot;, &quot;ZwResumeThread&quot;, </span><br><span class="line">                           g_pZWRT);</span><br><span class="line">            unhook_by_code(&quot;wininet.dll&quot;, &quot;InternetConnectW&quot;, </span><br><span class="line">                           g_pICW);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数的核心功能是ZwResumeThread()和InternetConnectW()API的“挂钩/脱钩”功能 其中有条语句特别明显 若加载进程名为IE.exe时 则加载wininet.dll文件 这和全局API钩取的特性有关 钩取ZwResumeThread（）API时 需要在相关进程开始之前就获得拦截权 此时我们钩取的wininet.dll可能还未加载</p>
<h3 id="NewInternetConnectW"><a href="#NewInternetConnectW" class="headerlink" title="NewInternetConnectW"></a>NewInternetConnectW</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">HINTERNET WINAPI NewInternetConnectW</span><br><span class="line">(</span><br><span class="line">    HINTERNET hInternet,</span><br><span class="line">    LPCWSTR lpszServerName,</span><br><span class="line">    INTERNET_PORT nServerPort,</span><br><span class="line">    LPCTSTR lpszUsername,</span><br><span class="line">    LPCTSTR lpszPassword,</span><br><span class="line">    DWORD dwService,</span><br><span class="line">    DWORD dwFlags,</span><br><span class="line">    DWORD_PTR dwContext</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    HINTERNET hInt = NULL;</span><br><span class="line">    FARPROC pFunc = NULL;</span><br><span class="line">    HMODULE hMod = NULL;</span><br><span class="line"></span><br><span class="line">    // unhook</span><br><span class="line">    if( !unhook_by_code(&quot;wininet.dll&quot;, &quot;InternetConnectW&quot;, g_pICW) )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewInternetConnectW() : unhook_by_code() failed!!!\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // call original API</span><br><span class="line">    hMod = GetModuleHandle(L&quot;wininet.dll&quot;);</span><br><span class="line">    if( hMod == NULL )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewInternetConnectW() : GetModuleHandle() failed!!! [%d]\n&quot;,</span><br><span class="line">                  GetLastError());</span><br><span class="line">        goto __INTERNETCONNECT_EXIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pFunc = GetProcAddress(hMod, &quot;InternetConnectW&quot;);</span><br><span class="line">    if( pFunc == NULL )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewInternetConnectW() : GetProcAddress() failed!!! [%d]\n&quot;,</span><br><span class="line">                  GetLastError());</span><br><span class="line">        goto __INTERNETCONNECT_EXIT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //修改原API调用时的第二个参数</span><br><span class="line">    if( !_tcsicmp(lpszServerName, L&quot;www.naver.com&quot;) ||</span><br><span class="line">        !_tcsicmp(lpszServerName, L&quot;www.daum.net&quot;) ||</span><br><span class="line">        !_tcsicmp(lpszServerName, L&quot;www.nate.com&quot;) || </span><br><span class="line">        !_tcsicmp(lpszServerName, L&quot;www.yahoo.com&quot;) )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;[redirect] naver, daum, nate, yahoo =&gt; reversecore\n&quot;);</span><br><span class="line">        hInt = ((PFINTERNETCONNECTW)pFunc)(hInternet,</span><br><span class="line">                                           L&quot;www.reversecore.com&quot;,</span><br><span class="line">                                           nServerPort,</span><br><span class="line">                                           lpszUsername,</span><br><span class="line">                                           lpszPassword,</span><br><span class="line">                                           dwService,</span><br><span class="line">                                           dwFlags,</span><br><span class="line">                                           dwContext);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;[no redirect]\n&quot;);</span><br><span class="line">        hInt = ((PFINTERNETCONNECTW)pFunc)(hInternet,</span><br><span class="line">                                           lpszServerName,</span><br><span class="line">                                           nServerPort,</span><br><span class="line">                                           lpszUsername,</span><br><span class="line">                                           lpszPassword,</span><br><span class="line">                                           dwService,</span><br><span class="line">                                           dwFlags,</span><br><span class="line">                                           dwContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">__INTERNETCONNECT_EXIT:</span><br><span class="line"></span><br><span class="line">    // hook</span><br><span class="line">    if( !hook_by_code(&quot;wininet.dll&quot;, &quot;InternetConnectW&quot;, </span><br><span class="line">                      (PROC)NewInternetConnectW, g_pICW) )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewInternetConnectW() : hook_by_code() failed!!!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return hInt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InternetConnectW()的钩取函数为NewInternetConnectW()函数 他负责监视IE的连接地址 IE连接到特定网站时 将其转到我们的指定网站</p>
<h3 id="NewZwResumeThread"><a href="#NewZwResumeThread" class="headerlink" title="NewZwResumeThread"></a>NewZwResumeThread</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">//ThreadHandle是要恢复运行的线程的句柄(即子进程的主线程)</span><br><span class="line">NTSTATUS WINAPI NewZwResumeThread(HANDLE ThreadHandle, PULONG SuspendCount)</span><br><span class="line">&#123;</span><br><span class="line">    NTSTATUS status, statusThread;</span><br><span class="line">    FARPROC pFunc = NULL, pFuncThread = NULL;</span><br><span class="line">    DWORD dwPID = 0;</span><br><span class="line">    static DWORD dwPrevPID = 0;</span><br><span class="line">    THREAD_BASIC_INFORMATION tbi;</span><br><span class="line">    HMODULE hMod = NULL;</span><br><span class="line">    TCHAR szModPath[MAX_PATH] = &#123;0,&#125;;</span><br><span class="line"></span><br><span class="line">    DebugLog(&quot;NewZwResumeThread() : start!!!\n&quot;);</span><br><span class="line"></span><br><span class="line">    hMod = GetModuleHandle(L&quot;ntdll.dll&quot;);</span><br><span class="line">    if( hMod == NULL )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewZwResumeThread() : GetModuleHandle() failed!!! [%d]\n&quot;,</span><br><span class="line">                  GetLastError());</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 调用ntdll!ZwQueryInformationThread()，通过线程句柄获取其对应进程PID</span><br><span class="line">    pFuncThread = GetProcAddress(hMod, &quot;ZwQueryInformationThread&quot;);</span><br><span class="line">    if( pFuncThread == NULL )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewZwResumeThread() : GetProcAddress() failed!!! [%d]\n&quot;,</span><br><span class="line">                  GetLastError());</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    statusThread = ((PFZWQUERYINFORMATIONTHREAD)pFuncThread)</span><br><span class="line">                   (ThreadHandle, 0, &amp;tbi, sizeof(tbi), NULL);</span><br><span class="line">    if( statusThread != STATUS_SUCCESS )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewZwResumeThread() : pFuncThread() failed!!! [%d]\n&quot;, </span><br><span class="line">                 GetLastError());</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //子进程PID</span><br><span class="line">    dwPID = (DWORD)tbi.ClientId.UniqueProcess;</span><br><span class="line">    if ( (dwPID != GetCurrentProcessId()) &amp;&amp; (dwPID != dwPrevPID) )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewZwResumeThread() =&gt; call InjectDll()\n&quot;);</span><br><span class="line"></span><br><span class="line">        dwPrevPID = dwPID;</span><br><span class="line"></span><br><span class="line">        // change privilege</span><br><span class="line">        // 打开SeDebugPrivilege特权</span><br><span class="line">        if( !SetPrivilege(SE_DEBUG_NAME, TRUE) )</span><br><span class="line">            DebugLog(&quot;NewZwResumeThread() : SetPrivilege() failed!!!\n&quot;);</span><br><span class="line"></span><br><span class="line">        // 获取要注入的dll的路径</span><br><span class="line">        GetModuleFileName(GetModuleHandle(STR_MODULE_NAME), </span><br><span class="line">                          szModPath, </span><br><span class="line">                          MAX_PATH);</span><br><span class="line">        // 注入dll</span><br><span class="line">        if( !InjectDll(dwPID, szModPath) )</span><br><span class="line">            DebugLog(&quot;NewZwResumeThread() : InjectDll(%d) failed!!!\n&quot;, dwPID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // call ntdll!ZwResumeThread()</span><br><span class="line">    if( !unhook_by_code(&quot;ntdll.dll&quot;, &quot;ZwResumeThread&quot;, g_pZWRT) )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewZwResumeThread() : unhook_by_code() failed!!!\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pFunc = GetProcAddress(hMod, &quot;ZwResumeThread&quot;);</span><br><span class="line">    if( pFunc == NULL )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewZwResumeThread() : GetProcAddress() failed!!! [%d]\n&quot;,</span><br><span class="line">                  GetLastError());</span><br><span class="line">        goto __NTRESUMETHREAD_END;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = ((PFZWRESUMETHREAD)pFunc)(ThreadHandle, SuspendCount);</span><br><span class="line">    if( status != STATUS_SUCCESS )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewZwResumeThread() : pFunc() failed!!! [%d]\n&quot;, GetLastError());</span><br><span class="line">        goto __NTRESUMETHREAD_END;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">__NTRESUMETHREAD_END:</span><br><span class="line"></span><br><span class="line">    if( !hook_by_code(&quot;ntdll.dll&quot;, &quot;ZwResumeThread&quot;, </span><br><span class="line">                      (PROC)NewZwResumeThread, g_pZWRT) )</span><br><span class="line">    &#123;</span><br><span class="line">        DebugLog(&quot;NewZwResumeThread() : hook_by_code() failed!!!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DebugLog(&quot;NewZwResumeThread() : end!!!\n&quot;);</span><br><span class="line"></span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数负责对ntdll.ZwResumeThread（）API进行全局钩取</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/15/OD学习5-18/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/15/OD学习5-18/" itemprop="url">OD学习5-18</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-15T17:16:31+08:00">
                2019-05-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="计算器显示成文字"><a href="#计算器显示成文字" class="headerlink" title="计算器显示成文字"></a>计算器显示成文字</h1><h2 id="OD法更改"><a href="#OD法更改" class="headerlink" title="OD法更改"></a>OD法更改</h2><p>首先利用OD修改内存中的值来实现计算器显示中文数字（这次还是在XP虚拟机里运行的）</p>
<p>用OD打开calc.exe 快捷键ctrl+N查看目标文件的API函数 </p>
<p><img src="22.png" alt=""><br>这里我们发现的两个值得关注的API函数 SetWinsowTextW（）和SetDlgItemTextW（） 他们负责向计算器的文本显示框中显示文本 来看看SetWinsowTextW（）API定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOLSetWindowText(</span><br><span class="line">HWNDhwnd,</span><br><span class="line">LPCTSTRlpString</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>hWnd</strong><br>要改变文本内容的窗口或控件的句柄。不能改变在其他应用程序中的控件的文本内容，如果需要可以用另外一个SendMessage函数发送一条WM_SETTEXT消息。</p>
<p><strong>lpString</strong><br>指向一个空结束的字符串的指针，该字符串将作为窗口或控件的新文本。</p>
<p>这里我们关注第二个参考——字符串指针（lpString）钩取时查看字符串（lpString）中的内容 将其中的阿拉伯数字改成中文就行</p>
<p>然后在刚才关注的那两个API函数上设置断点<br><img src="23.png" alt=""><br>运行<br><img src="24.png" alt=""><br>第一次运行断在了SetwindowTextW这里 右下角堆栈窗口发现字符0就是计算器开始的在字符0<br><img src="25.png" alt=""><br>在运行断在了SetDlgItemTextW（）处 再次运行一下 计算器的页面出现了 为了继续调试 我们望计算器中输入7 发现OD自动在SetwindowTextW这里停了</p>
<p><img src="26.png" alt=""><br>看到了刚才说的那两个参数 在数据窗口跟随TEXT那一项发现了储存的数字7<br><img src="27.png" alt=""><br>将中文数字 七 的Unicode码（4e03）覆写到地址处 这里记得要逆序（034e）写入<br><img src="28.png" alt=""><br>发现数字7已经变成汉字七了！<br><img src="29.png" alt=""><br>运行程序在计算器中看到已经变了：<br><img src="30.png" alt=""><br>这里就算完成了OD的过程 对SetWinsowTextW（）API验证结束 接下来看看IAT钩取操作及其实现原理 </p>
<h2 id="IAT钩取工作原理"><a href="#IAT钩取工作原理" class="headerlink" title="IAT钩取工作原理"></a>IAT钩取工作原理</h2><p>IAT钩取通过修改IAT中保存的API地址来钩取某个API 如图：<br><img src="5.png" alt=""><br><img src="6.png" alt=""><br>钩取IAT前 首先向计算器进程注入hookiat.dll文件<br>原理：在保持运行代码不变的情况下 讲IAT中保存的API起始地址变为用户函数的起始地址</p>
<h2 id="练习示例"><a href="#练习示例" class="headerlink" title="练习示例"></a>练习示例</h2><p>先复制文件到工作目录（c:work）然后运行calc.exe程序 再打开任务管理器查看其PID 如图：<br><img src="31.png" alt=""><br>然后在命令窗口执行如图命令：<br><img src="32.png" alt=""><br>接下来在计算器随便输入一些数值 如图：<br><img src="33.png" alt=""><br>我们可以看到 输入的数值已经变成了中文 计算器也在正常运行（其实我自己调试的这个InjectDLL.exe注入的hookiat.dll注入之后计算器显示的是韩文 可能是韩国人整的DLL文件吧 但确实是钩取成功了！！）</p>
<h2 id="源代码分析（hookiat-dll）"><a href="#源代码分析（hookiat-dll）" class="headerlink" title="源代码分析（hookiat.dll）"></a>源代码分析（hookiat.dll）</h2><h3 id="Dllmain（）"><a href="#Dllmain（）" class="headerlink" title="Dllmain（）"></a>Dllmain（）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span><br><span class="line">&#123;</span><br><span class="line">	switch( fdwReason )</span><br><span class="line">	&#123;</span><br><span class="line">		case DLL_PROCESS_ATTACH : </span><br><span class="line">            // 保存原始API的地址</span><br><span class="line">           	g_pOrgFunc = GetProcAddress(GetModuleHandle(L&quot;user32.dll&quot;), </span><br><span class="line">                                        &quot;SetWindowTextW&quot;);</span><br><span class="line"> </span><br><span class="line">            // # hook</span><br><span class="line">            //   用hookiat.MySetWindowText钩取user32.SetWindowTextW</span><br><span class="line">			hook_iat(&quot;user32.dll&quot;, g_pOrgFunc, (PROC)MySetWindowTextW);</span><br><span class="line">			break;</span><br><span class="line"> </span><br><span class="line">		case DLL_PROCESS_DETACH :</span><br><span class="line">            // # unhook</span><br><span class="line">            //   将calc.exe的IAT恢复原值</span><br><span class="line">            hook_iat(&quot;user32.dll&quot;, (PROC)MySetWindowTextW, g_pOrgFunc);</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在DLL_PROCESS_ATTACH事件中先获取user32.SetWindowTextW的地址，然后保存到全局变量g_pOrgFunc中，后面脱钩会用到这个地址。</p>
<h3 id="MySetWindowTextW"><a href="#MySetWindowTextW" class="headerlink" title="MySetWindowTextW()"></a>MySetWindowTextW()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI MySetWindowTextW(HWND hWnd, LPWSTR lpString)</span><br><span class="line">&#123;</span><br><span class="line">    wchar_t* pNum = L&quot;零一二三四五六七八九&quot;;</span><br><span class="line">    wchar_t temp[2] = &#123;0,&#125;;</span><br><span class="line">    int i = 0, nLen = 0, nIndex = 0;</span><br><span class="line"> </span><br><span class="line">    nLen = wcslen(lpString);</span><br><span class="line">    for(i = 0; i &lt; nLen; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //   将阿拉伯数字转换为中文数字</span><br><span class="line">        //   lpString是宽字符版本(2个字节)字符串</span><br><span class="line">        if( L&apos;0&apos; &lt;= lpString[i] &amp;&amp; lpString[i] &lt;= L&apos;9&apos; )</span><br><span class="line">        &#123;</span><br><span class="line">            temp[0] = lpString[i];</span><br><span class="line">            nIndex = _wtoi(temp);</span><br><span class="line">            lpString[i] = pNum[nIndex];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //   调用user32.SetWindowTextW</span><br><span class="line">    //   (修改lpString缓冲区中的内容)</span><br><span class="line">    return ((PFSETWINDOWTEXTW)g_pOrgFunc)(hWnd, lpString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lpString参数是一块缓冲区，该缓冲区用来存放要输出显示的字符串。for循环将存放在lpString的阿拉伯数字字符串转换为中文数字字符串。for循环结束后，最后再调用函数指针g_pOrgFunc。</p>
<p>hook_iat()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">BOOL hook_iat(LPCSTR szDllName, PROC pfnOrg, PROC pfnNew)</span><br><span class="line">&#123;</span><br><span class="line">	HMODULE hMod;</span><br><span class="line">	LPCSTR szLibName;</span><br><span class="line">	PIMAGE_IMPORT_DESCRIPTOR pImportDesc; </span><br><span class="line">	PIMAGE_THUNK_DATA pThunk;</span><br><span class="line">	DWORD dwOldProtect, dwRVA;</span><br><span class="line">	PBYTE pAddr;</span><br><span class="line"> </span><br><span class="line">    // hMod, pAddr = ImageBase of calc.exe</span><br><span class="line">    //             = VA to MZ signature (IMAGE_DOS_HEADER)</span><br><span class="line">	hMod = GetModuleHandle(NULL);</span><br><span class="line">	pAddr = (PBYTE)hMod;</span><br><span class="line"> </span><br><span class="line">    // pAddr = VA to PE signature (IMAGE_NT_HEADERS)</span><br><span class="line">	pAddr += *((DWORD*)&amp;pAddr[0x3C]);</span><br><span class="line"> </span><br><span class="line">    // dwRVA = RVA to IMAGE_IMPORT_DESCRIPTOR Table</span><br><span class="line">	dwRVA = *((DWORD*)&amp;pAddr[0x80]);</span><br><span class="line"> </span><br><span class="line">    // pImportDesc = VA to IMAGE_IMPORT_DESCRIPTOR Table</span><br><span class="line">	pImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)hMod+dwRVA);</span><br><span class="line"> </span><br><span class="line">	for( ; pImportDesc-&gt;Name; pImportDesc++ )</span><br><span class="line">	&#123;</span><br><span class="line">        // szLibName = VA to IMAGE_IMPORT_DESCRIPTOR.Name</span><br><span class="line">		szLibName = (LPCSTR)((DWORD)hMod + pImportDesc-&gt;Name);</span><br><span class="line">		if( !_stricmp(szLibName, szDllName) )</span><br><span class="line">		&#123;</span><br><span class="line">            // pThunk = IMAGE_IMPORT_DESCRIPTOR.FirstThunk</span><br><span class="line">            //        = VA to IAT(Import Address Table)</span><br><span class="line">			pThunk = (PIMAGE_THUNK_DATA)((DWORD)hMod + </span><br><span class="line">                                         pImportDesc-&gt;FirstThunk);</span><br><span class="line"> </span><br><span class="line">            // pThunk-&gt;u1.Function = VA to API</span><br><span class="line">			for( ; pThunk-&gt;u1.Function; pThunk++ )</span><br><span class="line">			&#123;</span><br><span class="line">				if( pThunk-&gt;u1.Function == (DWORD)pfnOrg )</span><br><span class="line">				&#123;</span><br><span class="line">                </span><br><span class="line">					VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, </span><br><span class="line">                                   4, </span><br><span class="line">                                   PAGE_EXECUTE_READWRITE, </span><br><span class="line">                                   &amp;dwOldProtect);</span><br><span class="line"> </span><br><span class="line">                    pThunk-&gt;u1.Function = (DWORD)pfnNew;</span><br><span class="line">				</span><br><span class="line">                    VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, </span><br><span class="line">                                   4, </span><br><span class="line">                                   dwOldProtect, </span><br><span class="line">                                   &amp;dwOldProtect);						</span><br><span class="line"> </span><br><span class="line">					return TRUE;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	return FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数主要负责钩取API</p>
<p>首先从ImageBase开始经由PE签名找到IDT<br><img src="34.png" alt=""><br><img src="35.png" alt=""><br><img src="36.png" alt=""><br>pImportDesc变量中存储着IMAGE_IMPORT_DESCRIPTOR结构体的起始地址，后者是calc.exe进程IDT的第一个结构体。IDT是由IMAGE_IMPORT_DESCRIPTOR结构体组成的数组。若想查找到IAT，先要查找到这个位置。使用PEView查看该地址(00012B80+01000000=01012B80)，如图所示。</p>
<p><img src="37.png" alt=""><br>在for循环中通过比较查找到user32.dll的IMAGE_IMPORT_DESCRIPTOR结构体地址，从上图可以看出最终pImportDesc的值为01012BF4。接下来进入user32的IAT，pImportDesc-&gt;FirstThunk成员所指的就是IAT。使用PEView查看该地址(000010A4+01000000=010010A4)，如图所示</p>
<p><img src="38.png" alt=""><br>接下来又在for循环中查找SetWindowTextW的IAT地址(01001110)，然后修改它的值。因为计算器进程的IAT内存区域是只读的，所以需要使用VirtualProtect在钩取之前将相应的区域改为可读写的，钩取之后再改回来。</p>
<h1 id="调试被注入的DLL文件"><a href="#调试被注入的DLL文件" class="headerlink" title="调试被注入的DLL文件"></a>调试被注入的DLL文件</h1><p>首先运行calc程序 查看其PID的值<br><img src="39.png" alt=""><br>将程序进程附加到OD中 然后在事件中选定中断于新DLL进程 然后将hookiat.dll注入计算器进程<br><img src="41.png" alt=""><br>运行程序发现：<br><img src="40.png" alt=""><br>双击进入hookiat.dll中 接下来取消刚才事件中的中断于新DLL的选项 然后在hookiat模块查找参考字符串寻找DllMain（）代码 当然也可以F7单步跟踪查找 DllMain()函数中使用的字符串有“user32.dll”和“SetWindowTextW”</p>
<p><img src="42.png" alt=""><br>我们发现“user32.dll”有两处“SetWindowTextW”有一处 转到“SetWindowTextW”处：</p>
<p><img src="43.png" alt=""><br>框出来的内容就是DllMain（）函数了</p>
<p>这就是调试注入进程Dll的方法了</p>
<h2 id="Dllmain（）-1"><a href="#Dllmain（）-1" class="headerlink" title="Dllmain（）"></a>Dllmain（）</h2><p><img src="44.png" alt=""><br>这个call语句就是调用hook_iat()<br>步入刚才那个call语句进入hook_iat()</p>
<h2 id="hook-iat"><a href="#hook-iat" class="headerlink" title="hook_iat()"></a>hook_iat()</h2><h3 id="查找IMAGE-IMPORT-DESCRIPTION-Table"><a href="#查找IMAGE-IMPORT-DESCRIPTION-Table" class="headerlink" title="查找IMAGE_IMPORT_DESCRIPTION Table"></a>查找IMAGE_IMPORT_DESCRIPTION Table</h3><p>hook_iat()是负责具体实施IAT钩取的核心函数 下面是调试一下：<br><img src="45.png" alt=""><br>框起来的部分就是IMAGE_IMPORT_DESCRIPTION Table（下面简称“IID Table”）的过程 一时难分代码仅仅用了4行代码就找到了ID Table</p>
<p><img src="46.png" alt=""><br>这个call指令用于调用stricmp（）函数。</p>
<h3 id="在IAT中查找SetWindowTextW-API位置"><a href="#在IAT中查找SetWindowTextW-API位置" class="headerlink" title="在IAT中查找SetWindowTextW API位置"></a>在IAT中查找SetWindowTextW API位置</h3><p>通过便利IID Table比较IID.Name于“user32.dll”字符串 查找到user32.dll的IID  找到之后 下面代码用来查找SetWindowTextW API位置 然后修改其中内容 从而实现对API的钩取</p>
<p><img src="47.png" alt=""><br>cmp语句中ESI的值为user32.dll的IAT起始地址 EBP的值为SetWindowTextW的地址 代码循环进入IAT SetWindowTextW的地址值（ebp的值）</p>
<h3 id="IAT钩取"><a href="#IAT钩取" class="headerlink" title="IAT钩取"></a>IAT钩取</h3><p>IAT钩取代码<br><img src="48.png" alt=""><br>MOV指令用来将MySetWindowTextW的地址覆写到前面从IAT中获取的SetWindowTextW的地址 执行后就变成了执行MySetWindowTextW地址的代码 也就是将数字变成汉字的代码段</p>
<h1 id="隐藏进程"><a href="#隐藏进程" class="headerlink" title="隐藏进程"></a>隐藏进程</h1><h2 id="API代码修改技术的原理"><a href="#API代码修改技术的原理" class="headerlink" title="API代码修改技术的原理"></a>API代码修改技术的原理</h2><p>IAT钩取通过操作进程的特定IAT值来实现API钩取 而API代码修改技术则将API代码的前5个字节修改为JMP XXXXXXXXXX指令来钩取API 调用执行被钩取的API时 JMP XXXXXXXXX就会被执行 转而控制hooking函数 后面描述的是 向process explorer进程（procexp.exe）注入stealth.dll文件后钩取ntdll.ZwQuery-SystemInformation（）API的整个过程（ntdll.ZwQuery-SystemInformation（）API是为了隐藏进程而需要钩取的API）</p>
<h3 id="注入之前"><a href="#注入之前" class="headerlink" title="注入之前"></a>注入之前</h3><p>首先看一下钩取之前正常调用API的进程内存。下图描述的是( 钩取之前)正常调用API的情形<br><img src="49.png" alt=""><br>procexp.exe代码调用ntdll.ZwQuerySystemInformation) API时，程序执行流顺序如下。</p>
<p>①procexp.exe的00422CF7地址处的CALL DWORD PTR DS:[48C69C]指令调 用ntdll.ZwQuerySystemInformation( API ( 48C69C地址在进程的IAT区域中，其值为7C93D92E，它是ntdll.ZwQuerySystemInformation() API的起始地址)。</p>
<p>②相应API执行完毕后，返回到调用代码的下一条指令的地址处。</p>
<h3 id="注入之后"><a href="#注入之后" class="headerlink" title="注入之后"></a>注入之后</h3><p>下面看看钩取指定API后程序执行的过程。先把stealth.dll注人目标进程( procexp.exe),直接修改ntdll.ZwQuerySystemInformation( API的代码( Code Patch ),如图所示。<br><img src="50.png" alt=""><br> 首先把stealth.dll注人目标进程，钩取ntll.ZwQuerySystemInformation( API。ntdll.ZwQuery-SystemInformation(O) API起始地址( 7C93D92E)的5个字节代码被修改为JMP 10001120 (仅修改5个字节代码)。10001 120是stealth.MyZwQuerySystemInformation(函数的地址。此时,在procexp.exe代码中调用ntdll.ZwQuerySystemInformation( API,程序将按如下顺序执行</p>
<p>①在422CF7地址处调用ntdll.ZwQuerySystemInformation() API ( 7C93D92E )。</p>
<p>②位于7C93D92E地址处的( 修改后的) JMP 10001 120指令将执行流转到10001120地址处( hooking函数)。10001 16A地址处的CALL unhook()指令用来将ntdll.ZwQuerySystemInformation(API的起始5个字节恢复原值。</p>
<p>③位于1000119B地址处的CALL EAX(7C93D92E)指令将调用原来的函数（ntdll.ZwQuery-SystemlnformationOAPI)(由于前面已经“脱钩”，所以可以正常调用执行）。</p>
<p>④ntdll.ZwQuerySystemlnformation（）执行完毕后，由7C93D93A地址处的RETN 10指令返回到 stealth.dll代码区域（调用自身的位置）。然后10001212地址处的CALL hook()指令再次钩取 ntdll.ZwQuerySystemlnformation（）API(即将开始的5字节修改为JMP10001120指令）</p>
<p>⑤stealth.MyZwQuerySystemInformation(函数执行完毕后，由10001233地址处的RETN 10命令返回到procexp.exe进程的代码区域，继续执行。</p>
<p>上述过程刚开始看似很难，多看几遍，慢慢就会明白的。<br>使用API代码修改技术的好处是可以钩取进程中使用的任意API。前面讲过的IAT钩取技术仅适用于可钩取的API,而API代码修改技术无此限制，(虽然代码会更复杂一些)使用起来要自由得多。使用API代码修改技术的唯- -限制是， 要钩取的API代码长度要大于5个字节，但是由于所有API代码长度都大于5个字节 所以事实上这个限制是不存在的</p>
<h2 id="练习（HideProc-exe，stealth-dll）"><a href="#练习（HideProc-exe，stealth-dll）" class="headerlink" title="练习（HideProc.exe，stealth.dll）"></a>练习（HideProc.exe，stealth.dll）</h2><p>HideProc exe负责将stealth.dll文件注人所有运行中的进程。Stealth.dll负责钩取(注人stealth.dll文件的)进程的ntdll.ZwQuerySystemInformation() API。接下来我们使用上面2个文件隐藏notepad.exe进程。<br><img src="2.png" alt=""></p>
<h3 id="运行notepad-exe-procexp-exe-taskmgr-exe"><a href="#运行notepad-exe-procexp-exe-taskmgr-exe" class="headerlink" title="运行notepad.exe procexp.exe taskmgr.exe"></a>运行notepad.exe procexp.exe taskmgr.exe</h3><p>首先运行要隐藏的进程notepad.exe(要隐藏的进程) procexp.exe（钩取对象1） taskmgr.exe（钩取对象2）</p>
<h3 id="运行HideProc-exe"><a href="#运行HideProc-exe" class="headerlink" title="运行HideProc.exe"></a>运行HideProc.exe</h3><p>运行HideProc.exe 将stealth.dll文件注入当前运行的所有程序：<br><img src="1.png" alt=""><br>简要介绍一下HideProc.exe命令的几个参数:<br>-hide/-show: -hide 用于隐藏，-show 用于取消隐藏。<br>process name:要隐藏的进程名称。<br>dllpath:要注入的DLL文件路径。</p>
<h3 id="查看进程是否隐藏成功"><a href="#查看进程是否隐藏成功" class="headerlink" title="查看进程是否隐藏成功"></a>查看进程是否隐藏成功</h3><p><img src="3.png" alt=""><br>我们发现任务管理器中的进程已经消失了 可是程序依然在运行 这就证明注入成功了</p>
<h3 id="取消进程隐藏"><a href="#取消进程隐藏" class="headerlink" title="取消进程隐藏"></a>取消进程隐藏</h3><p><img src="4.png" alt=""><br>我们可以发现在procexp.exe taskmgr.exe又能看到进程了</p>
<h2 id="源代码分析"><a href="#源代码分析" class="headerlink" title="源代码分析"></a>源代码分析</h2><h3 id="HideProc-cpp"><a href="#HideProc-cpp" class="headerlink" title="HideProc.cpp"></a>HideProc.cpp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">BOOL InjectAllProcess(int nMode, LPCTSTR szDllPath)</span><br><span class="line">&#123;</span><br><span class="line">	DWORD                   dwPID = 0;</span><br><span class="line">	HANDLE                  hSnapShot = INVALID_HANDLE_VALUE;</span><br><span class="line">	PROCESSENTRY32          pe;</span><br><span class="line"> </span><br><span class="line">	// Get the snapshot of the system</span><br><span class="line">	pe.dwSize = sizeof( PROCESSENTRY32 );</span><br><span class="line">	hSnapShot = CreateToolhelp32Snapshot( TH32CS_SNAPALL, NULL );</span><br><span class="line"> </span><br><span class="line">	// find process</span><br><span class="line">	Process32First(hSnapShot, &amp;pe);</span><br><span class="line">	do</span><br><span class="line">	&#123;</span><br><span class="line">		dwPID = pe.th32ProcessID;</span><br><span class="line"> </span><br><span class="line">        // 鉴于系统安全性的考虑</span><br><span class="line">        // 对于PID小于100的系统进程</span><br><span class="line">        // 不执行DLL注入操作</span><br><span class="line">		if( dwPID &lt; 100 )</span><br><span class="line">			continue;</span><br><span class="line"> </span><br><span class="line">        if( nMode == INJECTION_MODE )</span><br><span class="line">		    InjectDll(dwPID, szDllPath);</span><br><span class="line">        else</span><br><span class="line">            EjectDll(dwPID, szDllPath);</span><br><span class="line">	&#125;</span><br><span class="line">	while( Process32Next(hSnapShot, &amp;pe) );</span><br><span class="line"> </span><br><span class="line">	CloseHandle(hSnapShot);</span><br><span class="line"> </span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先通过SetPrivilege函数调用AdjustTokenPrivileges提升权限，然后在InjectAllProcess中使用CreateToolhelp32Snapshot获取系统中运行的所有进程的列表，使用Process32First与Process32Next将获得的进程信息存放到PROCESSENTRY32结构体变量pe中，进而获取进程的PID。获取了进程的PID后，要根据所用的命令选项来选择调用InjectDll函数还是EjectDll函数。当某进程的PID小于100时，鉴于系统安全性的考虑，忽略对它的操作。</p>
<h3 id="Stealth-dll"><a href="#Stealth-dll" class="headerlink" title="Stealth.dll"></a>Stealth.dll</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// global variable (in sharing memory)</span><br><span class="line">#pragma comment(linker, &quot;/SECTION:.SHARE,RWS&quot;)</span><br><span class="line">#pragma data_seg(&quot;.SHARE&quot;)</span><br><span class="line">    TCHAR g_szProcName[MAX_PATH] = &#123;0,&#125;;</span><br><span class="line">#pragma data_seg()</span><br><span class="line"> </span><br><span class="line">// export function</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line">__declspec(dllexport) void SetProcName(LPCTSTR szProcName)</span><br><span class="line">&#123;</span><br><span class="line">    _tcscpy_s(g_szProcName, szProcName);</span><br><span class="line">&#125;</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>首先看导出函数SetProcName。先创建名为.SHARE的共享内存节区，然后创建g_szProcName缓冲区，最后再由导出函数SetProcName将要隐藏的进程名称保存到g_szProcName中。</p>
<h3 id="DllMain"><a href="#DllMain" class="headerlink" title="DllMain()"></a>DllMain()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span><br><span class="line">&#123;</span><br><span class="line">    char            szCurProc[MAX_PATH] = &#123;0,&#125;;</span><br><span class="line">    char            *p = NULL;</span><br><span class="line"> </span><br><span class="line">    // #1. 异常处理</span><br><span class="line">    // 若当前进程为HookProc.exe则终止，不进行钩取操作</span><br><span class="line">    GetModuleFileNameA(NULL, szCurProc, MAX_PATH);</span><br><span class="line">    p = strrchr(szCurProc, &apos;\\&apos;);</span><br><span class="line">    if( (p != NULL) &amp;&amp; !_stricmp(p+1, &quot;HideProc.exe&quot;) )</span><br><span class="line">        return TRUE;</span><br><span class="line"> </span><br><span class="line">    switch( fdwReason )</span><br><span class="line">    &#123;</span><br><span class="line">        // #2. API Hooking</span><br><span class="line">        case DLL_PROCESS_ATTACH : </span><br><span class="line">        hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, </span><br><span class="line">                     (PROC)NewZwQuerySystemInformation, g_pOrgBytes);</span><br><span class="line">        break;</span><br><span class="line"> </span><br><span class="line">        // #3. API Unhooking </span><br><span class="line">        case DLL_PROCESS_DETACH :</span><br><span class="line">        unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, </span><br><span class="line">                       g_pOrgBytes);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先比较字符串，若进程名为HideProc.exe则不钩取API。发生DLL_PROCESS_ATTACH事件时，调用hook_by_code函数钩取API；发生DLL_PROCESS_DETACH事件时，调用unhook_by_code函数取消API钩取。</p>
<h3 id="hook-by-code"><a href="#hook-by-code" class="headerlink" title="hook_by_code()"></a>hook_by_code()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">BOOL hook_by_code(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew, PBYTE pOrgBytes)</span><br><span class="line">&#123;</span><br><span class="line">    FARPROC pfnOrg;</span><br><span class="line">    DWORD dwOldProtect, dwAddress;</span><br><span class="line">    BYTE pBuf[5] = &#123;0xE9, 0, &#125;;</span><br><span class="line">    PBYTE pByte;</span><br><span class="line"> </span><br><span class="line">    // 获取要钩取的API地址</span><br><span class="line">    pfnOrg = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">    pByte = (PBYTE)pfnOrg;</span><br><span class="line"> </span><br><span class="line">    // 若已经被钩取则返回FALSE</span><br><span class="line">    if( pByte[0] == 0xE9 )</span><br><span class="line">        return FALSE;</span><br><span class="line"> </span><br><span class="line">    // 向内存添加写属性</span><br><span class="line">    VirtualProtect((LPVOID)pfnOrg, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"> </span><br><span class="line">    // 备份原有代码(5字节)</span><br><span class="line">    memcpy(pOrgBytes, pfnOrg, 5);</span><br><span class="line"> </span><br><span class="line">    // 计算JMP地址 (E9 XXXX)</span><br><span class="line">    // =&gt; XXXX = pfnNew - pfnOrg - 5</span><br><span class="line">    dwAddress = (DWORD)pfnNew - (DWORD)pfnOrg - 5;</span><br><span class="line">    memcpy(&amp;pBuf[1], &amp;dwAddress, 4);</span><br><span class="line"> </span><br><span class="line">    // Hook:修改5 byte(JMP XXXX)</span><br><span class="line">    memcpy(pfnOrg, pBuf, 5);</span><br><span class="line"> </span><br><span class="line">    // 恢复内存属性</span><br><span class="line">    VirtualProtect((LPVOID)pfnOrg, 5, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">    </span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它通过修改代码实现API钩取操作。JMP指令的实际形式为E9 XXXXXXXX，XXXXXXXX=要跳转的地址-当前指令地址-当前指令长度(5)。</p>
<h3 id="unhook-by-code"><a href="#unhook-by-code" class="headerlink" title="unhook_by_code()"></a>unhook_by_code()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">BOOL unhook_by_code(LPCSTR szDllName, LPCSTR szFuncName, PBYTE pOrgBytes)</span><br><span class="line">&#123;</span><br><span class="line">    FARPROC pFunc;</span><br><span class="line">    DWORD dwOldProtect;</span><br><span class="line">    PBYTE pByte;</span><br><span class="line"> </span><br><span class="line">    // 获取API地址</span><br><span class="line">    pFunc = GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">    pByte = (PBYTE)pFunc;</span><br><span class="line"> </span><br><span class="line">    // 若已经脱钩则返回FALSE</span><br><span class="line">    if( pByte[0] != 0xE9 )</span><br><span class="line">        return FALSE;</span><br><span class="line"> </span><br><span class="line">    // 向内存添加写属性</span><br><span class="line">    VirtualProtect((LPVOID)pFunc, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"> </span><br><span class="line">    // Unhook</span><br><span class="line">    memcpy(pFunc, pOrgBytes, 5);</span><br><span class="line"> </span><br><span class="line">    // 恢复内存属性</span><br><span class="line">    VirtualProtect((LPVOID)pFunc, 5, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"> </span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>unhook_by_code函数是用来取消钩取的函数，原理就是将函数代码开始的前5个字节恢复原值</p>
<h3 id="NewZwQuerySystemInformation（）"><a href="#NewZwQuerySystemInformation（）" class="headerlink" title="NewZwQuerySystemInformation（）"></a>NewZwQuerySystemInformation（）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS WINAPI NewZwQuerySystemInformation(</span><br><span class="line">                SYSTEM_INFORMATION_CLASS SystemInformationClass, </span><br><span class="line">                PVOID SystemInformation, </span><br><span class="line">                ULONG SystemInformationLength, </span><br><span class="line">                PULONG ReturnLength)</span><br><span class="line">&#123;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    FARPROC pFunc;</span><br><span class="line">    PSYSTEM_PROCESS_INFORMATION pCur, pPrev;</span><br><span class="line">    char szProcName[MAX_PATH] = &#123;0,&#125;;</span><br><span class="line">    </span><br><span class="line">    // 开始前先脱钩</span><br><span class="line">    unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, g_pOrgBytes);</span><br><span class="line"> </span><br><span class="line">    // 调用原始API</span><br><span class="line">    pFunc = GetProcAddress(GetModuleHandleA(DEF_NTDLL), </span><br><span class="line">                           DEF_ZWQUERYSYSTEMINFORMATION);</span><br><span class="line">    status = ((PFZWQUERYSYSTEMINFORMATION)pFunc)</span><br><span class="line">              (SystemInformationClass, SystemInformation, </span><br><span class="line">              SystemInformationLength, ReturnLength);</span><br><span class="line"> </span><br><span class="line">    if( status != STATUS_SUCCESS )</span><br><span class="line">        goto __NTQUERYSYSTEMINFORMATION_END;</span><br><span class="line"> </span><br><span class="line">    // 针对SystemProcessInformation类型操作</span><br><span class="line">    if( SystemInformationClass == SystemProcessInformation )</span><br><span class="line">    &#123;</span><br><span class="line">        // SYSTEM_PROCESS_INFORMATION类型转换</span><br><span class="line">        // pCur是单向链表的头</span><br><span class="line">        pCur = (PSYSTEM_PROCESS_INFORMATION)SystemInformation;</span><br><span class="line"> </span><br><span class="line">        while(TRUE)</span><br><span class="line">        &#123;</span><br><span class="line">            // 比较进程名称</span><br><span class="line">            // g_szProcName为要隐藏的进程名称</span><br><span class="line">            // (=&gt; SetProcName()设置)</span><br><span class="line">            if(pCur-&gt;Reserved2[1] != NULL)</span><br><span class="line">            &#123;</span><br><span class="line">                if(!_tcsicmp((PWSTR)pCur-&gt;Reserved2[1], g_szProcName))</span><br><span class="line">                &#123;</span><br><span class="line">                    // 从链表中删除隐藏进程的节点</span><br><span class="line">                    if(pCur-&gt;NextEntryOffset == 0)</span><br><span class="line">                        pPrev-&gt;NextEntryOffset = 0;</span><br><span class="line">                    else</span><br><span class="line">                        pPrev-&gt;NextEntryOffset += pCur-&gt;NextEntryOffset;</span><br><span class="line">                &#125;</span><br><span class="line">                else		</span><br><span class="line">                    pPrev = pCur;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            if(pCur-&gt;NextEntryOffset == 0)</span><br><span class="line">                break;</span><br><span class="line"> </span><br><span class="line">            // 链表的下一项</span><br><span class="line">            pCur = (PSYSTEM_PROCESS_INFORMATION)</span><br><span class="line">                    ((ULONG)pCur + pCur-&gt;NextEntryOffset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">__NTQUERYSYSTEMINFORMATION_END:</span><br><span class="line"> </span><br><span class="line">    // 函数终止前再次执行API钩取操作，为下次调用准备</span><br><span class="line">    hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, </span><br><span class="line">                 (PROC)NewZwQuerySystemInformation, g_pOrgBytes);</span><br><span class="line"> </span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单分析一下 将SystemInformationClass参数设置为SystemProcessInformation（5）后调用ZwQuerySystemInformation（）API，SystemInformation[in/out]参数中储存的是SYSTEM_PROCESS_INFORMATIN结构体单向链表的起始地址 隐藏某进程之前，先要查找与之对应的链表成员，然后断开其与链表的链接。</p>
<h2 id="利用热补丁技术钩取API"><a href="#利用热补丁技术钩取API" class="headerlink" title="利用热补丁技术钩取API"></a>利用热补丁技术钩取API</h2><p>前面demo程序中通过代码修改技术进行API Hook存在的缺点</p>
<p>1.频繁脱钩，挂钩会造成整体性能下降</p>
<p>2.多线程环境，当一个线程尝试运行某段代码，而另一进程刚好在对该代码进行写操作，这时就会发生冲突，会引起非法访问异常（Access Violation）。《windows核心编程》指出，利用代码修改技术钩取API会对系统安全造成威胁</p>
<h3 id="热补丁（修改7Byte代码）"><a href="#热补丁（修改7Byte代码）" class="headerlink" title="热补丁（修改7Byte代码）"></a>热补丁（修改7Byte代码）</h3><p>Windows系统库中的函数，如kernel32.CreateProcessA/W, user32.MessageBoxA，gdi32.TextOutW有一个相似点</p>
<p>1.API以MOV EDI, EDI指令开始(IA-32 0X8bff)<br>2.API上方有5个NOP指令(IA-32 0X90)<br>微软做此设计的目的就是方便打热补丁。</p>
<p>使用热补丁Hook API的过程如下</p>
<p>1.修改API开始的两个字节MOV EDI,EDI为SHORT JMP指令EB F9, 跳转的目标地址是address_of_api - 5，即5个NOP指令的第一条<br>2.修改5个NOP指令为长跳转E9 XXXXXXXX，跳转到用户自定义API<br>3.用户自定义代码调用原始API时，直接以API+2的地址为API地址调用原API，这样就不会引起内存非法访问</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="DllMain（）"><a href="#DllMain（）" class="headerlink" title="DllMain（）"></a>DllMain（）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span><br><span class="line">&#123;</span><br><span class="line">    char            szCurProc[MAX_PATH] = &#123;0,&#125;;</span><br><span class="line">    char            *p = NULL;</span><br><span class="line"></span><br><span class="line">    // 判断进程名称，不向HideProc2.exe注入dll</span><br><span class="line">    GetModuleFileNameA(NULL, szCurProc, MAX_PATH);</span><br><span class="line">    p = strrchr(szCurProc, &apos;\\&apos;);</span><br><span class="line">    if( (p != NULL) &amp;&amp; !_stricmp(p+1, &quot;HideProc2.exe&quot;) )</span><br><span class="line">        return TRUE;</span><br><span class="line"></span><br><span class="line">    // change privilege</span><br><span class="line">    SetPrivilege(SE_DEBUG_NAME, TRUE);</span><br><span class="line"></span><br><span class="line">    switch( fdwReason )</span><br><span class="line">    &#123;</span><br><span class="line">        case DLL_PROCESS_ATTACH : </span><br><span class="line">            // hook</span><br><span class="line">            hook_by_hotpatch(&quot;kernel32.dll&quot;, &quot;CreateProcessA&quot;, </span><br><span class="line">                             (PROC)NewCreateProcessA);</span><br><span class="line">            hook_by_hotpatch(&quot;kernel32.dll&quot;, &quot;CreateProcessW&quot;, </span><br><span class="line">                             (PROC)NewCreateProcessW);</span><br><span class="line">            //可以看到这里没有对ZwQuerySystemInformation使用热补丁Hook，具体原因见&quot;3.热补丁Hook的缺点&quot;</span><br><span class="line">            hook_by_code(&quot;ntdll.dll&quot;, &quot;ZwQuerySystemInformation&quot;, </span><br><span class="line">                         (PROC)NewZwQuerySystemInformation, g_pOrgZwQSI);</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case DLL_PROCESS_DETACH :</span><br><span class="line">            // unhook</span><br><span class="line">            unhook_by_hotpatch(&quot;kernel32.dll&quot;, &quot;CreateProcessA&quot;);</span><br><span class="line">            unhook_by_hotpatch(&quot;kernel32.dll&quot;, &quot;CreateProcessW&quot;);</span><br><span class="line">            unhook_by_code(&quot;ntdll.dll&quot;, &quot;ZwQuerySystemInformation&quot;, </span><br><span class="line">                           g_pOrgZwQSI);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和之前代码一样，在Dll附加进程的时候调用hook方法，在dll卸载时调用unhook方法</p>
<h4 id="hook-by-hotpatch"><a href="#hook-by-hotpatch" class="headerlink" title="hook_by_hotpatch()"></a>hook_by_hotpatch()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">BOOL hook_by_hotpatch(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew)</span><br><span class="line">&#123;</span><br><span class="line">    FARPROC pFunc;</span><br><span class="line">    DWORD dwOldProtect, dwAddress;</span><br><span class="line">    BYTE pBuf[5] = &#123; 0xE9, 0, &#125;;</span><br><span class="line">    BYTE pBuf2[2] = &#123; 0xEB, 0xF9 &#125;;</span><br><span class="line">    PBYTE pByte;</span><br><span class="line"></span><br><span class="line">    pFunc = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">    pByte = (PBYTE)pFunc;</span><br><span class="line">    if( pByte[0] == 0xEB )</span><br><span class="line">        return FALSE;</span><br><span class="line"></span><br><span class="line">    VirtualProtect((LPVOID)((DWORD)pFunc - 5), 7, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    // 1. NOP (0x90)</span><br><span class="line">    dwAddress = (DWORD)pfnNew - (DWORD)pFunc;</span><br><span class="line">    memcpy(&amp;pBuf[1], &amp;dwAddress, 4);</span><br><span class="line">    memcpy((LPVOID)((DWORD)pFunc - 5), pBuf, 5);</span><br><span class="line">    </span><br><span class="line">    // 2. MOV EDI, EDI (0x8BFF)</span><br><span class="line">    memcpy(pFunc, pBuf2, 2);</span><br><span class="line"></span><br><span class="line">    VirtualProtect((LPVOID)((DWORD)pFunc - 5), 7, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改API中无用的7字节数据，跳转到用户自定义Hook函数</p>
<h4 id="unhook-by-hotpatch"><a href="#unhook-by-hotpatch" class="headerlink" title="unhook_by_hotpatch"></a>unhook_by_hotpatch</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">BOOL unhook_by_hotpatch(LPCSTR szDllName, LPCSTR szFuncName)</span><br><span class="line">&#123;</span><br><span class="line">    FARPROC pFunc;</span><br><span class="line">    DWORD dwOldProtect;</span><br><span class="line">    PBYTE pByte;</span><br><span class="line">    BYTE pBuf[5] = &#123; 0x90, 0x90, 0x90, 0x90, 0x90 &#125;;</span><br><span class="line">    BYTE pBuf2[2] = &#123; 0x8B, 0xFF &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pFunc = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">    pByte = (PBYTE)pFunc;</span><br><span class="line">    if( pByte[0] != 0xEB )</span><br><span class="line">        return FALSE;</span><br><span class="line"></span><br><span class="line">    VirtualProtect((LPVOID)pFunc, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    // 1. NOP (0x90)</span><br><span class="line">    memcpy((LPVOID)((DWORD)pFunc - 5), pBuf, 5);</span><br><span class="line">    </span><br><span class="line">    // 2. MOV EDI, EDI (0x8BFF)</span><br><span class="line">    memcpy(pFunc, pBuf2, 2);</span><br><span class="line"></span><br><span class="line">    VirtualProtect((LPVOID)pFunc, 5, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将7字节数据修改为原数据</p>
<h4 id="NewCreateProcess"><a href="#NewCreateProcess" class="headerlink" title="NewCreateProcess"></a>NewCreateProcess</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI NewCreateProcessA(</span><br><span class="line">    LPCTSTR lpApplicationName,</span><br><span class="line">    LPTSTR lpCommandLine,</span><br><span class="line">    LPSECURITY_ATTRIBUTES lpProcessAttributes,</span><br><span class="line">    LPSECURITY_ATTRIBUTES lpThreadAttributes,</span><br><span class="line">    BOOL bInheritHandles,</span><br><span class="line">    DWORD dwCreationFlags,</span><br><span class="line">    LPVOID lpEnvironment,</span><br><span class="line">    LPCTSTR lpCurrentDirectory,</span><br><span class="line">    LPSTARTUPINFO lpStartupInfo,</span><br><span class="line">    LPPROCESS_INFORMATION lpProcessInformation</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    BOOL bRet;</span><br><span class="line">    FARPROC pFunc;</span><br><span class="line"></span><br><span class="line">    pFunc = GetProcAddress(GetModuleHandleA(&quot;kernel32.dll&quot;), &quot;CreateProcessA&quot;);</span><br><span class="line">    //以API地址+2为函数地址调用CreateProcessA函数</span><br><span class="line">    pFunc = (FARPROC)((DWORD)pFunc + 2);</span><br><span class="line">    bRet = ((PFCREATEPROCESSA)pFunc)(lpApplicationName,</span><br><span class="line">                                     lpCommandLine,</span><br><span class="line">                                     lpProcessAttributes,</span><br><span class="line">                                     lpThreadAttributes,</span><br><span class="line">                                     bInheritHandles,</span><br><span class="line">                                     dwCreationFlags,</span><br><span class="line">                                     lpEnvironment,</span><br><span class="line">                                     lpCurrentDirectory,</span><br><span class="line">                                     lpStartupInfo,</span><br><span class="line">                                     lpProcessInformation);</span><br><span class="line"></span><br><span class="line">    // 注入steach3.dll</span><br><span class="line">    if( bRet )</span><br><span class="line">        InjectDll2(lpProcessInformation-&gt;hProcess, STR_MODULE_NAME);</span><br><span class="line"></span><br><span class="line">    return bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意一点，在使用之前的hook方法进行API钩取时，在用户自定义NewCreateProcess函数开头需要调用unhook方法(防止进入钩取的死循环)，函数结尾需要调用hook方法进行重新钩取。</p>
<p>但是使用热补丁Hook时不需要这样反复脱钩，挂钩，只需在调用原始API时，使用address of API + 2的地址调用API即可</p>
<h3 id="使用热补丁进行Hook的缺点"><a href="#使用热补丁进行Hook的缺点" class="headerlink" title="使用热补丁进行Hook的缺点"></a>使用热补丁进行Hook的缺点</h3><p>热补丁钩取技术有个明显的缺点，即不符合钩取条件（7字节无用代码）的API无法使用热补丁钩取</p>
<p>这样的API有，ntdll.dll提供的API 和kernel32.GetStartInfoA() 等</p>
<p>并非所有API都能使用热补丁钩取，所以使用前需要先确认要钩取的API是否支持，若不支持则需使用前面的5字节代码修改技术</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/09/OD学习记录5-11/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/09/OD学习记录5-11/" itemprop="url">OD学习记录5.11</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-09T19:18:09+08:00">
                2019-05-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="API钩取"><a href="#API钩取" class="headerlink" title="API钩取"></a>API钩取</h1><p>api(application programming interface,应用程序编程接口）。windows系统资源都是由windows os系统直接管理的，用户不能直接访问。用户需要访问系统资源的时候，必须向系统内核（kernel)申请，申请的方法就是使用微软提供的win32api.为了实际运行相应的程序代码，需要加载许多系统库（DLL).所有的进程都会默认加载kernel32.dll,kernel32.dll又会加载ntdll.dll库。</p>
<p><img src="1.png" alt=""><br>用户模式中的应用程序访问系统资源的时候，由ntdll.dll向内核模式提出访问请求。一般常规系统资源的api会经由kernel32.dll与ntdll.dll不断向下调用，最后同故宫SYSENTRY命令进入内核模式。</p>
<p>使用api钩取技术可以实现对某些win32API 的嗲用过程拦截，并获得相应的控制权限，使用api钩取技术的优势如下：<br>1）再api调用前/后运行用户的”钩子“代码。</p>
<p>2）查看或操作传递给api的参数或者传递api的返回值</p>
<p>3）取消对api的调用，或者更改执行流程，运行用户代码</p>
<p>下表列出了api钩取的技术图表：<br><img src="2.png" alt=""><br> 根据对象的不同，api钩取可以分为静态方法与动态方法。静态方法是针对的是“文件”，而动态方法针对的是进程内存。根据钩取的位置不懂，可以分为：</p>
<p>1)iat,将iad内部的api地址更改为钩取函数地址，该方法的优点是实现起来非常见到那，缺点是不能钩取不在iat中的api.</p>
<p>2)代码：系统库（*.dll）映射到进程内存时，从中查找api的实际嗲hi，并直接修改代码，具体的方法分为以下几种：使用jmp指令修改起始代码，覆写函数局部，仅更改必须部分的局部</p>
<p>3）eat:将记录在dll中的eat中的api起始地址更改为钩取函数地址也可以实现api钩取。</p>
<p>根据对应的技术不同，可以分为以下几种技术：</p>
<p>1）调试技术</p>
<p>调试法通过调试目标继承钩取api.调试器拥有被调试者的所有权限（执行控制，内存访问），所以可以向被调试进程的内存任意位置设置钩取函数。这里的调试器是用户编写的用来钩取的程序。在用户编写的程序中使用调试api附加到目标进程，然后设置钩取函数，这样，重启运行时就能偶完全实现api钩取了。也可以向现有的调试器（od,ida,windbg)使用自动化脚本，自动钩取api.</p>
<p>2)注入</p>
<p>向目标进程内存区域进行渗透测试的技术，根据注入对象的不同，可以分为dll注入与代码注入两种技术。</p>
<p>a)dll注入</p>
<p>使用dll注入即使可以使目标进程强制加载用户指定的dll文件。使用该技术的时候需要先在注入的dll中创建钩取代码与设置钩代码，然后再dllmain()中调用设置代码，注入的同时即可完成api钩取。</p>
<p>b）代码注入</p>
<p>代码注入技术广泛用于恶意代码，代码注入技术比dll注入技术更发达。</p>
<h1 id="记事本WriteFile（）API钩取"><a href="#记事本WriteFile（）API钩取" class="headerlink" title="记事本WriteFile（）API钩取"></a>记事本WriteFile（）API钩取</h1><h2 id="运行调试"><a href="#运行调试" class="headerlink" title="运行调试"></a>运行调试</h2><p>这次在windowsXP的虚拟机下调试程序 因为在自己的win10下有问题无法调试 所以就在winXP下去尝试了<br>首先运行notepad.exe 得到其PID 如图<br><img src="3.png" alt=""><br>然后运行hookdbg.exe 如图：<br><img src="4.png" alt=""><br>接下来像记事本里输入小写字母 随便输就行:<br><img src="5.png" alt=""><br>输入完后保存文件 发现刚才CMD黑框里的内容也变了：<br><img src="6.png" alt=""><br>发现刚好是刚才输入的内容和转变位大写的内容.<br>打开保存的记事本文件发现：<br><img src="7.png" alt=""><br>这就是钩取成功的表现了 下面看看其工作原理</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>先来看看WriteFile()定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL WriteFile(</span><br><span class="line">HANDLE  hFile,//文件句柄</span><br><span class="line">LPCVOID lpBuffer,//数据缓存区指针</span><br><span class="line">DWORD   nNumberOfBytesToWrite,//你要写的字节数</span><br><span class="line">LPDWORD lpNumberOfBytesWritten,//用于保存实际写入字节数的存储区域的指针</span><br><span class="line">LPOVERLAPPED lpOverlapped//OVERLAPPED结构体指针</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>参数 类型及说明<br>hFile Long，一个文件的句柄</p>
<p>lpBuffer Any，参数类型:指针,指向将写入文件的 数据缓冲区</p>
<p>nNumberOfBytesToWrite Long，要写入数据的字节数量。如写入零字节，表示什么都不写入，但会更新文件的“上一次修改时间”。针对位于远程系统的命名管道，限制在65535个字节以内</p>
<p>lpNumberOfBytesWritten Long，实际写入文件的字节数量（此变量是用来返回的 ）</p>
<p>lpOverlapped OVERLAPPED，倘若在指定FILE_FLAG_OVERLAPPED的前提下打开文件，这个参数就必须引用一个特殊的结构。那个结构定义了一次异步写操作。否则，该参数应置为空（将声明变为ByVal As Long，并传递零值）</p>
<p>用OD打开notepad 并在每个WriteFile上设置断点<br><img src="8.png" alt=""><br>运行程序并在记事本里输入内容 保存后发现 程序断在了WriteFile()处 并发现到了这4个重要的点<br><img src="9.png" alt=""><br>栈中有（ESP）1个返回值ESP+8中存在数据缓冲区的地址 直接跳转到此地址可以发现刚才输入的字符串 钩取Write/file（）API后 用指定字符串覆盖数据缓冲区的内容即可</p>
<h2 id="源代码分析（hookdng-cpp源代码）"><a href="#源代码分析（hookdng-cpp源代码）" class="headerlink" title="源代码分析（hookdng.cpp源代码）"></a>源代码分析（hookdng.cpp源代码）</h2><h3 id="main"><a href="#main" class="headerlink" title="main()"></a>main()</h3><p><img src="10.png" alt=""><br>Main函数以程序运行参数的形式接收要钩取API的进程的PID，然后通过DebugActiveProcess()API将调试器附加到该运行的进程上，开始调试。然后进入DebugLoop()函数，处理来自被调试者的调试事件。（也可以通过CreateProcess()API，从一开始就直接以调试模式运行进程）</p>
<h3 id="DebugLoop"><a href="#DebugLoop" class="headerlink" title="DebugLoop()"></a>DebugLoop()</h3><p><img src="11.png" alt=""><br>DebugLoop处理了三个DebugEvent，分别是</p>
<p>CREATE_PROCESS_DEBUG_EVENT： 被调试进程启动/附加时触发该事件，调试器调用OnCreateProcessDebugEvent()</p>
<p>EXCEPTION_DEBUG_EVENT：被调试进程遇到iNT 3指令时触发该事件，调试器调用OnExceptionDebugEvent()</p>
<p>EXIT_PROCESS_DEBUG_EVENT：被调试进程终止时触发，在本代码中，调试器在被调试器终止时退出</p>
<p>DebugL oop0函数的工作原理类似于窗口过程函数( WndProc ),它从被调试者处接收事件并处理，然后使被调试者继续运行。DebugLoop(函数代码比较简单，结合代码中的注释就能理解。下面看看其中比较重要的2个API。</p>
<p>顾名思义，WaitForDebugEvent() API (出处: MSDN)是-一个等待被调试者发生调试事件的函数(行为动作类似于WaitForSingleObject() API )。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WaitForDebugEvent(</span><br><span class="line"> </span><br><span class="line">    __in LPDEBUG_EVENT lpDebugEvent,</span><br><span class="line"> </span><br><span class="line">    __in DWORD dwMilliseconds</span><br><span class="line"> </span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>DebugLoop(函数代码中,若发生调试事件, WaitForDebugEvent( API就会将相关事件信息设置到其第- -个参数的变量( DEBUG EVENT结构体对象), 然后立刻返回。DEBUG EVENT结构体定义(出处: MSDN)如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _DEBUG_EVENT &#123;</span><br><span class="line"> </span><br><span class="line">    DWORD dwDebugEventCode;</span><br><span class="line"> </span><br><span class="line">    DWORD dwProcessId;</span><br><span class="line"> </span><br><span class="line">    DWORD dwThreadId;</span><br><span class="line"> </span><br><span class="line">    union &#123;</span><br><span class="line"> </span><br><span class="line">        EXCEPTION_DEBUG_INFO Exception;</span><br><span class="line"> </span><br><span class="line">        CREATE_THREAD_DEBUG_INFO CreateThread;</span><br><span class="line"> </span><br><span class="line">        CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;</span><br><span class="line"> </span><br><span class="line">        EXIT_THREAD_DEBUG_INFO ExitThread;</span><br><span class="line"> </span><br><span class="line">        EXIT_PROCESS_DEBUG_INFO ExitProcess;</span><br><span class="line"> </span><br><span class="line">        LOAD_DLL_DEBUG_INFO LoadDll;</span><br><span class="line"> </span><br><span class="line">        UNLOAD_DLL_DEBUG_INFO UnloadDll;</span><br><span class="line"> </span><br><span class="line">        OUTPUT_DEBUG_STRING_INFO DebugString;</span><br><span class="line"> </span><br><span class="line">        RIP_INFO RipInfo;</span><br><span class="line"> </span><br><span class="line">    &#125; u;</span><br><span class="line"> </span><br><span class="line">&#125; DEBUG_EVENT, *LPDEBUG_EVENT;</span><br></pre></td></tr></table></figure>
<p>前面的讲解中已经提到过，共有9种调试事件。DEBUG_ EVENT.dwDebugEventCode成员 会被设置为9种事件中的一-种，根据相关事件的种类，也会设置适当的DEBUG_EVENTu(union)成员( DEBUG EVENT.u共用体成员内部也由9个结构体组成，它们对应于事件种类的个数)</p>
<p>ContinueDebugEvent是一个使调试器继续运行的API</p>
<p>定义如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ContinueDebugEvent(</span><br><span class="line"> </span><br><span class="line">    __in DWORD dwProcessId,</span><br><span class="line"> </span><br><span class="line">    __in DWORD dwThreadId,</span><br><span class="line"> </span><br><span class="line">    __in DWORD dwContinueStatus</span><br><span class="line"> </span><br><span class="line">    );</span><br></pre></td></tr></table></figure></p>
<p>ContinueDebugEvent() API 的 最 后 一 个 参 数 dwContinueStatus 的 值 为 DBG_CONTINUE 或  DBG_EXCEPTION_NOT_HANDLED。若处理正常，则其值设置为DBG_CONTINUE;若无法处理，或希望在应用程序的SEH中处 理，则其值设置为DBG EXCEPTION NOT HANDLED</p>
<p>DebugLoopO函数处理3种调试事件，如下所示。</p>
<p>□ EXIT_PROCESS_DEBUG_EVENT</p>
<p>□ CREATE_PROCESS_DEBUG_EVENT</p>
<p>□ EXCEPTION_DEBUG_EVENT</p>
<p>下面分别看看这3个事件。<br>EXIT_PROCESS_DEBUG_EVENT</p>
<p>被调试进程终止时会触发该事件。本章的示例代码中发生该事件时，调试器与被调试者将一 起终止。</p>
<p>CREATE_PROCESS_DEBUG_EVENT-OnCreateProcessDebugEvent()</p>
<p>OnCreateProcessDebugEvent()是 CREATE_PROCESS_DEBUG_EVENT 事件句柄，被调试进程启动（或者附加）时即调用执行该函数。</p>
<h3 id="OnCreateProcessDebugEvent"><a href="#OnCreateProcessDebugEvent" class="headerlink" title="OnCreateProcessDebugEvent()"></a>OnCreateProcessDebugEvent()</h3><p><img src="12.png" alt=""><br>代码首先获得WriteFile的内存地址,</p>
<p>然后将函数地址处的第一个字节数据存放在g_chOrgByte变量中，之后将函数地址处第一个字节改为0xCC</p>
<p>由于调试器拥有被调试进程的句柄（带有调试权限，DLL注入时也是首先将进程提升为调试权限[SE_DEBUG_NAME]）所以可以使用ReadProcessMemory和WriteProcessMemory对被调试进程的内存空间自由进行读写操作。</p>
<h3 id="OnExceptionDebugEvent"><a href="#OnExceptionDebugEvent" class="headerlink" title="OnExceptionDebugEvent()"></a>OnExceptionDebugEvent()</h3><p><img src="13.png" alt=""><br><img src="14.png" alt=""><br><img src="15.png" alt=""><br><img src="16.png" alt=""><br>OnExceptionDebugEvent(函数代码有些多，接下来分析核心部分。首先，if语句用于检测异常是否为EXCEPTION_ BREAKPOINT异常(除此之外，还有大约19种异常,请参考前几节内容)。然后，用if语句检测发生断点的地址是否与kernel32!WriteFile(的起始地址一致( OnCreateProcessDebugEvent()已经事先获取了WriteFile()的起始地址)。若满足条件,则继续执行以下代码\</p>
<h4 id="脱钩（恢复原代码）"><a href="#脱钩（恢复原代码）" class="headerlink" title="脱钩（恢复原代码）"></a>脱钩（恢复原代码）</h4><p><img src="17.png" alt=""></p>
<h4 id="获取线程上下文"><a href="#获取线程上下文" class="headerlink" title=".获取线程上下文"></a>.获取线程上下文</h4><p>这是第1次提到“线程上下文”，所有程序在内存中都以进程为单位运行，而进程的实际指令代码以线程为单位运行。Windows OS是一个多线程 ( multi-thread )操作系统，同-进程中可以同时运行多个线程。多任务( multi-tasking )是将CPU资源划分为多个时间片( time-slice),然后平等地逐一 运行所有线程(考虑线程优先级)。 CPU运行完一 个线程的时间片而切换到其他线程时间片时，它必须将先前线程处理的内容准确备份下来，这样再次运行它时才能正常无误。</p>
<p>再次运行先前线程时，必须有运行所需信息，这些重要信息指的就是CPU中各寄存器的值。通过这些值，才能保证CPU能够再次准确运行它(内存信息栈&amp;堆存在于相应进程的虚拟空间,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI</span><br><span class="line">BOOL</span><br><span class="line">WINAPI</span><br><span class="line">GetThreadContext(</span><br><span class="line">    __in    HANDLE hThread,</span><br><span class="line">    __inout LPCONTEXT lpContext</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>像这样调用GetThreadContext() API (出处: MSDN),即可将指定线程( g_ cpdi.hThread)的CONTEXT存储到ctx结构体变量( g_ cpdi.hThread是被调试者的主线程句柄)。</p>
<h4 id="获取WriteFile-的param值"><a href="#获取WriteFile-的param值" class="headerlink" title="获取WriteFile()的param值"></a>获取WriteFile()的param值</h4><p>调用WriteFile()函数时,我们要在传递过来的参数中知道param2 (数据缓冲区地址)与param3(缓冲区大小)这2个参数。函数参数存储在栈中，通过#2中获取的CONTEXT.Esp成员可以分别获得它们的值</p>
<p><img src="18.png" alt=""><br>存储在dwAddrOfBuffer中的数据缓冲区地址是被调试者（notepad.exe）虚拟内存空间中的地址</p>
<h4 id="把小写字母转换为大写字母后覆写在WriteFile-缓冲区"><a href="#把小写字母转换为大写字母后覆写在WriteFile-缓冲区" class="headerlink" title="把小写字母转换为大写字母后覆写在WriteFile()缓冲区"></a>把小写字母转换为大写字母后覆写在WriteFile()缓冲区</h4><p>获取数据缓冲区的地址与大小后,将其内容读到调试器的内存空间，把小写字母转换为大写字母。然后将修改后的大写字母覆写到原位置(被调试者的虚拟内存)。整个代码不难，结合代码中的注释就能轻松理解</p>
<p><img src="19.png" alt=""></p>
<h4 id="把线程上下文的EIP修改为WriteFile-起始地址"><a href="#把线程上下文的EIP修改为WriteFile-起始地址" class="headerlink" title="把线程上下文的EIP修改为WriteFile()起始地址"></a>把线程上下文的EIP修改为WriteFile()起始地址</h4><p><img src="20.png" alt=""><br>将线程上下文的EIP更改为WriteFile()首地址(当前为WriteFile() + 1位置，int3命令之后)</p>
<p>修改好CONTEXT.Eip成员后，调用SetThreadContext()API来修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SetThreadContext(</span><br><span class="line"> </span><br><span class="line">    __in HANDLE hThread,</span><br><span class="line"> </span><br><span class="line">    __in CONST CONTEXT *lpContext</span><br><span class="line"> </span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h5 id="运行调试进程"><a href="#运行调试进程" class="headerlink" title="运行调试进程"></a>运行调试进程</h5><p> 全部准备完成后，接下来就正常调用WriteFile()API了，调用ContinueDebugEvent()API就可以重启被调试进程，使之继续运行。</p>
<h4 id="继续HOOK（达到循环获取的目的）"><a href="#继续HOOK（达到循环获取的目的）" class="headerlink" title="继续HOOK（达到循环获取的目的）"></a>继续HOOK（达到循环获取的目的）</h4><p> 最后设置API“钩子”，方便下次钩取操作(若略去该操作，由于#1中已经“脱钩”, WriteFile()API钩取将完全处于“脱钩”状态)</p>
<p><img src="21.png" alt=""><br>在 OnExceptionDebugEvent()函 数 中 调 用 了 ContinueDebugEvent()函 数 后 ，为 什 么 还 要  调 用Sleep(0)函 数 ？</p>
<font color="#00ffff" size="3">调 用Sleep(0)函 数 可 以 释 放 当 前 线 程 的 剩 余 时 间 片 ， 即 放 弃 当 前 线 程 执 行 的CPU时 间 片。也 就 是 说 ， 调 用Sleep(0)函 数 后 ，CPU会 立 即 执 行 其 他 线 程 。 被 调 试 进 程（Notepad.exe) 的 主 线 程 处 于 运 行 状 态 时 ， 会 正 常 调 用WriteFiIe()API。然 后 经 过 一 定 时 间 ， 控 制 权 再 次 转 移 给HookDbg.exe, Sleep(0)后 面 的 “ 钩子 ” 代 码（WriteProcessMemory()API)会 被 调 用 执 行。若 没 有Sleep(0)语 句 ，Notepad.exe调 用WriteFile()API的 过 程 中 ，HookDbg.exe会尝试将WriteFile()API的首字节修改为OxCC。若运气不佳，这可能会导致内存访问异常。（避免notepad正在调用writefile()API的过程中，后面的钩子代码在调用成功之前执行完毕)</font>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/04/od学习5-4/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/04/od学习5-4/" itemprop="url">od学习5.4</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-04T21:33:15+08:00">
                2019-05-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="windows消息钩取"><a href="#windows消息钩取" class="headerlink" title="windows消息钩取"></a>windows消息钩取</h1><h2 id="简单地说，消息钩取就是偷看、截取信息。"><a href="#简单地说，消息钩取就是偷看、截取信息。" class="headerlink" title="简单地说，消息钩取就是偷看、截取信息。"></a>简单地说，消息钩取就是偷看、截取信息。</h2><h2 id="常规Windows消息流："><a href="#常规Windows消息流：" class="headerlink" title="常规Windows消息流："></a>常规Windows消息流：</h2><p>1、发生键盘输入事件时，WM_KEYDOWN消息被添加到[OS message queue]；</p>
<p>2、OS判断哪个应用程序中发生了事件，然后从[OS message queue]中取出消息，添加到相应应用程序的[application message queue]中；</p>
<p>3、应用程序监视自身的[application message queue]，发现新添加的WM_KEYDOWN消息后，调用相应的事件处理程序处理。</p>
<h2 id="消息钩子："><a href="#消息钩子：" class="headerlink" title="消息钩子："></a>消息钩子：</h2><p>Windows OS向用户提供GUI，其是以事件驱动的方式进行工作的。每当发生这样的事件时，OS会将事先定义好的消息发送给相应的应用程序，应用程序分析收到的信息后执行相应动作。即在敲击键盘时，消息从OS传递到应用程序，此过程中消息钩子可以偷看其中的信息。</p>
<p>消息钩子是Windows OS提供的基本功能，其中最具代表性的是VS Visual Studio中提供的SPY++，其是一个功能强大的消息钩取程序，能够查看OS中来往的所有消息。</p>
<p>如下图，OS消息队列和应用程序消息队列之间存在一条钩链（Hook Chain），设置好键盘消息钩子后，处于钩链中的键盘消息钩子会比应用程序先一步看到相应信息。在键盘消息钩子函数的内部，除了可以查看消息之外，还可以修改消息本身，而且还能对消息实施拦截，阻止消息传递。可以同时设置多个相同的键盘消息钩子，按照设置的顺序依次调用，从而组成的链条称为钩链。</p>
<p><img src="1.jpg" alt=""></p>
<h2 id="Windows消息钩取的实现——SetWindowsHookEx"><a href="#Windows消息钩取的实现——SetWindowsHookEx" class="headerlink" title="Windows消息钩取的实现——SetWindowsHookEx()"></a>Windows消息钩取的实现——SetWindowsHookEx()</h2><p>在Windows编程中，使用SetWindowsHookEx() API可以简便地实现消息钩子，其用于将指定的钩子注册到钩链中，无论在DLL内部或外部都可调用.</p>
<p>SetWindowsHookEx() API定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HHOOK SetWindowsHookEx(</span><br><span class="line">    int idHook,			//hook type</span><br><span class="line">    HOOKPROC lpfn,		//hook procedure</span><br><span class="line">    HINSTANCE hMod,		//hook procedure所属的DLL句柄</span><br><span class="line">    DWORD dwThreadId	//将要挂钩的目标线程ID</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>HHOOK：返回值，钩子句柄，需要保留，等不使用钩子时通过UnhookWindowsHookEx函数卸载钩子。</p>
<p>idHook：钩子的拦截消息类型，选择钩子程序的拦截范围，具体值参考文章结尾的消息类型。</p>
<p>Lpfn：消息的回调函数地址，一般是填函数名。</p>
<p>hMod：钩子函数所在的实例的句柄。对于线程钩子，该参数为NULL；对于系统钩子，该参数为钩子函数所在的DLL句柄。在dll中可通过AfxInitExtensionModule(MousehookDLL, hInstance)获得DLL句柄。</p>
<p>dwThreadId：钩子所监视的线程的线程号，可通过GetCurrentThreadId()获得线程号。对于全局钩子，该参数为NULL(或0)。</p>
<h2 id="调试Windows消息钩取"><a href="#调试Windows消息钩取" class="headerlink" title="调试Windows消息钩取"></a>调试Windows消息钩取</h2><h3 id="1、调试HookMain-exe："><a href="#1、调试HookMain-exe：" class="headerlink" title="1、调试HookMain.exe："></a>1、调试HookMain.exe：</h3><p><img src="2.png" alt=""><br>直接拉到401000处可以看到：<br><img src="3.png" alt=""><br>程序先在401006地址处调用LoadLibraryA(KeyHook.dll)，然后在40104B地址处的CALLEBX指令调用KeyHook.HookStart()函数。跟踪进入该函数查看：</p>
<p><img src="4.png" alt=""><br>在100010EF地址处可以看到，调用了SetWindowsHookExW()函数，其上方两条PUSH指令将该函数的第一、第二两个参数压入栈。其中第一个参数idHook值为2，即WH_KEYBOARD，第二个参数lpfn值为74C21020，该值即为钩子过程的地址。</p>
<p>返回main()函数之后的代码即为接收用户输入的q后即终止钩取</p>
<h3 id="2-调试Notepad-exe："><a href="#2-调试Notepad-exe：" class="headerlink" title="2.调试Notepad.exe："></a>2.调试Notepad.exe：</h3><p><img src="5.png" alt=""><br>在调试界面里的事件选择：<br><img src="6.png" alt=""><br>开启后 每当新的DLL被调试时就会自动暂停调试 在从DLL注入调试时开始调试的情况下很有用<br>运行后发现：<br><img src="7.png" alt=""><br>双击HOOK到达HOOK的EP地址处 给此处设置断点 发现每次发生键盘输入事件时 程序就会停在此处</p>
<h1 id="Dll注入"><a href="#Dll注入" class="headerlink" title="Dll注入"></a>Dll注入</h1><h2 id="用CreateRemoteThread实现DLL注入"><a href="#用CreateRemoteThread实现DLL注入" class="headerlink" title="用CreateRemoteThread实现DLL注入"></a>用CreateRemoteThread实现DLL注入</h2><h3 id="（一）myhack-dll，即要注入的dll程序"><a href="#（一）myhack-dll，即要注入的dll程序" class="headerlink" title="（一）myhack.dll，即要注入的dll程序"></a>（一）myhack.dll，即要注入的dll程序</h3><p>程序流程：<br>（1）当DLL被加载（DLL_PROCESS_ATTACH）时，先输出一个调试字符串，<br>（2）利用CreateThread() 创建一个线程，创建后立即被激活，直接调用ThreadProc函数<br>（3）该函数调用URLDownloadToFile() 下载指定网站的index.html文件<br>首先将InjectDll.exe和myhack.DLl放入一个文件夹<br><img src="13.png" alt=""><br>运行notepad.exe 看到PID是6340<br><img src="14.png" alt=""><br>myhack.dll注入<br><img src="15.png" alt=""><br>结果确认<br><img src="16.png" alt=""><br>发现文件夹里多了文件  打开看看<br><img src="17.png" alt=""><br>虽然看起来与实际主页可能不同 但确实是从该网站下载的index.html文件<br>上述借助创建远程线程的方法可以成功渗透指定进程 进而可以随意操作</p>
<h3 id="（二）InjectDll-exe，即将myhack-dll注入notepad-exe的程序"><a href="#（二）InjectDll-exe，即将myhack-dll注入notepad-exe的程序" class="headerlink" title="（二）InjectDll.exe，即将myhack.dll注入notepad.exe的程序"></a>（二）InjectDll.exe，即将myhack.dll注入notepad.exe的程序</h3><p>程序流程：<br>（1）首先进行提权，如果不提权，OpenProcess()会报GetlastError[5]的错误，同时拿不到句柄。这是因为在xp环境下，虽然账号是管理员，但是权限默认没有启动。<br>（2）利用OpenProcess() 获得目标进程的句柄。这里指notepad.exe<br>（3）用VirtualAllocEx() 在目标进程空间分配一定的内存空间。用来写入DLL的路径<br>（4）用WriteProcessMemory() 将DLL路径字符串写入刚分配的内存。<br>（5）利用GetModuleHandle() 和GetProcessAddress() 得到LoadLibrary() 的地址。用来加载DLL<br>（6）利用CreateRemoteThread() 使LoadLibrary()加载DLL，实现DLL的注入。<br>给进程提权有三种方法：</p>
<h4 id="调试："><a href="#调试：" class="headerlink" title="调试："></a>调试：</h4><p>打开记事本，OD attach ，运行；<br>将OD的选项-&gt;调试设置-&gt;事件-&gt;中断在新模块DLL处选中，则程序当加载新的DLL时就会停住；<br>运行命令行，输入参数，运行InjectDll.exe程序。<br>将notepad.exe拖入Od 查看其PID 如图：<br><img src="18.png" alt=""><br>还是myhack.dll注入<br><img src="19.png" alt=""><br>在调试界面里的事件选择：<br><img src="20.png" alt=""><br>F9运行会发现myhack.dll<br><img src="21.png" alt=""><br>双击来到myhack.dll 入口点附近，下断点，接下来，将OD的中断在新的DLL入口处关闭，运行，就可以调试DLL程序了<br><img src="22.png" alt=""><br>下来F9运行 断在了刚才设置断点的地方 接下来F8单步运行 运行到这里发现myhack.dll字符串：<br><img src="23.png" alt=""><br>继续运行发现到了这里：<br><img src="24.png" alt=""><br>执行完后，说明这个函数实现了拷贝，但是……为啥要拷贝？<br><img src="25.png" alt=""><br>最后调用URLDownloadToFile() 函数实现下载。观察参数明白了，原来拷贝函数是为了得到下载存储的路径的呀！<br><img src="26.png" alt=""><br>运行程序：发现注入成功了！</p>
<h1 id="使用汇编语言编写注入代码"><a href="#使用汇编语言编写注入代码" class="headerlink" title="使用汇编语言编写注入代码"></a>使用汇编语言编写注入代码</h1><h2 id="新的EPI"><a href="#新的EPI" class="headerlink" title="新的EPI"></a>新的EPI</h2><p>在反汇编窗口右键，选择此处为新EIP，可以修改EIP指向选中的位置，与直接通过调试方式转到指定地址不一样的是，寄存器和栈中的内容未改变</p>
<p><img src="8.png" alt=""></p>
<h2 id="编写ThreadProc函数"><a href="#编写ThreadProc函数" class="headerlink" title="编写ThreadProc函数"></a>编写ThreadProc函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PUSH EBP</span><br><span class="line">MOV EBP,ESP                        ; 生成栈桢</span><br><span class="line">MOV ESI,DWORD PTR SS:[EBP+8]       ; ESI = pParam 从栈上获取函数参数       </span><br><span class="line">PUSH 6C6C                      </span><br><span class="line">PUSH 642E3233</span><br><span class="line">PUSH 72657375</span><br><span class="line">PUSH ESP                           ; - &quot;user32.dll&quot;(ESP为字符串首地址)，LoadLibraryA的参数</span><br><span class="line">CALL DWORD PTR DS:[ESI]            ; LoadLibraryA(&quot;user32.dll&quot;)</span><br><span class="line">PUSH 41786F</span><br><span class="line">PUSH 42656761</span><br><span class="line">PUSH 7373654D</span><br><span class="line">PUSH ESP                           ; - &quot;MessageBoxA&quot;(同上&quot;user32.dll&quot;的解释)</span><br><span class="line">PUSH EAX                           ; - hMod(EAX是LoadLibraryA的返回值)</span><br><span class="line">CALL DWORD PTR DS:[ESI+4]          ; GetProcAddress(hMod, &quot;MessageBoxA&quot;)</span><br><span class="line">PUSH 0                             ; - MB_OK (0)</span><br><span class="line">CALL 0040112C</span><br><span class="line">&lt;ASCII&gt;                            ; - &quot;ReverseCore&quot;, 0</span><br><span class="line">CALL 00401145</span><br><span class="line">&lt;ASCII&gt;                            ; - &quot;www.reversecore.com&quot;, 0</span><br><span class="line">PUSH 0                             ; - hWnd (0)</span><br><span class="line">CALL EAX                           ; MessageBoxA(0, &quot;www.reversecore.com&quot;, &quot;ReverseCore&quot;, 0)</span><br><span class="line">XOR EAX,EAX                        </span><br><span class="line">MOV ESP,EBP</span><br><span class="line">POP EBP                            </span><br><span class="line">RETN</span><br></pre></td></tr></table></figure>
<p>这里有些是字符串的代码 由于OD的原因 才会显示成汇编代码</p>
<h3 id="使用push指令将字符串数据压栈"><a href="#使用push指令将字符串数据压栈" class="headerlink" title="使用push指令将字符串数据压栈"></a>使用push指令将字符串数据压栈</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PUSH 41786F</span><br><span class="line">PUSH 42656761</span><br><span class="line">PUSH 7373654D</span><br></pre></td></tr></table></figure>
<p>这段代码还是比较好理解的，实际上是将字符串压到栈上</p>
<p>可以看到运行到call指令前，栈上的情况如下<br><img src="9.png" alt=""><br>字符串’user32.dll‘即为栈上的\x75\x73\x65\x72\x33\x32\x2e\x64\x6c\x6c</p>
<h3 id="使用call指令将字符串数据压栈"><a href="#使用call指令将字符串数据压栈" class="headerlink" title="使用call指令将字符串数据压栈"></a>使用call指令将字符串数据压栈</h3><p>第二种将字符串保存在代码中的方法为使用call指令</p>
<p>call func_address指令的本质为push eip+4，jmp func_address<br><img src="10.png" alt=""><br>在03d8002e处执行call 03d8003f实际上是执行了push 03d80033, jmp 03d8003f</p>
<p>可以在数据窗口中看出从03d80033到03d8003e存储的内容为ReverseCore的字符串，所以push 03d80033实际上是将字符串的首地址压栈</p>
<p>f7跟进call, 可以看到跳转到的内容如下<br><img src="11.png" alt=""><br>这仍然是一个将字符串压栈的过程，第一行的call指令将首地址为03d90044的字符串“<a href="http://www.reversecore.com”压栈" target="_blank" rel="noopener">www.reversecore.com”压栈</a></p>
<p>然后跳转到03d90058</p>
<p><img src="12.png" alt=""><br>该地址的内容如上图，调用了MessageBoxA函数</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/27/周报4-27/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/27/周报4-27/" itemprop="url">周报4.27</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-27T20:18:19+08:00">
                2019-04-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="OD学习记录（真难啊-QAQ）"><a href="#OD学习记录（真难啊-QAQ）" class="headerlink" title="OD学习记录（真难啊~~~QAQ）"></a>OD学习记录（真难啊~~~QAQ）</h1><h2 id="手动修复IAT"><a href="#手动修复IAT" class="headerlink" title="手动修复IAT"></a>手动修复IAT</h2><p>开始修复IAT。<br>第一步还是先找到OEP，到达OEP后，OD和进程本身不能关掉。脱壳过程中不能把程序关掉。<br>操作过程和之前相同，先选进程，右键，完整转存，脱壳完毕。<br>双击脱壳后的程序，无法打开。<br>第二步：使用importrec修复IAT。不是选择dump后的程序，而是到达OEP的加壳程序。为什么不选择脱壳后的程序呢？<br>因为我们需要提取源文件里的信息，放到脱壳后的文件里。然后放到脱壳后的程序 附件进程后，里面有个选项</p>
<p>如何使用填写这几个数字呢：<br>第一个选项是OEP栏：这里填写OEP的相对偏移地址就行<br>第二个选项是RVA：虚拟内存地址，这里填IAT的起始位置<br>大小：填写导入表大小，需要用IAT的末地址减去首地址。哪个是首地址，哪个是尾部地址？<br>有一个小技巧，能帮我们快速定位到IAT的开始和末尾。怎么做呢，在数据窗口右击-长型-地址，那么它的起始位置<br>就非常直观了：<br><img src="1.jpg" alt=""><br>OEP：10000<br>RVA：3184<br>大小：尾部一定得是00000000才行。而且得是最后一个00000000。<br>接下来就是修复PE头了</p>
<h2 id="打补丁"><a href="#打补丁" class="headerlink" title="打补丁"></a>打补丁</h2><p>程序很简单，只有两个窗口<br><img src="13.png" alt=""><img src="14.png" alt=""><br>（一）、使用OD载入程序，按F9跳转到入口点<br><img src="1.png" alt=""><br>（二）步入第一个call调用<br><img src="2.png" alt=""><br>（三）按f8步进来到40109B处<br>仔细分析这段代码，会发现这段代码的是第一轮解密代码，对004010F5到00401249（004010F5+0x154）这个区段的数据异或0x44<br><img src="3.png" alt=""><br>（四）继续按f8步进来到40109B处，可以发现两个循环，这个两个循环都负责解密<br><img src="4.png" alt=""><br>（五）继续按f8步进程序会返回到00401038处，此处需要主意的校验和计算和比较校验和的值。<br><img src="5.png" alt=""><br>（六）继续运行程序，会发现OEP，如下图<br><img src="6.png" alt=""><br>还有下面的跳转表的啦。。。。<br><img src="7.png" alt=""><br>（七）通过查找DialogBoxParamA的api手册，会发现4010F5是指向对话框的指针，跳转到4010F5这个地址之后，在往下滚动，发现字符串（x32dbg将这个区段解析为指令了，ascii码对的上，只能在内存窗口中查看）。</p>
<p><img src="8.png" alt=""><br>通过分析pe结构，我们会发现.text头会有很多代码洞空白区域<br><img src="9.png" alt=""><br>插入代码。.。。<br><img src="10.png" alt=""><br>修改JMP指令<br>修改前：<br><img src="11.png" alt=""><br>修改后：<br><img src="12.png" alt=""><br>然后就成功了。。。。。。不晓得我为啥有点问题QAQ。。。<br>中途想过之前的方法是直接修改数据窗口的内容来让实现修改  尝试以后发现程序有检测的  不能用 就只能用打补丁的方法咯</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">loser</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">loser</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
