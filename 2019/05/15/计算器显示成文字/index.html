<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="chinese">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="计算器显示成文字将计算器显示的数字通过注入DLL文件显示成数字">
<meta property="og:type" content="article">
<meta property="og:title" content="计算器显示成文字">
<meta property="og:url" content="http://yoursite.com/2019/05/15/计算器显示成文字/index.html">
<meta property="og:site_name" content="loser的博客">
<meta property="og:description" content="计算器显示成文字将计算器显示的数字通过注入DLL文件显示成数字">
<meta property="og:locale" content="chinese">
<meta property="og:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/22.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/23.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/24.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/25.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/26.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/27.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/28.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/29.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/30.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/5.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/6.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/31.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/32.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/33.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/34.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/35.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/36.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/37.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/38.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/39.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/41.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/40.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/42.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/43.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/44.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/45.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/46.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/47.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/48.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/49.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/50.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/2.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/1.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/3.png">
<meta property="og:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/4.png">
<meta property="og:updated_time" content="2019-07-19T12:29:04.238Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="计算器显示成文字">
<meta name="twitter:description" content="计算器显示成文字将计算器显示的数字通过注入DLL文件显示成数字">
<meta name="twitter:image" content="http://yoursite.com/2019/05/15/计算器显示成文字/22.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/05/15/计算器显示成文字/">





  <title>计算器显示成文字 | loser的博客</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="chinese">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">loser的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/15/计算器显示成文字/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">计算器显示成文字</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-15T17:16:31+08:00">
                2019-05-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="计算器显示成文字"><a href="#计算器显示成文字" class="headerlink" title="计算器显示成文字"></a>计算器显示成文字</h1><p>将计算器显示的数字通过注入DLL文件显示成数字</p>
<a id="more"></a>
<h2 id="OD法更改"><a href="#OD法更改" class="headerlink" title="OD法更改"></a>OD法更改</h2><p>首先利用OD修改内存中的值来实现计算器显示中文数字（这次还是在XP虚拟机里运行的）</p>
<p>用OD打开calc.exe 快捷键ctrl+N查看目标文件的API函数 </p>
<p><img src="22.png" alt=""><br>这里我们发现的两个值得关注的API函数 SetWinsowTextW（）和SetDlgItemTextW（） 他们负责向计算器的文本显示框中显示文本 来看看SetWinsowTextW（）API定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOLSetWindowText(</span><br><span class="line">HWNDhwnd,</span><br><span class="line">LPCTSTRlpString</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>hWnd</strong><br>要改变文本内容的窗口或控件的句柄。不能改变在其他应用程序中的控件的文本内容，如果需要可以用另外一个SendMessage函数发送一条WM_SETTEXT消息。</p>
<p><strong>lpString</strong><br>指向一个空结束的字符串的指针，该字符串将作为窗口或控件的新文本。</p>
<p>这里我们关注第二个参考——字符串指针（lpString）钩取时查看字符串（lpString）中的内容 将其中的阿拉伯数字改成中文就行</p>
<p>然后在刚才关注的那两个API函数上设置断点<br><img src="23.png" alt=""><br>运行<br><img src="24.png" alt=""><br>第一次运行断在了SetwindowTextW这里 右下角堆栈窗口发现字符0就是计算器开始的在字符0<br><img src="25.png" alt=""><br>在运行断在了SetDlgItemTextW（）处 再次运行一下 计算器的页面出现了 为了继续调试 我们望计算器中输入7 发现OD自动在SetwindowTextW这里停了</p>
<p><img src="26.png" alt=""><br>看到了刚才说的那两个参数 在数据窗口跟随TEXT那一项发现了储存的数字7<br><img src="27.png" alt=""><br>将中文数字 七 的Unicode码（4e03）覆写到地址处 这里记得要逆序（034e）写入<br><img src="28.png" alt=""><br>发现数字7已经变成汉字七了！<br><img src="29.png" alt=""><br>运行程序在计算器中看到已经变了：<br><img src="30.png" alt=""><br>这里就算完成了OD的过程 对SetWinsowTextW（）API验证结束 接下来看看IAT钩取操作及其实现原理 </p>
<h2 id="IAT钩取工作原理"><a href="#IAT钩取工作原理" class="headerlink" title="IAT钩取工作原理"></a>IAT钩取工作原理</h2><p>IAT钩取通过修改IAT中保存的API地址来钩取某个API 如图：<br><img src="5.png" alt=""><br><img src="6.png" alt=""><br>钩取IAT前 首先向计算器进程注入hookiat.dll文件<br>原理：在保持运行代码不变的情况下 讲IAT中保存的API起始地址变为用户函数的起始地址</p>
<h2 id="练习示例"><a href="#练习示例" class="headerlink" title="练习示例"></a>练习示例</h2><p>先复制文件到工作目录（c:work）然后运行calc.exe程序 再打开任务管理器查看其PID 如图：<br><img src="31.png" alt=""><br>然后在命令窗口执行如图命令：<br><img src="32.png" alt=""><br>接下来在计算器随便输入一些数值 如图：<br><img src="33.png" alt=""><br>我们可以看到 输入的数值已经变成了中文 计算器也在正常运行（其实我自己调试的这个InjectDLL.exe注入的hookiat.dll注入之后计算器显示的是韩文 可能是韩国人整的DLL文件吧 但确实是钩取成功了！！）</p>
<h2 id="源代码分析（hookiat-dll）"><a href="#源代码分析（hookiat-dll）" class="headerlink" title="源代码分析（hookiat.dll）"></a>源代码分析（hookiat.dll）</h2><h3 id="Dllmain（）"><a href="#Dllmain（）" class="headerlink" title="Dllmain（）"></a>Dllmain（）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span><br><span class="line">&#123;</span><br><span class="line">	switch( fdwReason )</span><br><span class="line">	&#123;</span><br><span class="line">		case DLL_PROCESS_ATTACH : </span><br><span class="line">            // 保存原始API的地址</span><br><span class="line">           	g_pOrgFunc = GetProcAddress(GetModuleHandle(L&quot;user32.dll&quot;), </span><br><span class="line">                                        &quot;SetWindowTextW&quot;);</span><br><span class="line"> </span><br><span class="line">            // # hook</span><br><span class="line">            //   用hookiat.MySetWindowText钩取user32.SetWindowTextW</span><br><span class="line">			hook_iat(&quot;user32.dll&quot;, g_pOrgFunc, (PROC)MySetWindowTextW);</span><br><span class="line">			break;</span><br><span class="line"> </span><br><span class="line">		case DLL_PROCESS_DETACH :</span><br><span class="line">            // # unhook</span><br><span class="line">            //   将calc.exe的IAT恢复原值</span><br><span class="line">            hook_iat(&quot;user32.dll&quot;, (PROC)MySetWindowTextW, g_pOrgFunc);</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在DLL_PROCESS_ATTACH事件中先获取user32.SetWindowTextW的地址，然后保存到全局变量g_pOrgFunc中，后面脱钩会用到这个地址。</p>
<h3 id="MySetWindowTextW"><a href="#MySetWindowTextW" class="headerlink" title="MySetWindowTextW()"></a>MySetWindowTextW()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI MySetWindowTextW(HWND hWnd, LPWSTR lpString)</span><br><span class="line">&#123;</span><br><span class="line">    wchar_t* pNum = L&quot;零一二三四五六七八九&quot;;</span><br><span class="line">    wchar_t temp[2] = &#123;0,&#125;;</span><br><span class="line">    int i = 0, nLen = 0, nIndex = 0;</span><br><span class="line"> </span><br><span class="line">    nLen = wcslen(lpString);</span><br><span class="line">    for(i = 0; i &lt; nLen; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //   将阿拉伯数字转换为中文数字</span><br><span class="line">        //   lpString是宽字符版本(2个字节)字符串</span><br><span class="line">        if( L&apos;0&apos; &lt;= lpString[i] &amp;&amp; lpString[i] &lt;= L&apos;9&apos; )</span><br><span class="line">        &#123;</span><br><span class="line">            temp[0] = lpString[i];</span><br><span class="line">            nIndex = _wtoi(temp);</span><br><span class="line">            lpString[i] = pNum[nIndex];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //   调用user32.SetWindowTextW</span><br><span class="line">    //   (修改lpString缓冲区中的内容)</span><br><span class="line">    return ((PFSETWINDOWTEXTW)g_pOrgFunc)(hWnd, lpString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lpString参数是一块缓冲区，该缓冲区用来存放要输出显示的字符串。for循环将存放在lpString的阿拉伯数字字符串转换为中文数字字符串。for循环结束后，最后再调用函数指针g_pOrgFunc。</p>
<p>hook_iat()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">BOOL hook_iat(LPCSTR szDllName, PROC pfnOrg, PROC pfnNew)</span><br><span class="line">&#123;</span><br><span class="line">	HMODULE hMod;</span><br><span class="line">	LPCSTR szLibName;</span><br><span class="line">	PIMAGE_IMPORT_DESCRIPTOR pImportDesc; </span><br><span class="line">	PIMAGE_THUNK_DATA pThunk;</span><br><span class="line">	DWORD dwOldProtect, dwRVA;</span><br><span class="line">	PBYTE pAddr;</span><br><span class="line"> </span><br><span class="line">    // hMod, pAddr = ImageBase of calc.exe</span><br><span class="line">    //             = VA to MZ signature (IMAGE_DOS_HEADER)</span><br><span class="line">	hMod = GetModuleHandle(NULL);</span><br><span class="line">	pAddr = (PBYTE)hMod;</span><br><span class="line"> </span><br><span class="line">    // pAddr = VA to PE signature (IMAGE_NT_HEADERS)</span><br><span class="line">	pAddr += *((DWORD*)&amp;pAddr[0x3C]);</span><br><span class="line"> </span><br><span class="line">    // dwRVA = RVA to IMAGE_IMPORT_DESCRIPTOR Table</span><br><span class="line">	dwRVA = *((DWORD*)&amp;pAddr[0x80]);</span><br><span class="line"> </span><br><span class="line">    // pImportDesc = VA to IMAGE_IMPORT_DESCRIPTOR Table</span><br><span class="line">	pImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)hMod+dwRVA);</span><br><span class="line"> </span><br><span class="line">	for( ; pImportDesc-&gt;Name; pImportDesc++ )</span><br><span class="line">	&#123;</span><br><span class="line">        // szLibName = VA to IMAGE_IMPORT_DESCRIPTOR.Name</span><br><span class="line">		szLibName = (LPCSTR)((DWORD)hMod + pImportDesc-&gt;Name);</span><br><span class="line">		if( !_stricmp(szLibName, szDllName) )</span><br><span class="line">		&#123;</span><br><span class="line">            // pThunk = IMAGE_IMPORT_DESCRIPTOR.FirstThunk</span><br><span class="line">            //        = VA to IAT(Import Address Table)</span><br><span class="line">			pThunk = (PIMAGE_THUNK_DATA)((DWORD)hMod + </span><br><span class="line">                                         pImportDesc-&gt;FirstThunk);</span><br><span class="line"> </span><br><span class="line">            // pThunk-&gt;u1.Function = VA to API</span><br><span class="line">			for( ; pThunk-&gt;u1.Function; pThunk++ )</span><br><span class="line">			&#123;</span><br><span class="line">				if( pThunk-&gt;u1.Function == (DWORD)pfnOrg )</span><br><span class="line">				&#123;</span><br><span class="line">                </span><br><span class="line">					VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, </span><br><span class="line">                                   4, </span><br><span class="line">                                   PAGE_EXECUTE_READWRITE, </span><br><span class="line">                                   &amp;dwOldProtect);</span><br><span class="line"> </span><br><span class="line">                    pThunk-&gt;u1.Function = (DWORD)pfnNew;</span><br><span class="line">				</span><br><span class="line">                    VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, </span><br><span class="line">                                   4, </span><br><span class="line">                                   dwOldProtect, </span><br><span class="line">                                   &amp;dwOldProtect);						</span><br><span class="line"> </span><br><span class="line">					return TRUE;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	return FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数主要负责钩取API</p>
<p>首先从ImageBase开始经由PE签名找到IDT<br><img src="34.png" alt=""><br><img src="35.png" alt=""><br><img src="36.png" alt=""><br>pImportDesc变量中存储着IMAGE_IMPORT_DESCRIPTOR结构体的起始地址，后者是calc.exe进程IDT的第一个结构体。IDT是由IMAGE_IMPORT_DESCRIPTOR结构体组成的数组。若想查找到IAT，先要查找到这个位置。使用PEView查看该地址(00012B80+01000000=01012B80)，如图所示。</p>
<p><img src="37.png" alt=""><br>在for循环中通过比较查找到user32.dll的IMAGE_IMPORT_DESCRIPTOR结构体地址，从上图可以看出最终pImportDesc的值为01012BF4。接下来进入user32的IAT，pImportDesc-&gt;FirstThunk成员所指的就是IAT。使用PEView查看该地址(000010A4+01000000=010010A4)，如图所示</p>
<p><img src="38.png" alt=""><br>接下来又在for循环中查找SetWindowTextW的IAT地址(01001110)，然后修改它的值。因为计算器进程的IAT内存区域是只读的，所以需要使用VirtualProtect在钩取之前将相应的区域改为可读写的，钩取之后再改回来。</p>
<h1 id="调试被注入的DLL文件"><a href="#调试被注入的DLL文件" class="headerlink" title="调试被注入的DLL文件"></a>调试被注入的DLL文件</h1><p>首先运行calc程序 查看其PID的值<br><img src="39.png" alt=""><br>将程序进程附加到OD中 然后在事件中选定中断于新DLL进程 然后将hookiat.dll注入计算器进程<br><img src="41.png" alt=""><br>运行程序发现：<br><img src="40.png" alt=""><br>双击进入hookiat.dll中 接下来取消刚才事件中的中断于新DLL的选项 然后在hookiat模块查找参考字符串寻找DllMain（）代码 当然也可以F7单步跟踪查找 DllMain()函数中使用的字符串有“user32.dll”和“SetWindowTextW”</p>
<p><img src="42.png" alt=""><br>我们发现“user32.dll”有两处“SetWindowTextW”有一处 转到“SetWindowTextW”处：</p>
<p><img src="43.png" alt=""><br>框出来的内容就是DllMain（）函数了</p>
<p>这就是调试注入进程Dll的方法了</p>
<h2 id="Dllmain（）-1"><a href="#Dllmain（）-1" class="headerlink" title="Dllmain（）"></a>Dllmain（）</h2><p><img src="44.png" alt=""><br>这个call语句就是调用hook_iat()<br>步入刚才那个call语句进入hook_iat()</p>
<h2 id="hook-iat"><a href="#hook-iat" class="headerlink" title="hook_iat()"></a>hook_iat()</h2><h3 id="查找IMAGE-IMPORT-DESCRIPTION-Table"><a href="#查找IMAGE-IMPORT-DESCRIPTION-Table" class="headerlink" title="查找IMAGE_IMPORT_DESCRIPTION Table"></a>查找IMAGE_IMPORT_DESCRIPTION Table</h3><p>hook_iat()是负责具体实施IAT钩取的核心函数 下面是调试一下：<br><img src="45.png" alt=""><br>框起来的部分就是IMAGE_IMPORT_DESCRIPTION Table（下面简称“IID Table”）的过程 一时难分代码仅仅用了4行代码就找到了ID Table</p>
<p><img src="46.png" alt=""><br>这个call指令用于调用stricmp（）函数。</p>
<h3 id="在IAT中查找SetWindowTextW-API位置"><a href="#在IAT中查找SetWindowTextW-API位置" class="headerlink" title="在IAT中查找SetWindowTextW API位置"></a>在IAT中查找SetWindowTextW API位置</h3><p>通过便利IID Table比较IID.Name于“user32.dll”字符串 查找到user32.dll的IID  找到之后 下面代码用来查找SetWindowTextW API位置 然后修改其中内容 从而实现对API的钩取</p>
<p><img src="47.png" alt=""><br>cmp语句中ESI的值为user32.dll的IAT起始地址 EBP的值为SetWindowTextW的地址 代码循环进入IAT SetWindowTextW的地址值（ebp的值）</p>
<h3 id="IAT钩取"><a href="#IAT钩取" class="headerlink" title="IAT钩取"></a>IAT钩取</h3><p>IAT钩取代码<br><img src="48.png" alt=""><br>MOV指令用来将MySetWindowTextW的地址覆写到前面从IAT中获取的SetWindowTextW的地址 执行后就变成了执行MySetWindowTextW地址的代码 也就是将数字变成汉字的代码段</p>
<h1 id="隐藏进程"><a href="#隐藏进程" class="headerlink" title="隐藏进程"></a>隐藏进程</h1><h2 id="API代码修改技术的原理"><a href="#API代码修改技术的原理" class="headerlink" title="API代码修改技术的原理"></a>API代码修改技术的原理</h2><p>IAT钩取通过操作进程的特定IAT值来实现API钩取 而API代码修改技术则将API代码的前5个字节修改为JMP XXXXXXXXXX指令来钩取API 调用执行被钩取的API时 JMP XXXXXXXXX就会被执行 转而控制hooking函数 后面描述的是 向process explorer进程（procexp.exe）注入stealth.dll文件后钩取ntdll.ZwQuery-SystemInformation（）API的整个过程（ntdll.ZwQuery-SystemInformation（）API是为了隐藏进程而需要钩取的API）</p>
<h3 id="注入之前"><a href="#注入之前" class="headerlink" title="注入之前"></a>注入之前</h3><p>首先看一下钩取之前正常调用API的进程内存。下图描述的是( 钩取之前)正常调用API的情形<br><img src="49.png" alt=""><br>procexp.exe代码调用ntdll.ZwQuerySystemInformation) API时，程序执行流顺序如下。</p>
<p>①procexp.exe的00422CF7地址处的CALL DWORD PTR DS:[48C69C]指令调 用ntdll.ZwQuerySystemInformation( API ( 48C69C地址在进程的IAT区域中，其值为7C93D92E，它是ntdll.ZwQuerySystemInformation() API的起始地址)。</p>
<p>②相应API执行完毕后，返回到调用代码的下一条指令的地址处。</p>
<h3 id="注入之后"><a href="#注入之后" class="headerlink" title="注入之后"></a>注入之后</h3><p>下面看看钩取指定API后程序执行的过程。先把stealth.dll注人目标进程( procexp.exe),直接修改ntdll.ZwQuerySystemInformation( API的代码( Code Patch ),如图所示。<br><img src="50.png" alt=""><br> 首先把stealth.dll注人目标进程，钩取ntll.ZwQuerySystemInformation( API。ntdll.ZwQuery-SystemInformation(O) API起始地址( 7C93D92E)的5个字节代码被修改为JMP 10001120 (仅修改5个字节代码)。10001 120是stealth.MyZwQuerySystemInformation(函数的地址。此时,在procexp.exe代码中调用ntdll.ZwQuerySystemInformation( API,程序将按如下顺序执行</p>
<p>①在422CF7地址处调用ntdll.ZwQuerySystemInformation() API ( 7C93D92E )。</p>
<p>②位于7C93D92E地址处的( 修改后的) JMP 10001 120指令将执行流转到10001120地址处( hooking函数)。10001 16A地址处的CALL unhook()指令用来将ntdll.ZwQuerySystemInformation(API的起始5个字节恢复原值。</p>
<p>③位于1000119B地址处的CALL EAX(7C93D92E)指令将调用原来的函数（ntdll.ZwQuery-SystemlnformationOAPI)(由于前面已经“脱钩”，所以可以正常调用执行）。</p>
<p>④ntdll.ZwQuerySystemlnformation（）执行完毕后，由7C93D93A地址处的RETN 10指令返回到 stealth.dll代码区域（调用自身的位置）。然后10001212地址处的CALL hook()指令再次钩取 ntdll.ZwQuerySystemlnformation（）API(即将开始的5字节修改为JMP10001120指令）</p>
<p>⑤stealth.MyZwQuerySystemInformation(函数执行完毕后，由10001233地址处的RETN 10命令返回到procexp.exe进程的代码区域，继续执行。</p>
<p>上述过程刚开始看似很难，多看几遍，慢慢就会明白的。<br>使用API代码修改技术的好处是可以钩取进程中使用的任意API。前面讲过的IAT钩取技术仅适用于可钩取的API,而API代码修改技术无此限制，(虽然代码会更复杂一些)使用起来要自由得多。使用API代码修改技术的唯- -限制是， 要钩取的API代码长度要大于5个字节，但是由于所有API代码长度都大于5个字节 所以事实上这个限制是不存在的</p>
<h2 id="练习（HideProc-exe，stealth-dll）"><a href="#练习（HideProc-exe，stealth-dll）" class="headerlink" title="练习（HideProc.exe，stealth.dll）"></a>练习（HideProc.exe，stealth.dll）</h2><p>HideProc exe负责将stealth.dll文件注人所有运行中的进程。Stealth.dll负责钩取(注人stealth.dll文件的)进程的ntdll.ZwQuerySystemInformation() API。接下来我们使用上面2个文件隐藏notepad.exe进程。<br><img src="2.png" alt=""></p>
<h3 id="运行notepad-exe-procexp-exe-taskmgr-exe"><a href="#运行notepad-exe-procexp-exe-taskmgr-exe" class="headerlink" title="运行notepad.exe procexp.exe taskmgr.exe"></a>运行notepad.exe procexp.exe taskmgr.exe</h3><p>首先运行要隐藏的进程notepad.exe(要隐藏的进程) procexp.exe（钩取对象1） taskmgr.exe（钩取对象2）</p>
<h3 id="运行HideProc-exe"><a href="#运行HideProc-exe" class="headerlink" title="运行HideProc.exe"></a>运行HideProc.exe</h3><p>运行HideProc.exe 将stealth.dll文件注入当前运行的所有程序：<br><img src="1.png" alt=""><br>简要介绍一下HideProc.exe命令的几个参数:<br>-hide/-show: -hide 用于隐藏，-show 用于取消隐藏。<br>process name:要隐藏的进程名称。<br>dllpath:要注入的DLL文件路径。</p>
<h3 id="查看进程是否隐藏成功"><a href="#查看进程是否隐藏成功" class="headerlink" title="查看进程是否隐藏成功"></a>查看进程是否隐藏成功</h3><p><img src="3.png" alt=""><br>我们发现任务管理器中的进程已经消失了 可是程序依然在运行 这就证明注入成功了</p>
<h3 id="取消进程隐藏"><a href="#取消进程隐藏" class="headerlink" title="取消进程隐藏"></a>取消进程隐藏</h3><p><img src="4.png" alt=""><br>我们可以发现在procexp.exe taskmgr.exe又能看到进程了</p>
<h2 id="源代码分析"><a href="#源代码分析" class="headerlink" title="源代码分析"></a>源代码分析</h2><h3 id="HideProc-cpp"><a href="#HideProc-cpp" class="headerlink" title="HideProc.cpp"></a>HideProc.cpp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">BOOL InjectAllProcess(int nMode, LPCTSTR szDllPath)</span><br><span class="line">&#123;</span><br><span class="line">	DWORD                   dwPID = 0;</span><br><span class="line">	HANDLE                  hSnapShot = INVALID_HANDLE_VALUE;</span><br><span class="line">	PROCESSENTRY32          pe;</span><br><span class="line"> </span><br><span class="line">	// Get the snapshot of the system</span><br><span class="line">	pe.dwSize = sizeof( PROCESSENTRY32 );</span><br><span class="line">	hSnapShot = CreateToolhelp32Snapshot( TH32CS_SNAPALL, NULL );</span><br><span class="line"> </span><br><span class="line">	// find process</span><br><span class="line">	Process32First(hSnapShot, &amp;pe);</span><br><span class="line">	do</span><br><span class="line">	&#123;</span><br><span class="line">		dwPID = pe.th32ProcessID;</span><br><span class="line"> </span><br><span class="line">        // 鉴于系统安全性的考虑</span><br><span class="line">        // 对于PID小于100的系统进程</span><br><span class="line">        // 不执行DLL注入操作</span><br><span class="line">		if( dwPID &lt; 100 )</span><br><span class="line">			continue;</span><br><span class="line"> </span><br><span class="line">        if( nMode == INJECTION_MODE )</span><br><span class="line">		    InjectDll(dwPID, szDllPath);</span><br><span class="line">        else</span><br><span class="line">            EjectDll(dwPID, szDllPath);</span><br><span class="line">	&#125;</span><br><span class="line">	while( Process32Next(hSnapShot, &amp;pe) );</span><br><span class="line"> </span><br><span class="line">	CloseHandle(hSnapShot);</span><br><span class="line"> </span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先通过SetPrivilege函数调用AdjustTokenPrivileges提升权限，然后在InjectAllProcess中使用CreateToolhelp32Snapshot获取系统中运行的所有进程的列表，使用Process32First与Process32Next将获得的进程信息存放到PROCESSENTRY32结构体变量pe中，进而获取进程的PID。获取了进程的PID后，要根据所用的命令选项来选择调用InjectDll函数还是EjectDll函数。当某进程的PID小于100时，鉴于系统安全性的考虑，忽略对它的操作。</p>
<h3 id="Stealth-dll"><a href="#Stealth-dll" class="headerlink" title="Stealth.dll"></a>Stealth.dll</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// global variable (in sharing memory)</span><br><span class="line">#pragma comment(linker, &quot;/SECTION:.SHARE,RWS&quot;)</span><br><span class="line">#pragma data_seg(&quot;.SHARE&quot;)</span><br><span class="line">    TCHAR g_szProcName[MAX_PATH] = &#123;0,&#125;;</span><br><span class="line">#pragma data_seg()</span><br><span class="line"> </span><br><span class="line">// export function</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line">__declspec(dllexport) void SetProcName(LPCTSTR szProcName)</span><br><span class="line">&#123;</span><br><span class="line">    _tcscpy_s(g_szProcName, szProcName);</span><br><span class="line">&#125;</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>首先看导出函数SetProcName。先创建名为.SHARE的共享内存节区，然后创建g_szProcName缓冲区，最后再由导出函数SetProcName将要隐藏的进程名称保存到g_szProcName中。</p>
<h3 id="DllMain"><a href="#DllMain" class="headerlink" title="DllMain()"></a>DllMain()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span><br><span class="line">&#123;</span><br><span class="line">    char            szCurProc[MAX_PATH] = &#123;0,&#125;;</span><br><span class="line">    char            *p = NULL;</span><br><span class="line"> </span><br><span class="line">    // #1. 异常处理</span><br><span class="line">    // 若当前进程为HookProc.exe则终止，不进行钩取操作</span><br><span class="line">    GetModuleFileNameA(NULL, szCurProc, MAX_PATH);</span><br><span class="line">    p = strrchr(szCurProc, &apos;\\&apos;);</span><br><span class="line">    if( (p != NULL) &amp;&amp; !_stricmp(p+1, &quot;HideProc.exe&quot;) )</span><br><span class="line">        return TRUE;</span><br><span class="line"> </span><br><span class="line">    switch( fdwReason )</span><br><span class="line">    &#123;</span><br><span class="line">        // #2. API Hooking</span><br><span class="line">        case DLL_PROCESS_ATTACH : </span><br><span class="line">        hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, </span><br><span class="line">                     (PROC)NewZwQuerySystemInformation, g_pOrgBytes);</span><br><span class="line">        break;</span><br><span class="line"> </span><br><span class="line">        // #3. API Unhooking </span><br><span class="line">        case DLL_PROCESS_DETACH :</span><br><span class="line">        unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, </span><br><span class="line">                       g_pOrgBytes);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先比较字符串，若进程名为HideProc.exe则不钩取API。发生DLL_PROCESS_ATTACH事件时，调用hook_by_code函数钩取API；发生DLL_PROCESS_DETACH事件时，调用unhook_by_code函数取消API钩取。</p>
<h3 id="hook-by-code"><a href="#hook-by-code" class="headerlink" title="hook_by_code()"></a>hook_by_code()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">BOOL hook_by_code(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew, PBYTE pOrgBytes)</span><br><span class="line">&#123;</span><br><span class="line">    FARPROC pfnOrg;</span><br><span class="line">    DWORD dwOldProtect, dwAddress;</span><br><span class="line">    BYTE pBuf[5] = &#123;0xE9, 0, &#125;;</span><br><span class="line">    PBYTE pByte;</span><br><span class="line"> </span><br><span class="line">    // 获取要钩取的API地址</span><br><span class="line">    pfnOrg = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">    pByte = (PBYTE)pfnOrg;</span><br><span class="line"> </span><br><span class="line">    // 若已经被钩取则返回FALSE</span><br><span class="line">    if( pByte[0] == 0xE9 )</span><br><span class="line">        return FALSE;</span><br><span class="line"> </span><br><span class="line">    // 向内存添加写属性</span><br><span class="line">    VirtualProtect((LPVOID)pfnOrg, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"> </span><br><span class="line">    // 备份原有代码(5字节)</span><br><span class="line">    memcpy(pOrgBytes, pfnOrg, 5);</span><br><span class="line"> </span><br><span class="line">    // 计算JMP地址 (E9 XXXX)</span><br><span class="line">    // =&gt; XXXX = pfnNew - pfnOrg - 5</span><br><span class="line">    dwAddress = (DWORD)pfnNew - (DWORD)pfnOrg - 5;</span><br><span class="line">    memcpy(&amp;pBuf[1], &amp;dwAddress, 4);</span><br><span class="line"> </span><br><span class="line">    // Hook:修改5 byte(JMP XXXX)</span><br><span class="line">    memcpy(pfnOrg, pBuf, 5);</span><br><span class="line"> </span><br><span class="line">    // 恢复内存属性</span><br><span class="line">    VirtualProtect((LPVOID)pfnOrg, 5, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">    </span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它通过修改代码实现API钩取操作。JMP指令的实际形式为E9 XXXXXXXX，XXXXXXXX=要跳转的地址-当前指令地址-当前指令长度(5)。</p>
<h3 id="unhook-by-code"><a href="#unhook-by-code" class="headerlink" title="unhook_by_code()"></a>unhook_by_code()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">BOOL unhook_by_code(LPCSTR szDllName, LPCSTR szFuncName, PBYTE pOrgBytes)</span><br><span class="line">&#123;</span><br><span class="line">    FARPROC pFunc;</span><br><span class="line">    DWORD dwOldProtect;</span><br><span class="line">    PBYTE pByte;</span><br><span class="line"> </span><br><span class="line">    // 获取API地址</span><br><span class="line">    pFunc = GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">    pByte = (PBYTE)pFunc;</span><br><span class="line"> </span><br><span class="line">    // 若已经脱钩则返回FALSE</span><br><span class="line">    if( pByte[0] != 0xE9 )</span><br><span class="line">        return FALSE;</span><br><span class="line"> </span><br><span class="line">    // 向内存添加写属性</span><br><span class="line">    VirtualProtect((LPVOID)pFunc, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"> </span><br><span class="line">    // Unhook</span><br><span class="line">    memcpy(pFunc, pOrgBytes, 5);</span><br><span class="line"> </span><br><span class="line">    // 恢复内存属性</span><br><span class="line">    VirtualProtect((LPVOID)pFunc, 5, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"> </span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>unhook_by_code函数是用来取消钩取的函数，原理就是将函数代码开始的前5个字节恢复原值</p>
<h3 id="NewZwQuerySystemInformation（）"><a href="#NewZwQuerySystemInformation（）" class="headerlink" title="NewZwQuerySystemInformation（）"></a>NewZwQuerySystemInformation（）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS WINAPI NewZwQuerySystemInformation(</span><br><span class="line">                SYSTEM_INFORMATION_CLASS SystemInformationClass, </span><br><span class="line">                PVOID SystemInformation, </span><br><span class="line">                ULONG SystemInformationLength, </span><br><span class="line">                PULONG ReturnLength)</span><br><span class="line">&#123;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    FARPROC pFunc;</span><br><span class="line">    PSYSTEM_PROCESS_INFORMATION pCur, pPrev;</span><br><span class="line">    char szProcName[MAX_PATH] = &#123;0,&#125;;</span><br><span class="line">    </span><br><span class="line">    // 开始前先脱钩</span><br><span class="line">    unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, g_pOrgBytes);</span><br><span class="line"> </span><br><span class="line">    // 调用原始API</span><br><span class="line">    pFunc = GetProcAddress(GetModuleHandleA(DEF_NTDLL), </span><br><span class="line">                           DEF_ZWQUERYSYSTEMINFORMATION);</span><br><span class="line">    status = ((PFZWQUERYSYSTEMINFORMATION)pFunc)</span><br><span class="line">              (SystemInformationClass, SystemInformation, </span><br><span class="line">              SystemInformationLength, ReturnLength);</span><br><span class="line"> </span><br><span class="line">    if( status != STATUS_SUCCESS )</span><br><span class="line">        goto __NTQUERYSYSTEMINFORMATION_END;</span><br><span class="line"> </span><br><span class="line">    // 针对SystemProcessInformation类型操作</span><br><span class="line">    if( SystemInformationClass == SystemProcessInformation )</span><br><span class="line">    &#123;</span><br><span class="line">        // SYSTEM_PROCESS_INFORMATION类型转换</span><br><span class="line">        // pCur是单向链表的头</span><br><span class="line">        pCur = (PSYSTEM_PROCESS_INFORMATION)SystemInformation;</span><br><span class="line"> </span><br><span class="line">        while(TRUE)</span><br><span class="line">        &#123;</span><br><span class="line">            // 比较进程名称</span><br><span class="line">            // g_szProcName为要隐藏的进程名称</span><br><span class="line">            // (=&gt; SetProcName()设置)</span><br><span class="line">            if(pCur-&gt;Reserved2[1] != NULL)</span><br><span class="line">            &#123;</span><br><span class="line">                if(!_tcsicmp((PWSTR)pCur-&gt;Reserved2[1], g_szProcName))</span><br><span class="line">                &#123;</span><br><span class="line">                    // 从链表中删除隐藏进程的节点</span><br><span class="line">                    if(pCur-&gt;NextEntryOffset == 0)</span><br><span class="line">                        pPrev-&gt;NextEntryOffset = 0;</span><br><span class="line">                    else</span><br><span class="line">                        pPrev-&gt;NextEntryOffset += pCur-&gt;NextEntryOffset;</span><br><span class="line">                &#125;</span><br><span class="line">                else		</span><br><span class="line">                    pPrev = pCur;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            if(pCur-&gt;NextEntryOffset == 0)</span><br><span class="line">                break;</span><br><span class="line"> </span><br><span class="line">            // 链表的下一项</span><br><span class="line">            pCur = (PSYSTEM_PROCESS_INFORMATION)</span><br><span class="line">                    ((ULONG)pCur + pCur-&gt;NextEntryOffset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">__NTQUERYSYSTEMINFORMATION_END:</span><br><span class="line"> </span><br><span class="line">    // 函数终止前再次执行API钩取操作，为下次调用准备</span><br><span class="line">    hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, </span><br><span class="line">                 (PROC)NewZwQuerySystemInformation, g_pOrgBytes);</span><br><span class="line"> </span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单分析一下 将SystemInformationClass参数设置为SystemProcessInformation（5）后调用ZwQuerySystemInformation（）API，SystemInformation[in/out]参数中储存的是SYSTEM_PROCESS_INFORMATIN结构体单向链表的起始地址 隐藏某进程之前，先要查找与之对应的链表成员，然后断开其与链表的链接。</p>
<h2 id="利用热补丁技术钩取API"><a href="#利用热补丁技术钩取API" class="headerlink" title="利用热补丁技术钩取API"></a>利用热补丁技术钩取API</h2><p>前面demo程序中通过代码修改技术进行API Hook存在的缺点</p>
<p>1.频繁脱钩，挂钩会造成整体性能下降</p>
<p>2.多线程环境，当一个线程尝试运行某段代码，而另一进程刚好在对该代码进行写操作，这时就会发生冲突，会引起非法访问异常（Access Violation）。《windows核心编程》指出，利用代码修改技术钩取API会对系统安全造成威胁</p>
<h3 id="热补丁（修改7Byte代码）"><a href="#热补丁（修改7Byte代码）" class="headerlink" title="热补丁（修改7Byte代码）"></a>热补丁（修改7Byte代码）</h3><p>Windows系统库中的函数，如kernel32.CreateProcessA/W, user32.MessageBoxA，gdi32.TextOutW有一个相似点</p>
<p>1.API以MOV EDI, EDI指令开始(IA-32 0X8bff)<br>2.API上方有5个NOP指令(IA-32 0X90)<br>微软做此设计的目的就是方便打热补丁。</p>
<p>使用热补丁Hook API的过程如下</p>
<p>1.修改API开始的两个字节MOV EDI,EDI为SHORT JMP指令EB F9, 跳转的目标地址是address_of_api - 5，即5个NOP指令的第一条<br>2.修改5个NOP指令为长跳转E9 XXXXXXXX，跳转到用户自定义API<br>3.用户自定义代码调用原始API时，直接以API+2的地址为API地址调用原API，这样就不会引起内存非法访问</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="DllMain（）"><a href="#DllMain（）" class="headerlink" title="DllMain（）"></a>DllMain（）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span><br><span class="line">&#123;</span><br><span class="line">    char            szCurProc[MAX_PATH] = &#123;0,&#125;;</span><br><span class="line">    char            *p = NULL;</span><br><span class="line"></span><br><span class="line">    // 判断进程名称，不向HideProc2.exe注入dll</span><br><span class="line">    GetModuleFileNameA(NULL, szCurProc, MAX_PATH);</span><br><span class="line">    p = strrchr(szCurProc, &apos;\\&apos;);</span><br><span class="line">    if( (p != NULL) &amp;&amp; !_stricmp(p+1, &quot;HideProc2.exe&quot;) )</span><br><span class="line">        return TRUE;</span><br><span class="line"></span><br><span class="line">    // change privilege</span><br><span class="line">    SetPrivilege(SE_DEBUG_NAME, TRUE);</span><br><span class="line"></span><br><span class="line">    switch( fdwReason )</span><br><span class="line">    &#123;</span><br><span class="line">        case DLL_PROCESS_ATTACH : </span><br><span class="line">            // hook</span><br><span class="line">            hook_by_hotpatch(&quot;kernel32.dll&quot;, &quot;CreateProcessA&quot;, </span><br><span class="line">                             (PROC)NewCreateProcessA);</span><br><span class="line">            hook_by_hotpatch(&quot;kernel32.dll&quot;, &quot;CreateProcessW&quot;, </span><br><span class="line">                             (PROC)NewCreateProcessW);</span><br><span class="line">            //可以看到这里没有对ZwQuerySystemInformation使用热补丁Hook，具体原因见&quot;3.热补丁Hook的缺点&quot;</span><br><span class="line">            hook_by_code(&quot;ntdll.dll&quot;, &quot;ZwQuerySystemInformation&quot;, </span><br><span class="line">                         (PROC)NewZwQuerySystemInformation, g_pOrgZwQSI);</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case DLL_PROCESS_DETACH :</span><br><span class="line">            // unhook</span><br><span class="line">            unhook_by_hotpatch(&quot;kernel32.dll&quot;, &quot;CreateProcessA&quot;);</span><br><span class="line">            unhook_by_hotpatch(&quot;kernel32.dll&quot;, &quot;CreateProcessW&quot;);</span><br><span class="line">            unhook_by_code(&quot;ntdll.dll&quot;, &quot;ZwQuerySystemInformation&quot;, </span><br><span class="line">                           g_pOrgZwQSI);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和之前代码一样，在Dll附加进程的时候调用hook方法，在dll卸载时调用unhook方法</p>
<h4 id="hook-by-hotpatch"><a href="#hook-by-hotpatch" class="headerlink" title="hook_by_hotpatch()"></a>hook_by_hotpatch()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">BOOL hook_by_hotpatch(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew)</span><br><span class="line">&#123;</span><br><span class="line">    FARPROC pFunc;</span><br><span class="line">    DWORD dwOldProtect, dwAddress;</span><br><span class="line">    BYTE pBuf[5] = &#123; 0xE9, 0, &#125;;</span><br><span class="line">    BYTE pBuf2[2] = &#123; 0xEB, 0xF9 &#125;;</span><br><span class="line">    PBYTE pByte;</span><br><span class="line"></span><br><span class="line">    pFunc = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">    pByte = (PBYTE)pFunc;</span><br><span class="line">    if( pByte[0] == 0xEB )</span><br><span class="line">        return FALSE;</span><br><span class="line"></span><br><span class="line">    VirtualProtect((LPVOID)((DWORD)pFunc - 5), 7, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    // 1. NOP (0x90)</span><br><span class="line">    dwAddress = (DWORD)pfnNew - (DWORD)pFunc;</span><br><span class="line">    memcpy(&amp;pBuf[1], &amp;dwAddress, 4);</span><br><span class="line">    memcpy((LPVOID)((DWORD)pFunc - 5), pBuf, 5);</span><br><span class="line">    </span><br><span class="line">    // 2. MOV EDI, EDI (0x8BFF)</span><br><span class="line">    memcpy(pFunc, pBuf2, 2);</span><br><span class="line"></span><br><span class="line">    VirtualProtect((LPVOID)((DWORD)pFunc - 5), 7, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改API中无用的7字节数据，跳转到用户自定义Hook函数</p>
<h4 id="unhook-by-hotpatch"><a href="#unhook-by-hotpatch" class="headerlink" title="unhook_by_hotpatch"></a>unhook_by_hotpatch</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">BOOL unhook_by_hotpatch(LPCSTR szDllName, LPCSTR szFuncName)</span><br><span class="line">&#123;</span><br><span class="line">    FARPROC pFunc;</span><br><span class="line">    DWORD dwOldProtect;</span><br><span class="line">    PBYTE pByte;</span><br><span class="line">    BYTE pBuf[5] = &#123; 0x90, 0x90, 0x90, 0x90, 0x90 &#125;;</span><br><span class="line">    BYTE pBuf2[2] = &#123; 0x8B, 0xFF &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pFunc = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">    pByte = (PBYTE)pFunc;</span><br><span class="line">    if( pByte[0] != 0xEB )</span><br><span class="line">        return FALSE;</span><br><span class="line"></span><br><span class="line">    VirtualProtect((LPVOID)pFunc, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    // 1. NOP (0x90)</span><br><span class="line">    memcpy((LPVOID)((DWORD)pFunc - 5), pBuf, 5);</span><br><span class="line">    </span><br><span class="line">    // 2. MOV EDI, EDI (0x8BFF)</span><br><span class="line">    memcpy(pFunc, pBuf2, 2);</span><br><span class="line"></span><br><span class="line">    VirtualProtect((LPVOID)pFunc, 5, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将7字节数据修改为原数据</p>
<h4 id="NewCreateProcess"><a href="#NewCreateProcess" class="headerlink" title="NewCreateProcess"></a>NewCreateProcess</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI NewCreateProcessA(</span><br><span class="line">    LPCTSTR lpApplicationName,</span><br><span class="line">    LPTSTR lpCommandLine,</span><br><span class="line">    LPSECURITY_ATTRIBUTES lpProcessAttributes,</span><br><span class="line">    LPSECURITY_ATTRIBUTES lpThreadAttributes,</span><br><span class="line">    BOOL bInheritHandles,</span><br><span class="line">    DWORD dwCreationFlags,</span><br><span class="line">    LPVOID lpEnvironment,</span><br><span class="line">    LPCTSTR lpCurrentDirectory,</span><br><span class="line">    LPSTARTUPINFO lpStartupInfo,</span><br><span class="line">    LPPROCESS_INFORMATION lpProcessInformation</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    BOOL bRet;</span><br><span class="line">    FARPROC pFunc;</span><br><span class="line"></span><br><span class="line">    pFunc = GetProcAddress(GetModuleHandleA(&quot;kernel32.dll&quot;), &quot;CreateProcessA&quot;);</span><br><span class="line">    //以API地址+2为函数地址调用CreateProcessA函数</span><br><span class="line">    pFunc = (FARPROC)((DWORD)pFunc + 2);</span><br><span class="line">    bRet = ((PFCREATEPROCESSA)pFunc)(lpApplicationName,</span><br><span class="line">                                     lpCommandLine,</span><br><span class="line">                                     lpProcessAttributes,</span><br><span class="line">                                     lpThreadAttributes,</span><br><span class="line">                                     bInheritHandles,</span><br><span class="line">                                     dwCreationFlags,</span><br><span class="line">                                     lpEnvironment,</span><br><span class="line">                                     lpCurrentDirectory,</span><br><span class="line">                                     lpStartupInfo,</span><br><span class="line">                                     lpProcessInformation);</span><br><span class="line"></span><br><span class="line">    // 注入steach3.dll</span><br><span class="line">    if( bRet )</span><br><span class="line">        InjectDll2(lpProcessInformation-&gt;hProcess, STR_MODULE_NAME);</span><br><span class="line"></span><br><span class="line">    return bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意一点，在使用之前的hook方法进行API钩取时，在用户自定义NewCreateProcess函数开头需要调用unhook方法(防止进入钩取的死循环)，函数结尾需要调用hook方法进行重新钩取。</p>
<p>但是使用热补丁Hook时不需要这样反复脱钩，挂钩，只需在调用原始API时，使用address of API + 2的地址调用API即可</p>
<h3 id="使用热补丁进行Hook的缺点"><a href="#使用热补丁进行Hook的缺点" class="headerlink" title="使用热补丁进行Hook的缺点"></a>使用热补丁进行Hook的缺点</h3><p>热补丁钩取技术有个明显的缺点，即不符合钩取条件（7字节无用代码）的API无法使用热补丁钩取</p>
<p>这样的API有，ntdll.dll提供的API 和kernel32.GetStartInfoA() 等</p>
<p>并非所有API都能使用热补丁钩取，所以使用前需要先确认要钩取的API是否支持，若不支持则需使用前面的5字节代码修改技术</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/09/API钩取/" rel="next" title="API钩取">
                <i class="fa fa-chevron-left"></i> API钩取
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/20/高级全局API钩取：IE连接控制/" rel="prev" title="高级全局API钩取：IE连接控制">
                高级全局API钩取：IE连接控制 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">loser</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#计算器显示成文字"><span class="nav-number">1.</span> <span class="nav-text">计算器显示成文字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#OD法更改"><span class="nav-number">1.1.</span> <span class="nav-text">OD法更改</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IAT钩取工作原理"><span class="nav-number">1.2.</span> <span class="nav-text">IAT钩取工作原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#练习示例"><span class="nav-number">1.3.</span> <span class="nav-text">练习示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#源代码分析（hookiat-dll）"><span class="nav-number">1.4.</span> <span class="nav-text">源代码分析（hookiat.dll）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Dllmain（）"><span class="nav-number">1.4.1.</span> <span class="nav-text">Dllmain（）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySetWindowTextW"><span class="nav-number">1.4.2.</span> <span class="nav-text">MySetWindowTextW()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#调试被注入的DLL文件"><span class="nav-number">2.</span> <span class="nav-text">调试被注入的DLL文件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Dllmain（）-1"><span class="nav-number">2.1.</span> <span class="nav-text">Dllmain（）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hook-iat"><span class="nav-number">2.2.</span> <span class="nav-text">hook_iat()</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查找IMAGE-IMPORT-DESCRIPTION-Table"><span class="nav-number">2.2.1.</span> <span class="nav-text">查找IMAGE_IMPORT_DESCRIPTION Table</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在IAT中查找SetWindowTextW-API位置"><span class="nav-number">2.2.2.</span> <span class="nav-text">在IAT中查找SetWindowTextW API位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IAT钩取"><span class="nav-number">2.2.3.</span> <span class="nav-text">IAT钩取</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#隐藏进程"><span class="nav-number">3.</span> <span class="nav-text">隐藏进程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#API代码修改技术的原理"><span class="nav-number">3.1.</span> <span class="nav-text">API代码修改技术的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#注入之前"><span class="nav-number">3.1.1.</span> <span class="nav-text">注入之前</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注入之后"><span class="nav-number">3.1.2.</span> <span class="nav-text">注入之后</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#练习（HideProc-exe，stealth-dll）"><span class="nav-number">3.2.</span> <span class="nav-text">练习（HideProc.exe，stealth.dll）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#运行notepad-exe-procexp-exe-taskmgr-exe"><span class="nav-number">3.2.1.</span> <span class="nav-text">运行notepad.exe procexp.exe taskmgr.exe</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行HideProc-exe"><span class="nav-number">3.2.2.</span> <span class="nav-text">运行HideProc.exe</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查看进程是否隐藏成功"><span class="nav-number">3.2.3.</span> <span class="nav-text">查看进程是否隐藏成功</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#取消进程隐藏"><span class="nav-number">3.2.4.</span> <span class="nav-text">取消进程隐藏</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#源代码分析"><span class="nav-number">3.3.</span> <span class="nav-text">源代码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HideProc-cpp"><span class="nav-number">3.3.1.</span> <span class="nav-text">HideProc.cpp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stealth-dll"><span class="nav-number">3.3.2.</span> <span class="nav-text">Stealth.dll</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DllMain"><span class="nav-number">3.3.3.</span> <span class="nav-text">DllMain()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hook-by-code"><span class="nav-number">3.3.4.</span> <span class="nav-text">hook_by_code()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unhook-by-code"><span class="nav-number">3.3.5.</span> <span class="nav-text">unhook_by_code()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NewZwQuerySystemInformation（）"><span class="nav-number">3.3.6.</span> <span class="nav-text">NewZwQuerySystemInformation（）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#利用热补丁技术钩取API"><span class="nav-number">3.4.</span> <span class="nav-text">利用热补丁技术钩取API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#热补丁（修改7Byte代码）"><span class="nav-number">3.4.1.</span> <span class="nav-text">热补丁（修改7Byte代码）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#源码分析"><span class="nav-number">3.4.2.</span> <span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DllMain（）"><span class="nav-number">3.4.2.1.</span> <span class="nav-text">DllMain（）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hook-by-hotpatch"><span class="nav-number">3.4.2.2.</span> <span class="nav-text">hook_by_hotpatch()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unhook-by-hotpatch"><span class="nav-number">3.4.2.3.</span> <span class="nav-text">unhook_by_hotpatch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NewCreateProcess"><span class="nav-number">3.4.2.4.</span> <span class="nav-text">NewCreateProcess</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用热补丁进行Hook的缺点"><span class="nav-number">3.4.3.</span> <span class="nav-text">使用热补丁进行Hook的缺点</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">loser</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
