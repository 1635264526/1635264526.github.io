<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">

  

  

  
    <meta name="author" content="loser">
  

  

  

  <title>周报4.20 | loser的博客</title>

  

  
    <link rel="icon" href="/favicon.ico">
  

  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="/css/style.css">
</head>
<body>
  <div id="container">
    <!-- header -->
<header class="header">
  <div class="header-container ">
    <nav class="header-navbar">
      <div class="header-navbar-left">
        <h1 class="header-navbar-logo">
          <a href="/">
            
              <img src="https://qiniu.miiiku.xyz/src/images/logo.png" alt="loser的博客">
            
          </a>
        </h1>
      </div>
      <div class="header-navbar-right">
        <div class="header-navbar-btn">
          <div></div>
          <div></div>
          <div></div>
        </div>
        <ul class="header-navbar-list">
          
            <li class="header-navbar-item"><a href="/">首页</a></li>
          
        </ul>
      </div>
    </nav>
  </div>
</header>

    <section id="main"><!-- 文章详情页 -->

<!-- banner container -->
<div class="banner-container" style="background-image: url(https://qiniu.miiiku.xyz/src/images/banner.jpg)">
  <div class="banner-inner">

    
    

    
    

    
    

    
    
    

    
    
      <h1 class="header-title"><a href="/2019/04/14/周报4-20/">周报4.20</a></h1>
      <h2 class="header-subtitle">
        
          
          <!--
          
  <a href="javascript:;" class="article-date">
    <time datetime="2019-04-14T02:34:28.000Z" itemprop="datePublished">2019-04-14 10:34:28</time>
  </a>

          -->
        
      </h2>
    

    
    
  </div>
</div>

<!-- 文章内容 -->

<div class="body-container">
  <article id="article-content" class="main-container article-content zoom">
    
    

    <div class="article-entry">
      <h1 id="OD学习记录"><a href="#OD学习记录" class="headerlink" title="OD学习记录"></a>OD学习记录</h1><h2 id="通常脱壳的基本步骤如下"><a href="#通常脱壳的基本步骤如下" class="headerlink" title="通常脱壳的基本步骤如下"></a>通常脱壳的基本步骤如下</h2><pre><code>1):寻找OEP
2):转储(PS:传说中的dump)
3):修复IAT(修复导入表)

4):检查目标程序是否存在AntiDump等阻止程序被转储的保护措施,并尝试修复这些问题。以上是脱壳的经典步骤,可能具体到不同的壳的话会有细微的差别。
</code></pre><h2 id="寻找简单壳"><a href="#寻找简单壳" class="headerlink" title="寻找简单壳"></a>寻找简单壳</h2><pre><code>搜索JMP或者CALL指令的机器码(即一步直达法,只适用于少数壳,包括UPX,ASPACK壳).
可以直接搜索长跳转JMP(0E9)或者CALL(0E8)这类长转移的机器码,一般情况下(理想情况)壳在解密完原程序各个区段以后,需要一个长JMP或者CALL跳转到原程序代码段中的OEP处开始执行原程序代码。

除了搜索JMP指令的机器码以外,还可以尝试搜索CALL EAX,CALL EBX,JMP EAX等指令的机器码,因为很多壳是将OEP的值存放在寄存器中,然后通过CALL 某寄存器或者JMP 某寄存器来跳往OEP的。
</code></pre><h2 id="定位OEP"><a href="#定位OEP" class="headerlink" title="定位OEP"></a>定位OEP</h2><pre><code>1).使用OllyDbg自带的功能定位OEP(SFX法)
2).使用Patch过的OD来定位OEP(即内存映像法)
3).堆栈平衡法(即ESP定律法) 适用于一些古老的壳
4).最后一次异常法 在脱壳的过程中发现目标程序产生大量异常的话,就可以使用最后一次异常法

5).利用壳最常用的API函数来定位OEP 壳最常用的API函数,比如GetProcAddress,LoadLibrary。ExitThread有些壳会用。

6).利用应用程序调用的第一个API函数来定位OEP  很多程序(VC++)一开始会调用GetVersion,GetModuleHandleA。
</code></pre><h2 id="什么是IAT？"><a href="#什么是IAT？" class="headerlink" title="什么是IAT？"></a>什么是IAT？</h2><pre><code>拿Cruehead的CrackMe中的MessageBoxA这个API函数来说吧,其入口地址为77D504EA,在我的机器上运行的很好,那些跟我操作系统版本以及User32.dll版本相同的童鞋的机器上该程序运行可能也很正常,但是如果在操作系统版本或者User32.dll的版本跟我的不同童鞋的机器上运行,可能就会出错。为了解决以上兼容问题,操作系统就必须提供一些措施来确保该CrackMe可以在其他版本的Windows操作系统,以及DLL版本下也能正常运行。这时IAT(Import Address Table:输入函数地址表)就应运而生了。
</code></pre><h2 id="手脱UPX-修复IAT"><a href="#手脱UPX-修复IAT" class="headerlink" title="手脱UPX 修复IAT"></a>手脱UPX 修复IAT</h2><pre><code>首先去定位OEP了，用的是加过壳的那个CrackMe的例子，刚好入口地址的函数是PUSHAD就F7单步执行 在寄存器中找到ESP 数据窗口跟随  设置硬件断点 F9运行 就会发现跳转的语句了call或者jmp语句 找到OEP之后 利用PE-TOOL　Dump程序 但是没有修复IAT所以并不能执行，用Import REConstructor修复 下来回到OD 找到IAT函数地址的跳转表 在数据窗口定位到IAT的地址 找到整个IAT的起始地址和终止地址 计算RVA起始地址-映像地址 计算IAT终止地址-起始地址 计算OEP虚拟地址-映像基质 输入到Import REConstructor 单击Get Imports看到Import REConstructor找到了IAT中的每项元素 然后就可以对之前DUMP出来的程序的IAT进行修复了 在用PE TOOL重建PE 之后的程序就可以正常运行啦 然后在OD里修改代码段的虚拟地址就和之前的程序一模一样啦。
</code></pre><h2 id="手脱ASPack"><a href="#手脱ASPack" class="headerlink" title="手脱ASPack"></a>手脱ASPack</h2><pre><code>前面都和UPX壳一样 难点就在IAT这里吧 这两个壳难点都在这里  找到IAT的起始地址和终止地址 题外话  回到正题 不同感觉在于修复IAT那里需要删除垃圾文件 删除完就一样欧克啦。
</code></pre><h2 id="IAT重定向"><a href="#IAT重定向" class="headerlink" title="IAT重定向"></a>IAT重定向</h2><pre><code>这里以telock这个壳为例子，首先还是找OEP  这个跟之前那两个有点不同的是虽是ESP定律 但不能用 说明壳可能有检测硬件断点的东东，然后我使用了OD自带的检测DEP的工具 在调试设置里找到了SFX选择块方式跟踪真正入口 就找到了OPE入口  这个程序的IAT被重新定义过了(这个程序和之前那个程序一样) 在反汇编窗口右键选择查看模块间所有函数调用 可以看到CALL被重新定义到了其他区段 但在里面仔细查看还是能找到直接调用的API函数的 右键跟随 然后找到跳转表 在数据窗口找到IAT 在定位IAT的起始和结束位置的时候,不仅仅要判断是否为系统DLL中的地址还是需要判断其是否为重定向过的地址。
</code></pre>
    </div>

    <div class="article-footer">
      
    </div>

    <div class="article-navs">
      
<nav class="card-container card-article-nav">
  <div class="card-wrap">
    
      <div class="card-item">
        <article>
          
          <a class="card-link article-nav-link" href="/2019/04/17/PE文件结构/"></a>
          <div class="article-nav-caption">Newer</div>
          <div class="article-nav-title">PE文件结构</div>
        </article>
      </div>
    
    
      <div class="card-item">
        <article>
          
          <a class="card-link article-nav-link" href="/2019/04/10/4-13周记/"></a>
          <div class="article-nav-caption">Older</div>
          <div class="article-nav-title">4.13周ji</div>
        </article>
      </div>
    
  </div>
</nav>

    </div>
    
    
  <div id="comment-container" class="comment-container"></div>

  </article>
</div></section>

    <!-- footer container -->
<footer id="footer" class="footer">
  <div class="footer-container">
    <p>&copy; 2019 <a href="/" target="_blank">loser</a></p>

    
      <p id="hitokoto"></p>
      <script src="https://v1.hitokoto.cn/?c=a&amp;encode=js&select=%23hitokoto" defer></script>
    

    

    <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> Theme - <a href="https://github.com/miiiku/flex-block" target="_blank">flex-block</a></p>
  </div>
</footer>
  </div>

  
  <!-- 尾部其他内容 -->

<!-- analytics -->







  
  

<!-- dplayer 视频 -->
<link rel="stylesheet" href="/lib/DPlayer.min.css">
<script src="/lib/DPlayer.min.js"></script>
<script type="text/javascript">
  const dplayer = document.querySelectorAll(".dplayer");
  dplayer && initDPlayer(dplayer);
  function initDPlayer(els) {
    let elsArr = Array.from(els);
    elsArr.forEach(el => {
      let url = el.dataset.url;
      let cover = el.dataset.cover;
      new DPlayer({
        container: el,
        video: { url: url, pic: cover },
        theme: "#b7daff",
        autoplay: false,
        loop: false,
        mutex: true,
      });
    });
  }
</script>


<!-- 瀑布流 -->
<script src="/lib/macy.js"></script>
<script type="text/javascript">

if (document.querySelector(".waterfall-container")) {
  initCss()
  initMacy(".waterfall-container")
}

function initMacy(selector) {
  new Macy({
    container: selector,
    trueOrder: false,
    waitForImages: false,
    useOwnImageLoader: false,
    mobileFirst: true,
    columns: 1,
    margin: {
      y: 16,
      x: '2%',
    },
    breakAt: {
      1200: {
        margin: {
          x: 20
        },
        columns: 4
      },
      940: {
        margin: {
          x: 20
        },
        columns: 3
      },
      520: {
        margin: {
          x: 10
        },
        columns: 2
      },
      400: {
        margin: {
          x: 0
        },
        columns: 1
      },
    }
  });
}

function initCss() {
  let cssStyle = document.createElement("style")
  cssStyle.innerText = `.waterfall-container p { display: block; border-radius: 4px; overflow: hidden; margin: 0; }`
  document.head.appendChild(cssStyle);
}
</script>


<!-- 图片预览 -->
<script src="/lib/zoom.min.js"></script>
<script>
  document.querySelector(".zoom") && zoom(".zoom", {
    margin: 15,
    padding: 15,
    radius: 5,
    specify: "",
    filter: "gallery",
  });
</script>


<script src="/js/script.js"></script>
</body>
</html>